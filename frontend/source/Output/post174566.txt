Insert Character on batch folder rename <body> I have a folder that has several hundreds of thousands of files named like "ABC 123456". I need to add a dash after between the two blocks of text like this "ABC - 123456". Leaving the trailing space.   Automator does not offer a method for counting 4 characters in and inserting an new dash and space.  I have this terminal command and have been tinkering with it.   precodefor file in *.txt do   echo mv "$file" **"$file" count 3 "- "** done /code/pre  Anyone know of an Applescript or can help with the terminal command that will help me rename the files?  <answer174579> If your file names are "ABC 123456" with single space between the first 3 and the following, then you are trying to replace the space with a character (or dash or something), so to look like ABC-123456.  I found this article that explains how to do that.  Example:  Note that the following command will only replace spaces with hyphens. If you need a different substitution you’ll have to modify the command accordingly  precodefor i in *.JPG; do mv "$i" "`echo $i | sed -e 's, ,-,g'`"; done /code/pre  Others:  If you wanted underscores or any other character instead of a hyphen, you’d simply switch the codes, ,-,g/code part of the above command to codes, ,_,g/code.   For how to see this article.  Here is a strongTest/strong on my MBA 10.9.5 (I used a ABC 123456.png file) and placed it in a new folder. Than I did the cd to that directory in Terminal and run   precodefor i in *.png; do mv "$i" "`echo $i | sed -e 's, ,-,g'`"; done /code/pre  Result is, it works great (it renames the file)  How does it work:, it would replace the space in file name on all *.png files in that folder, so make sure to have it on the right folder first.  img src="https://i.stack.imgur.com/xQsRP.jpg" alt="renamed"  <answer174696> The question itself isn't exact too, because the OP talks about:  ul lifiles names like codeABC 123456/code (without extension), but in the example code using code*.txt/code extension/li liemadd a dash between two blocks/em (e.g. where is the space) like codeABC - 123456/code, but in the next taking about codecounting to 4/code and codecount 3/code, e.g. not exacltly clear what the script should do for example if find codeABCD 12/code or codeAB 345/code/li lialso, want keep the trailing space, what is strange - but OK ;)/li /ul  The problem is dividable to 3 separate parts:  ol liselecting the right files for the rename/li lipreparing the new filename, replacing/adding characters into the old one/li lithe "physical" rename/li /ol  Ad "selecting the right files". Selecting the files, can be done by some external utilities, for example by the codefind/code command. The main benefits of the codefind/code are:  ul liit can search files recursively in the sub directories too/li liis possible more precisely select the right files, e.g. exclude directories, select files by time or size and so on. (check from the terminal codeman find/code.)/li /ul  Ad "prepare the new name". This can be done by external programs, like codesed/code or codeawk/code or any program what can manipulate text in shell scripts, emor/em it can be done (in some simple cases such this) withing the codebash/code itself - and is possible to save one expensive command execution. (for hunderts of thousand files it makes a difference).  The following:  precode${file/ /-} /code/pre  substitutes (replaces) one emspace/em (the code/ //code part) with the emdash/em (code/-/code). So it is possible to write  precodemv "$file" "${file/ /-}" /code/pre  and save the codesed/code execution.  strongSo one of the alternative solutions could be/strong, for example the following:  precode#!/bin/bash while IFS= read -r -d $'\0' filename do     newfilename="${filename/ /-}"     [[ "$filename" != "$newfilename" ]] &amp;&amp; echo mv -i "$filename" "$newfilename" done &lt; &lt;(find . -maxdepth 1 -type f -iname "* *.jpg" -print0) /code/pre  The abobe is for the emDRY RUN/em - it only will show, what will be done, for the real execution remove the codeecho/code.  Decomposition:  ul liselecting the right files for the rename: the codefind . -maxdepth 1 -type f -iname "* *.jpg" -print0/code will find all  ul liwhat are only in the current directory (code-maxdepth 1/code)/li liand they're emplain files/em (code-type f/code)/li liand their name matches em(anything)(space)(anything).jpg/em case insensitively - e.g. the name must contains a space/li lisupply the filenames as emnull terminated/em, so their name can safely contain newline character too. (code-print0/code)/li /ul/li lithe cycle codewhile IFS= read -r -d $'\0' filename; do ... done &lt; &lt;( )/code  ul lireads the output from the above codefind/code command/li liwhere the filenames are emnull terminated/em (code-d $'\0'/code)/li liignore any escaped characters (code-r/code) /advanced topic - not needed to explained here//li lithe codeIFS=/code  prevents trimming of leading and trailing whitespace from the filename (also, a bit advanced topic)/li /ul/li lipreparing the new filename codenewfilename="${filename/ /-}"/code  ul liis done by codebash/code internally (without executing an external command)./li liif want preserve the trailing space after the dash use code${filename/ /- }/code/li /ul/li lithe actual renaming is done by the codemv/code command (see codeman mv/code from the terminal), where  ul lithe code-i/code what will ask the user if here are already a file with the new filename (don't override it)/li /ul/li liand the codemv/code is executed only when the codenewfilename/code is different from the codefilename/code code[[ "$filename" != "$newfilename" ]]/code/li /ul  The above solution is mostly error-prone, but it still isn't very effective, because for hundreds of thousand files will execute hundreds of thousand times the codemv/code command. The solution can be: using some utility, what can read the filenames and do the renaming without executing the codemv/code command N-times. For example, the "big gun" of system admins the "perl", as:  precodefind . -maxdepth 1 -type f -iname "*.jpg" -print0 |\     perl -0nle '$n=$_; $n=~s/ /-/; rename $_,$n unless($_ eq $n || -e $n)' /code/pre  what will rename all files what outputs the codefind/code in one execution - e.g. much faster as thousands of codemv/code executions.  Tor testing (DRY RUN) use the following:  precodefind . -maxdepth 1 -type f -iname "*.jpg" -print0 |\     perl -0nle '$n=$_; $n=~s/ /-/; print qq{old:$_ new:$n\n} unless($_ eq $n || -e $n)' #print instead of the rename /code/pre  Ps: the perl is powerful enough to handle everything itself, eg. the find command too, but it is more advanced topic...  Ps2: my English is much worse as my codebash/code, so someone could kindly edit this post for adding/correcting things.. ;) 
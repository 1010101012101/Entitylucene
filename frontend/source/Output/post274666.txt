Paradox in understanding the "order of booting" of programs given by $PATH <body> h1Background/h1  This tutorial on how to "properly install git" on OSX 10.8.5, says:     To strongrun the latest version/strong you need to adjust your shell path so that   strong/usr/bin/git/strong runs strongemafter/em/strong strong/usr/local/bin/strong      ...      So add into the path strong[in my case: ~/.bash_profile]/strong similar to the below and keep what you already   have in the path, each segment is separated by a colon:      codeexport PATH="/usr/local/bin:/usr/bin/git:/usr/bin:/usr/local/sbin:$PATH"/code   precode                                   ^ Focus on this /code/pre  hr  So my understanding is this:   ul liwhen I log in, BASH will give priority to whatever is appended further on the right-hand side of the codeexport PATH=.../code line /li li$PATH is at the righter-most code:/code delimited entry in the codeexport PATH=.../code line /li li$PATH contains code/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin/code/li /ul  So... If my assumptions are correct, then surely the tutorial (quoted above) should have looked like:  codeexport PATH="$PATH:/usr/bin/git"/code  Instead of:  codeexport PATH="/usr/local/bin:/usr/bin/git:/usr/bin:/usr/local/sbin:$PATH"/code  hr  h1My questions are:/h1  Is the tutorial wrong? If not, then what of my assumptions are wrong? If my assumptions are not wrong AND the tutorial is not wrong, please explain why...  hr  Note: I am aware this may not really be relevant to OSX 10.8.5, in which case please flag as off-topic to the appropriate Stack Exchange. But AFAIK, my Ubuntu machine has worked fine with ~/.bashrc having stuff like:  codeexport PATH=$PATH:&lt;myProgram1&gt;:&lt;myProgram2&gt;:.../code  So it may be that BASH behaves differently in OSX? I don't know...   <answer274704> The tutorial is badly worded, one should emnever/em include a binary (like code/usr/bin/git/code) into codePATH/code, only directories. A better alternative would be to write     To run the latest version you need to adjust your shell path so that code/usr/local/bin/code is searched embefore/em code/usr/bin/code   So if you set codePATH/code to code/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin/code the manually installed version of codegit/code will be picked from code/usr/local/bin/code.  PS: Handling of codePATH/code works the same for all Unix-based systems, the various directories are searched for the command from left to right.  <comment345410> If `/usr/bin/git` is supposed to be after `/usr/local/bin`, then use `export PATH="$PATH:/usr/bin/git"`, it's just that simple! <comment345412> @user3439894, cheers for now... but I think I would like some more specific details on how BASH works with OSX... if for example, the tutorial's version "worked" it would mean my whole understanding of BASH (at least in OSX) was wrong <comment345414> If you want to know how `bash` works, read its man page. How bash is depends more on its version then the OS. OS X/macOS tends to have older versions of bash then current Linux Distros. <comment345482> You can also use the command `which` to determine, which command will be used.  Just open your terminal and say `which git` and it will answer `/usr/bin/git` (in my case, yours might vary). <comment345505> Beware: the command `which` is based on your `PATH` within some shells. Rather use the builtin `type` which is made to analyse it but without depending on your `PATH`. <comment345681> perhaps this is a paradigm shift for me... my understanding was the reverse. This essentially means @user3439894 was wrong in his comment on the OP? "If /usr/bin/git is supposed to be after /usr/local/bin, then use export PATH="$PATH:/usr/bin/git", it's just that simple!" <comment345682> @hello_there_andy user3439894 probably was led astray by the wording in the tutorial. "adjust your shell path so that /usr/bin/git runs after /usr/local/bin" just doesn't make sense. <comment345683> @danielAzuelos both `which` and `type` rely on `PATH` (where should `type` look for commands if not in the `PATH`?). Or are you referring to `type`'s ability to look into the command cache of bash? <comment345685> Yes you are right, both commands analyze `PATH` but on the versions I read the source code for `csh`, `which` is a shell script using the `PATH` setting, and may fail if there is an error in its definition within `.cshrc` where type is an internal function not reading any user configuration file, and thus safer. <comment345693> @danielAzuelos Do shell scripts read `.cshrc`? Otherwise the PATH definition should be the same anyway <comment345695> Yes they do. I adopted this religion against `which` since a time where a typing error in `.cshrc` made this function to enter a recursive loop.
Are Bash, Bourne, and Korn shells compiled into one binary in OSX? <body> On OSX 10.8, if you compare the binaries for bash, sh, and ksh, a few different shell options, they are the same size.  If you take it further and codecmp/code the binaries, there seems to be only a single-byte difference between the binaries.  This superficially seems to indicate that all of the code to support all of the different shells is available in each binary, but which subset you have access to depends on which shell you end up executing.  ol liCan anyone confirm that the binaries are in fact compiled this way? br //li liFrom Apple's point of view, is their any benefit in combining all of the shells in this manner?/li /ol  <answer89314> I think your basic assumption is wrong. Checking on 10.8.3:  precodepse@Fourecks:~$ ls -l $(type -p sh bash ksh) -r-xr-xr-x  1 root  wheel  1333920 Oct 16  2012 /bin/bash* -r-xr-xr-x  1 root  wheel  1380304 Oct 16  2012 /bin/ksh* -r-xr-xr-x  1 root  wheel  1334000 Oct 16  2012 /bin/sh* pse@Fourecks:~$ cmp -l $(type -p sh bash) | wc -l cmp: EOF on /bin/bash  1138124 pse@Fourecks:~$ cmp -l $(type -p sh ksh) | wc -l cmp: EOF on /bin/sh  1238180 /code/pre  Technically speaking there are some similarities between codesh/code and codebash/code (and the later also can be made to behave like codesh/code) but codeksh/code is definitively coming from a different source base:  ul lihttp://opensource.apple.com/source/bash/bash-86.1//li lihttp://opensource.apple.com/source/ksh/ksh-18//li /ul  <answer89327> ksh and bash are completely different, but the bash and sh binaries are mostly identical. OS X's sh is a version of bash that:  ul liHas POSIX mode enabled. bash doesn't comply to POSIX by default./li liHas different startup behavior. For example codesh -l/code doesn't read code~/.bash_profile//code./li liHas xpg_echo enabled by default. So codeecho/code acts like codeecho -e/code and it doesn't support any options./li /ul  The default FCEDIT is ed in sh but EDITOR or ed in bash:  precode$ diff -y --suppress-common-lines -W 80 &lt;(strings /bin/bash) &lt;(strings /bin/sh)                                       &gt; /bin/bash ${FCEDIT:-${EDITOR:-ed}}              | ${FCEDIT:-ed} @(#)PROGRAM:bash  PROJECT:bash-86.1   | @(#)PROGRAM:sh  PROJECT:bash-86.1 $ grep -rF '${FCEDIT:-${EDITOR:-ed}}' ~/Code/Source/bash-86.1/ bash-86.1/bash-3.2/builtins/fc.c:#  define POSIX_FC_EDIT_COMMAND "${FCEDIT:-${EDITOR:-ed}}" bash-86.1/bash-3.2/builtins/fc.def:#  define POSIX_FC_EDIT_COMMAND "${FCEDIT:-${EDITOR:-ed}}" /code/pre  The source can be downloaded from http://opensource.apple.com/tarballs/.  From man bash:     If bash is invoked with the name sh, it tries to mimic the startup behavior of historical versions of sh as closely as possible, while conforming to the POSIX standard as well.   It doesn't emulate other aspects of the original Bourne shells though.  The original Bourne shells are no longer maintained, and /bin/sh is now meant to be some other shell that just complies to POSIX. OS X's sh allows using bashisms that don't necessarily work with the /bin/sh on other platforms (like dash on Ubuntu).  <comment104768> Oh yeah, you're definitely right; should have been looking at cmp -l rather than just cmp.  Thanks. <comment104778> Interestingly, /bin/sh actually *is* bash (although it'll run in sh-emulation mode based on the name). In some past versions of OS X it's been either a hard link to /bin/bash or an identical copy, but at least in 10.8.3 it's slightly different. /bin/ksh, on the other hand, is a truly different program that just happens to be about the same size. <comment104799> very detailed, would upvote if I could, thanks!
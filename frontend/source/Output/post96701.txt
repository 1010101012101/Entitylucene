Sublime Text like fuzzy filesystem search for Mac OS X <body> Currently I am using Alfred's filesystem navigation capabilities. It's pretty awesome, but sometimes I want fuzzy-search to match not only the filename but the full path.  E.g. I want to find a pdf file with some very common filename (say proposal.pdf). And I have a directory structure like this:  precode - dropbox    - partners      - supercorp        - proposal.pdf      - megacorp        - proposal.pdf /code/pre  It would be nice if I can type codedro/meg/propos/code to get to the megacorp's proposal file. The answer may be the Alfred plugin or some configuration, but I'll accept any solution that allows me to quickly navigate to this file and perform some action (e.g. reveal in Finder or something). "Search-as-you-type" functionality is very important.  strongUPD/strong Just found a similar question. Seems that full path matching feature is missing because codemdfind/code is only searching the file name and all the tools are using it internally.  <answer96799> Easy Find, free, from DevonTechnologies allows you to search files, folders or both, in anything from single folders or the entire disk - as well as use easily selected criteria: fuzzy, invisible, name, contents etc.   Hard to estimate how many hundred hours it's saved me over the years while Apple futzes with Spotlight and Saved Search. Finds, nearly instantly, emanything/em.  <answer96946> There is a kMDItemPath attribute, but it can't be used in queries. You can grep the output of mdfind though:  precode$ pp() { path="/${1%/*}/"; mdfind "name:${1##*/}" | grep -i "${path//\//.*\/}"; } $ time pp desk/ante /Library/Desktop Pictures/Antelope Canyon.jpg 0.365 /code/pre  Matching kMDItemFSName is often a lot slower:  precode$ time mdfind "kMDItemFSName=\"ante.*\"c" | grep -i '/desk.*/' /Library/Desktop Pictures/Antelope Canyon.jpg 10.232 /code/pre  I tried creating a script filter like this in Alfred:  precodeq="{query}"  shopt -s nocasematch  amp() {   local o=${1//&amp;/&amp;amp;}   o=${o//&lt;/&amp;lt;}   printf %s "${o//&gt;/&amp;gt;}" }  output='&lt;?xml version="1.0"?&gt; &lt;items&gt; '  while IFS= read -r l; do   path=$(amp "$l")   output+="&lt;item&gt; &lt;arg&gt;$path&lt;/arg&gt; &lt;title&gt;$(amp "${l##*/}")&lt;/title&gt; &lt;subtitle&gt;$path&lt;/subtitle&gt; &lt;icon type=\"fileicon\"&gt;$path&lt;/icon&gt; &lt;/item&gt; " done &lt; &lt;(if [[ $q =~ .+/.+ ]]; then   dir=${q%/*}   mdfind "name:${q##*/}" | while IFS= read -r l; do     [[ ${l%/*} = */${dir//\/*/}* ]] &amp;&amp; echo "$l"   done else   mdfind "kind:folder name:$q" fi | head -n20)  echo "$output&lt;/items&gt; &lt;/xml&gt;" /code/pre  I couldn't get it to work relibaly though, and it often took multiple seconds to update the results.  <answer181260> Add this in ~/.bash_profile (you can replace codecd/code with codeopen/code)  precodeexport PATH=$PATH:~/bin  cds(){   cd "$(find . -type d -maxdepth 3 | selecta)" } /code/pre  And add selecta from https://github.com/garybernhardt/selecta/blob/master/selecta into ~/bin  Now when you launch a terminal you can type cds and start searching!  AppleScript file to open iTerm and enter cds automatically: cds.applescript  precodeactivate application "iTerm" tell application "System Events" to keystroke "t" using command down tell application "iTerm" to tell session -1 of current terminal to write text "cds" /code/pre  you can test the script using the command codeosascript cds.applescript/code You could even set up a keyboard shortcut to call it: http://www.macdevcenter.com/pub/a/mac/2007/06/08/hit-and-run-launching-applescripts-with-keyboard-shortcuts.html?page=1  <answer215156> You may try Findspot. Findspot supports these features  ol liFuzzy search like Sublime Text's Control-P/li liFull path search/li liSearch as you type/li /ol  Here is a screenshot of Findspot when using your example:  img src="https://i.stack.imgur.com/v73LR.png" alt="enter image description here"  Actually, you can skip the slashes and you will still get the same result.  <answer276756> Why u need fuzzy search in spotlight, if terminal is here? open dro[tab]meg[tab]prop[tab]  also you can configure your .bash_profile to additionals.   <comment113522> Alfred can navigate the file system, with autocompletion. If you type `~`, and then type `dro`, pressing Enter autocompletes `Dropbox`. Then `meg` would match `megacorp`, etc. That’s not quite path matching, but it might be useful. Once you’ve found the file in Alfred, press the right arrow key and you can access file actions. <comment113525> Thanks, alexwlchan. Alfred's "File Navigation" feature is very useful and I use it a lot, while just "exploring" new directory structure. I need a matching in the case when I am already familiar with structure and want to go-to-things faster. <comment113699> I just tried Easy Find and found no way to match full file path - it matches only the filename like Alfred and Spotlight. Maybe I am missing something though. <comment113808> All the usual columns are there -- size, date, etc. -- sometimes they just need to be dragged wider. "Where" shows the path. Also, clicking on a column header sorts by. <comment113826> Great answer. I also create a simple proof-of-concept script filter for Alfred, using `mdfind | grep` way. See [gist](https://gist.github.com/vbo/6060982). It's very far from ideal though. I'll try to use it on my own for some time to fix some bugs and maybe I come up with some improvements. But for now I don't think that this approach (or yours) can be used in the robust ready-made solution. <comment113828> Columns are there, but search matches only the filename. If I am wrong, please add a precise instructions on how to get it working. <comment113872> As far as search matching, that has to be set up in all the choices down the left side. Files and/or folders, visible or not, etc. Narrow down the location to search in the pull-down at top right that starts with hard disk name. <comment348404> Welcome to Ask Different!  We're trying to find the best answers and those answers will provide info as to why they're the best.  Answers should be self-contained so explain why you think the answer you provided will solve the problem or is better than others out there.  Providing links as supporting information can also help the OP, and others, find additional info for themselves.  See [answer] on how to provide a quality answer. - From Review
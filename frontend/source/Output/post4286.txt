Is there a Mac OS X Terminal version of the "free" command in Linux systems? <body> On Linux, I often use the free command to see the current amount of strongfree and used memory/strong in the system. For example:  precode$ free              total       used       free     shared    buffers     cached Mem:       7264256    1010952    6253304          0     371892     189088 -/+ buffers/cache:     449972    6814284 Swap:      8126456         28    8126428 /code/pre  It does not seem to exist when I enter codefree/code in Mac OS X's Terminal. Is there an alternative?  <answer4289> Judging by your other question, I think you've found the use of the Activity Monitor utility to look at your memory status, right?  Just for the record, it's in /Applications/Utilities/Activity Monitor.app.  <answer4296> As @khedron says, you can see this info in Activity Monitor.  If you want it on the command line, here is a Python script that I wrote (or perhaps modified from someone else's, I can't remember, it's quite old now) to show you the Wired, Active, Inactive and Free memory amounts:  precode#!/usr/bin/python  import subprocess import re  # Get process info ps = subprocess.Popen(['ps', '-caxm', '-orss,comm'], stdout=subprocess.PIPE).communicate()[0].decode() vm = subprocess.Popen(['vm_stat'], stdout=subprocess.PIPE).communicate()[0].decode()  # Iterate processes processLines = ps.split('\n') sep = re.compile('[\s]+') rssTotal = 0 # kB for row in range(1,len(processLines)):     rowText = processLines[row].strip()     rowElements = sep.split(rowText)     try:         rss = float(rowElements[0]) * 1024     except:         rss = 0 # ignore...     rssTotal += rss  # Process vm_stat vmLines = vm.split('\n') sep = re.compile(':[\s]+') vmStats = {} for row in range(1,len(vmLines)-2):     rowText = vmLines[row].strip()     rowElements = sep.split(rowText)     vmStats[(rowElements[0])] = int(rowElements[1].strip('\.')) * 4096  print 'Wired Memory:\t\t%d MB' % ( vmStats["Pages wired down"]/1024/1024 ) print('Active Memory:\t\t%d MB' % ( vmStats["Pages active"]/1024/1024 )) print('Inactive Memory:\t%d MB' % ( vmStats["Pages inactive"]/1024/1024 )) print('Free Memory:\t\t%d MB' % ( vmStats["Pages free"]/1024/1024 )) print('Real Mem Total (ps):\t%.3f MB' % ( rssTotal/1024/1024 )) /code/pre  As you can see, you can just call codevm_stat/code from the command line, though it counts in 4kB pages, hence the script to convert to MB.  The script also counts up the "real memory" usage of all running processes for comparison (this won't match any specific value(s) from overall memory stats, because memory is a complex beast).  hr  Here's an example of the output of the script on my system:  precode[user@host:~] % memReport.py Wired Memory:           1381 MB Active Memory:          3053 MB Inactive Memory:        727 MB Free Memory:            1619 MB Real Mem Total (ps):    3402.828 MB /code/pre  em(very slightly adjusted to match the tab sizing on StackExchange ;)/em  <answer18341> You might try the command codeallmemory/code if you want a command line tool that reports extremely detailed memory usage.  <answer19107> precodefree="$(( $(vm_stat | awk '/free/ {gsub(/\./, "", $3); print $3}') * 4096 / 1048576)) MiB free" /code/pre  <answer19112> There is a terminal command similar to codefree/code on Mac OS X... it is called codetop/code  For further information you can check out this Apple Support document.  strongMac OS X: How to View Memory Usage With the "top" Utility/strong  <answer38478> This runs at my $PS1:  https://github.com/vigo/dotfiles-universal/blob/master/prompts/free_memory  (Ruby version: https://github.com/vigo/dotfiles-universal/blob/master/prompts%2Ffree_memory.rb )  <answer40712> precode#!/bin/bash top -l 1 | grep PhysMem: | awk '{print $10}' /code/pre  hr  For Unix experts only:  precodetop -l 1 | awk '/PhysMem:/ {print $10}' /code/pre  <answer46655> It seems the reason it's slow is because codetop -l 1/code always delays by one second after completing, the standard delay between refreshes.  Adding -s 0 to the command makes it complete instantly:  precodetop -l 1 -s 0 | grep PhysMem /code/pre  Also, for clarity, I like showing each mem-component on its line, so I added 9 spaces for alignment with 'PhysMem: ' in the sed replacement string:  precodetop -l 1 -s 0 | grep PhysMem | sed 's/, /\n         /g' /code/pre  <answer48195> Just taking the solution from @zack and adding inactive and speculative blocks.  precode#!/bin/bash  FREE_BLOCKS=$(vm_stat | grep free | awk '{ print $3 }' | sed 's/\.//') INACTIVE_BLOCKS=$(vm_stat | grep inactive | awk '{ print $3 }' | sed 's/\.//') SPECULATIVE_BLOCKS=$(vm_stat | grep speculative | awk '{ print $3 }' | sed 's/\.//')  FREE=$((($FREE_BLOCKS+SPECULATIVE_BLOCKS)*4096/1048576)) INACTIVE=$(($INACTIVE_BLOCKS*4096/1048576)) TOTAL=$((($FREE+$INACTIVE))) echo Free:       $FREE MB echo Inactive:   $INACTIVE MB echo Total free: $TOTAL MB /code/pre  <answer50109> The command you need is codevm_stat/code - similar to the traditional Unix tool codevmstat/code but with a few MACH-specific differences. The man page is well written.  <answer91128> h2Bash commands "free like" for Mac OSX./h2  This is the second reissue of this post. At first, I got two code-1/code. One because I was not describing in English, it is corrected. The other because I used codegawk/code (which is not part of a standard OS X installation), it is also corrected, I now use codeawk/code. The code-2/code are still there ;-). The best is perhaps now to test and evaluate the commands it themselves?  I reviewed my first idea to build only one end-user oriented command with a friendly and highly configurable display, I made two:  ul licodefree-like.sh/code a script always oriented "end user", with more accuracy, a "friendly" and configurable display, but with more calculations and resource consumption,/li licodefree-like-raw.sh/code, a command now oriented developer, sysadmin, etc.., with less computation and resource consumption, but also with less precision, less  "friendly" display./li /ul  The data for the physical memory are extracted from the results of the command codevm_stat/code (which returns the results in blocksize). The imprecision resulting from the transformation in bytes (number_of_blocks * block_size, the default value of the calculations) will be between 0 &lt; the size of the block. The data for virtual memory are taken from the codetop/code command. The imprecision here is linked to the unit of reference of the codetop/code command: kilo, mega, giga.  Calculations are made using codeawk/code that respects rounded (as opposed to codebc/code). codeawk/code is also quicker than codebc/code. You can see the test script here: http://myblog.robert.sebille.name/article29.html#awk-bc  You can view the results of the commands in bytes (default), in kilo, mega or giga, with x decimal places in the case of free-like.sh and if you ask the display in mega ou giga.  The scripts are too long for a post, but you can find them on this article of my blog: http://myblog.robert.sebille.name/article29.html  The article is in french, but it display one example of display for each command and their integrated help (code./free-like.sh -h/code and code./free-like-raw.sh -h/code), in english. These aids completely describe the commands. The article display also the codes.   English is not my mother language. If somebody wants to correct errors in the integrated help, he is welcome ;).  yours.  <answer94258> Here's a simple one-liner to make the whole codevm_stat/code output more human friendly:  precode$ vm_stat | perl -ne '/page size of (\d+)/ and $size=$1; /Pages\s+([^:]+)[^\d]+(\d+)/ and printf("%-16s % 16.2f Mi\n", "$1:", $2 * $size / 1048576);' free:                     2330.23 Mi active:                   2948.07 Mi inactive:                 1462.97 Mi speculative:               599.45 Mi wired down:                840.46 Mi copy-on-write:           43684.84 Mi zero filled:            385865.48 Mi reactivated:               608.14 Mi /code/pre  <answer110459> In case you're only really interested in swap usage (what would be the last line of output from codefree/code):  precode$ sysctl vm.swapusage vm.swapusage: total = 64.00M  used = 0.00M  free = 64.00M  (encrypted) /code/pre  <answer112648> There's no exact equivalent that's distributed with Mac OS X, but there are a couple other ways to get the information:  ol licodesystem_profiler/code - Shows all of the Mac's System Profile info in the shell /li licodesysctl -a | grep mem/code or codesysctl hw.memsize/code (total mem)/li /ol  <answer118956> The above is way too much effort for my liking, and it assumes that you have a fully fledged install too... If you've booted from a Mac OS X start up disk, then all the above solutions obviously won't work... Just use the command "hostinfo", here's the output from my mid 2012 MBAir running Mavericks (10.9.1):  precode Mach kernel version:  Darwin Kernel Version 13.0.0: Thu Sep 19 22:22:27 PDT 2013; root:xnu-2422.1.72~6/RELEASE_X86_64 Kernel configured for up to 4 processors. 2 processors are physically available. 4 processors are logically available. Processor type: i486 (Intel 80486) Processors active: 0 1 2 3 Primary memory available: 8.00 gigabytes Default processor set: 195 tasks, 961 threads, 4 processors Load average: 1.61, Mach factor: 2.38 /code/pre  The good this about this command is that it comes preinstalled with the 10.9 installer too under code/usr/bin/code, so it's very handy,   ideally, if you just want RAM then issue:  precode$ hostinfo | grep memory /code/pre  Don't know if hostinfo exists on any previous OSes though...  <answer212888> precodetop -l 1 -s 0 | awk ' /Processes/ || /PhysMem/ || /Load Avg/{print}' /code/pre  This should do nicely :)  <answer216657> codevm_stat/code shows you in kilobytes.  The oneliner below shows in megabytes:  precodepaste &lt;(vm_stat | awk 'NR&gt;1' | grep -o ".*:") &lt;(for i in $(vm_stat | awk 'NR&gt;1' | tr -d '.' | awk '{print $NF}'); do perl -e "print $i/1024" | awk '{printf "%0.2f", $0}'; echo; done) | column -s: -t /code/pre  Returns:  precodePages free                      11.06 Pages active                    798.25 Pages inactive                  776.03 Pages speculative               9.15 Pages throttled                 0.00 Pages wired down                303.27 Pages purgeable                 0.95 "Translation faults"            82172.66 Pages copy-on-write             11629.60 Pages zero filled               27685.41 Pages reactivated               1450.70 Pages purged                    91.66 File-backed pages               430.20 Anonymous pages                 1153.24 Pages stored in compressor      481.75 Pages occupied by compressor    149.91 Decompressions                  1277.92 Compressions                    1622.33 Pageins                         13198.02 Pageouts                        66.61 Swapins                         54.34 Swapouts                        90.63 /code/pre  <answer238922> You can try the codememory_pressure/code command. See the following output of my system (i5, 4 Gb RAM):  precodeThe system has 2147483648 (524288 pages with a page size of 4096).  Stats:  Pages free: 90009  Pages purgeable: 139593  Pages purged: 7496548   Swap I/O: Swapins: 470466  Swapouts: 530913   Page Q counts: Pages active: 407739  Pages inactive: 148277  Pages speculative: 16200  Pages throttled: 0  Pages wired down: 263064   Compressor Stats: Pages used by compressor: 122815  Pages decompressed: 7327420  Pages compressed: 17625795   File I/O: Pageins: 1538997  Pageouts: 86692   System-wide memory free percentage: 63% /code/pre  <answer253890> top  or  htop can also help to solve the problem .  <answer265882> If case you use fishshell on osx, along with fisher its package manager.  I wrote the following extension: https://github.com/fisherman/free  It's a complete redo of the free command for osx. See by yourself  precode&gt; free                  total     used     free   appmem    wired   compressed Mem:            8.00Gb   6.65Gb   1.95Gb   2.87Gb   2.09Gb   1.86Gb +/- Cache:               1.24Gb   1.87Gb Swap(43%):      2048Mb    877Mb   1171Mb Load Avg:        1.63 1.95 1.95 /code/pre  <answer271222> I think these days, codepsutil/code and its codememinfo.py/code script provide the most helpful memory-usage details. To try it:  precodepip install psutil curl -O https://raw.githubusercontent.com/giampaolo/psutil/master/scripts/meminfo.py python ./meminfo.py /code/pre  The output it produces looks like this:  precodeMEMORY ------ Total      :   16.0G Available  :    5.5G Percent    :    65.8 Used       :   13.5G Free       :    1.5G Active     :    7.4G Inactive   :    4.0G Wired      :    2.1G  SWAP ---- Total      :    1.0G Used       :   33.5M Free       :  990.5M Percent    :     3.3 Sin        :   15.9G Sout       :   71.6M /code/pre  Notice the codeAvailable/code row, which shows an estimate  of  stronghow  much  memory  is actually available for starting new applications/strong, without swapping.  I don’t know of any other MacOS utility providing that available-memory estimate.  For the sake of comparison: On a Linux system, the same sort of information is provided in the codeavailable/code column in output from current versions of codefree/code:  precode              total        used        free      shared  buff/cache   available Mem:           7.8G        552M        182M        156M        7.1G        6.9G Swap:            0B          0B          0B Total:         7.8G        552M        182M /code/pre  That codeavailable/code column in codefree/code output just comes from codeMemAvailable/code in code/proc/meminfo/code. And on systems that have code/proc/meminfo/code, psutil also just uses that to estimate available memory.  But MacOS doesn’t have code/proc/meminfo/code, so to estimate the available memory in that case,  psutil employs the same algorithm used on Linux to calculate codeMemAvailable/code for code/proc/meminfo/code.  <comment13246> what is the best way to use this script? <comment14654> not sure exactly what you mean... copy and paste it into a new file, save it somewhere (perhaps in /usr/local/bin), make it executable and run it? <comment35522> Strictly speaking, "top" on OS X is rather more similar to the Linux "top" command, of course :) <comment53365> I think @idober was suggesting you include an example of running it and the output produced (e.g. a screen capture) <comment54666> @AJ, ah ok, got it <comment57371> The current edition of that command does not work for me in `tcsh` (my default) or `sh`. Is the command shell-specific? <comment57372> A powerful tool, but it's processor-intensive (around 95% of one of two CPUs on my MacBookPro5,2) and if much memory is used: a simple run of `allmemory` may be unexpectedly long — for me today, over four minutes per run, YMMV. A run of `allmemory` for `sysdiagnose` may take considerably longer. <comment93362> Yes, it is `bash` and `ksh` specific. In `tcsh` try: `set freeblocks=\`vm_stat | grep free | awk '{ print $3 }' | sed 's/\.//'\` ; set freeMB=\`expr $freeblocks \* 4096 / 1048576\`; set free=\`echo $freeMB MiB free\``. You can then do `echo $free` to print the amount of free memory. You could also create an alias: `alias free echo $freeMB MiB free`. <comment104067> It's dog slow, it's much better to utilize `vm_stat`. <comment104802> better than top : `htop` <comment107052> Besides being more or less unusable by somebody without any knowledge of French, your script seems to require `gawk` which is not part of a standard OS X installation. <comment107064> @patrix : Thank you for your feedback  I will make a description in English and I will translate the integrated help too (currently in French).  gawk: actually, I forgot, thank you. I met some localization issues (decimal comma or decimal point) with awk. They disappeared without knowing why. I came back to awk instead of gawk.  I've needed a bit of time to adjust things, I will repost when it's ready.  Yours. <comment107066> Simply replacing gawk with awk worked for me without issues. <comment107082> Yes, querying `top` is significantly slower that calling `vm_stat` but the `top` extract is much less verbose and the unit is megabyte and not pages. To be even less verbose the line breaks can be removed and `awk` can be replaced by `grep` resulting in `top -l 1 | grep ^PhysMem`. <comment131631> What are 'pages'? <comment131894> @zhermes - The smallest unit of memory usable by the system... in the case of x86 and PPC Macs, this is 4k. Pages free are the number of 4k units of memory free. <comment138073> @nXqd htop: command not found <comment138074> You can increase/decrease the window size horizontally to see more/less columns. I can see these columns:  PID    COMMAND           %CPU  TIME      #TH   #WQ   #PORT #MREGS RPRVT   RSHRD   RSIZE   VPRVT   VSIZE   PGRP  PPID  STATE     UID   FAULTS   COW     MSGSENT    MSGRECV    SYSBSD    SYSMACH   CSW       PAGEINS KPRVT   KSHRD   USER <comment138078> @SazzadTusharKhan brew install htop if you do have brew installed <comment138746> How does `hostinfo` show *used* memory? <comment144557> Pages are also 4K in iOS. <comment230611> this command (at least here in OS 10.6.8)  shows only the physically available memory, but not how much of it is currently used <comment257067> Answers on Ask Different need to be more than just a link. It's okay to include a link, but please summarize or excerpt it in the answer. The idea is to make the answer stand alone. <comment269216> Which means this doesn't actually answer the question asked since it specifically states that it desires "free and used memory". <comment297400> i was looking for it thanx a lot :) <comment316056> Welcome to ask Different. Please provide more information about how the commands you reference answer the question. <comment316872> It boggles the mind that one has to write a script to get this basic info on a mac <comment317120> @meyerson, I think that's a bit overstated, you don't *have* to write a script to get this info, this script is merely collating an interesting set of information together in a human readable format vaguely similar to the linux-specific 'free' command. 'vm_stat' already gives you the basic info, as does 'top'. <comment318194> just my 2 cents: `ps -caxm -orss= | awk '{ sum += $1 } END { print "Resident Set Size: " sum/1024 " MiB" }'` <comment324649> Technically they aren't similar at all because free prints something nice and neat to command line while top is something you actively view. <comment333461> Nice. Immediately nicked it. <comment369211> what is wired memory ? <comment369397> @Ciastopiekarz https://apple.stackexchange.com/q/31801/1587
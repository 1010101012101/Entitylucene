How to correctly pipe output into "say" in terminal <body> I realized that the codesay/code command can be great when combined with another command/program because it can read you the output. I tried to pipe the output from codeleave/code to codesay/code by typing the following in terminal, but it didn't work.  precodeleave +5 | say /code/pre  What is the correct way to do this?  <answer9676> I think you simply canÂ´t use codeleave/code for that, rather use codesleep/code with the correct amount of seconds (put it into a short script to convert seconds to minutes, hours):  precodesleep 60 &amp;&amp; say -v Vicki 'Time to leave!' &amp; /code/pre  <answer9680> Your example is, in general, the correct way to pipe normal output to say:  precode cat file | say  echo "hello world" | say /code/pre  The specific issue is that the code|/code (pipe) character transfers codeSTDOUT/code from the command on the left to codeSTDIN/code to the command on the right. codesay/code then speaks whatever is on codeSTDIN/code.  However, codeleave/code does not print the output directly to codeSTDOUT/code. It is either using codeSTDERR/code, or some other message mechanism. You can pipe codeSTDERR/code through the code|/code, but the syntax is shell dependent. For codebash/code, you would do it like so, although I'm not sure that this will make codeleave/code work with codesay/code, as I don't much about codeleave/code.  precodecmd 2&gt;&amp;1 |cmd2 /code/pre  <answer9776> Based on mankoff's answer, this works:  precodeleave +1 2&gt;&amp;1 | while read line ; do echo $line | say ; done /code/pre  although leave no longer vanishes into the background and lets you carry on typing. Similarly:  precodeleave +1 2&gt;&amp;1 | while read line ; do echo $line | say ; done &amp; /code/pre  will make it vanish into the background, but will also speak a (harmless) process ID number as well. So neither is quite perfect, but both work.  (I was looking for a solution to:  precodeping google.com | say /code/pre  which suffers a similar problem, and someone suggested the above as a solution. I didn't add this as a comment to mankoff's answer because I can't work out how to put spaces and newlines in comments.).  <answer116287> As an addition to this - if you want to pipe an ongoing file to say, the "recipe" also works with tail:  precodetail -f ~/Documents/activity.log | while read line ; do echo $line | say ; done /code/pre  <comment10120> That is an interesting solution although The question was not how to make the computer say Time To leave; I want to know how to pipe output from one program to `say`. Thanks for the response though. <comment10124> Based off of very initial analysis, I don't think you'll be able to, because `leave` forks/daemonizes and leaves your shell. <comment10128> So you can't pipe output from daemons to another program? <comment10129> You can probably capture the output of daemons and pipe it to another program, but not as simply as `|` <comment10131> `STDERR` or some other message mechanism? Why would it do that. Another commenter seems to think the issue is that `leave` is a daemon. What is that last command you wrote? `cmd 2&1 |cmd2` <comment10132> The last command pipes STDOUT and STDERR through the pipe. Normally only STDOUT gets captured, and STDERR goes wherever the first command would send it. Why would `leave` do that (whatever "that" is)? Because the authors wrote it that way. <comment10134> I used that command to pipe `STDERR` from `leave` to `say` and it almost worked. Basically, all of the output was sent at one time rather than in increments. <comment10236> You can't put newlines in comments. Unfortunately. <comment10338> you could edit my answer, but I think your comments are worthy of their own 'answer'. To silence the process ID, perhaps something before `|say` like `|grep -v ^[0-9]*$`, etc. <comment10443> Thanks that worked. I'm guessing `read line` reads each line of an input and then you just echo the line so you can pipe it to `say`? <comment10485> Yes, and the `while ... do` form makes sure it does the _read line/say line_ pair over and over. (The problem is that when you pipe input into `say`, it waits until the entire end of the input before speaking all of it at once, however `read` takes one line and stops. So the code chops a continuous output into line-sized chunks and launches `say` once for each chunk).
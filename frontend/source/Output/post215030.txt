El Capitan, make check, DYLD_LIBRARY_PATH <body> I develop applications using the usual Unix tool set: a compiler, codemake/code, and shared libraries.  The procedure is then traditionally something like  ul licode./configure/code, which tailors the sources for the features of the machine it is run on,/li licodemake/code, which actually compiles the shared libs, executables, etc.,/li licodemake check/code, which runs the tests embefore/em we install the package,/li licodemake install/code, if the package behaves properly, and finally, optionally,/li licodemake installcheck/code, to make sure the installation works./li /ul  During codemake/code, the shared libs and executables are compiled in their final form: the executables are compiled with a dependency to the shared libs in their final destination (i.e., they depend on libraries in code/usr/local/lib/code although they are not there yet, they are still in the build tree).  Then codemake install/code is, roughly, just using codecp/code to install libs and executables from the build tree to the final place.  During the codemake check/code phase, we are running the program uninstalled: the shared libs, executables and auxiliary files are still in the build tree.  To run the tests you have to set up a few custom environment variables (for instance to tell your program that your auxiliary data files are not in code/usr/local/share/code but in the source tree), and some system environment variables, to tell your share lib loader to look for the shared libs.  The environment variables on traditional Unices is codeLD_LIBRARY_PATH/code, on OS X it is codeDYLD_LIBRARY_PATH/code.  This has worked for (dozens of) years.  But now, El Capitan broke this.  precode$ (export FOO=foo; env) | grep foo FOO=foo $ (export DYLDFOO=foo; env) | grep foo DYLDFOO=foo $ (export DYLD_FOO=foo; env) | grep foo $ /code/pre  now, when SIP is enabled, no codeDYLD_*/code is exported from a process to its children.  So my question is: How can we run programs that are not installed?  What is the procedure to follow to be able to run the traditional Unix sequence code./configure &amp;&amp; make &amp;&amp; make check/code?  emPlease/em, no answer such as "run codemake install/code first".  That's not the point.  I am a developper, and running "make check" (and more generally running a non-installed version of a program) is something I do very frequently.  Even installing to a dummy place is time consuming.  I need something effective, emand/em efficient.  And disabling SIP will not fix the issue for users of my packages that want to run codemake check/code.  <answer216815> It seems like DYLD_* only gets stripped out for “protected” binaries (I’m not sure exactly what that means, but apparently anything in /bin and /usr/bin for starters) However, if you copy /usr/bin/env to somewhere else, it gets to keep its DYLD_* stuff:  precode$ cp /usr/bin/env ~/Desktop; (DYLD_FOO=bar ~/Desktop/env)|grep DY dyld: warning, unknown environment variable: DYLD_FOO DYLD_FOO=bar /code/pre  I think make always runs commands via /bin/sh, so you can’t set “dangerous” variables in the makefile and have them affect the commands, but maybe you could move the test into a shell script, set the environment variables inside the script, and then invoke the script from make. Though obviously, this won’t help you if the tests, in turn, rely on shell scripts (or if the things tested emare/em shell scripts!) because then they’re going to invoke /bin/sh and lose the variables again...  <comment260965> I still can use `DYLD_INSERT_LIBRARIES=$HOME/.bin/lib/Apple80211 /Applications/Utilities/AirPort\ Utility\ 5.6.app/Contents/MacOS/AirPort\ Utility\ 5.6` to run the old APU (with the old library) under 10.11 (even though the variable doesn't show up in `env`). Strange (but it works). <comment262127> Thanks a lot!  Now I can `cp` `/bin/sh`, and use that shell instead of the real one.  Symlinks won't do, and hard links are "Operations not permitted", so I guess I have to live with `cp`.
Executables in /bin and /usr/bin are not found in path <body> Somehow I can’t execute files in code/bin/code or code/usr/bin/code without providing the full path.   This isn’t happening when running from Terminal, but, for example, iTerm can’t run codebash/code (only code/bin/bash/code), OnyX can't run codesw_vers/code.  precode.profile: export PATH=/opt/local/bin:/opt/local/sbin:/bin:/usr/bin:$PATH  .profile: export PATH=$PATH  .bash_history: export PATH="$PATH:"'/Users/gilstrauss/Applications/CrossOver.app/Contents/SharedSuppor‌​t/CrossOver/bin'  .bash_history: export PATH=/opt/local/bin:/opt/local/sbin:$PATH  .bash_history: export PATH=${PATH}:/bin  .bash_profile: export PATH=/bin:$PATH  .bashrc: export PATH=${PATH}:/bin:/usr/bin /code/pre  <answer51308> Not sure how it happened but your codePATH/code went haywire, luckily it's an easy fix. Run the following in Terminal (or iTerm) to fix the issue:  precodeecho "export PATH=$PATH:/bin:/usr/bin" &gt;&gt; ~/.bashrc source ~/.bashrc /code/pre  This will add code/bin/code and code/usr/bin/code to the end of your codePATH/code for this and all future terminal sessions.   <answer51310> do you have a code.bash_profile/code?  in mine  precode$ cat bash_profile   source ~/.bashrc export PATH=$PATH:/opt/local/bin:/opt/local/sbin  $ echo $PATH /usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/usr/local/git/bin:/usr/local/julia:/usr/local/MacGPG2/bin:/usr/texbin:/opt/local/bin:/opt/local/sbin /code/pre  (for macports to the path). It stands to reason that you could just have in .bash_profile the line  codeexport PATH=$PATH:/bin:/usr/bin/code  And see how it goes. My guess is that you must have done something very serious to your machine, so do make a backup of your files, and test for software and also hardware soundness.  <answer51311> emTerminal.app/em correctly starting the shell does’t mean much: it runs code/usr/bin/login/code (with the full path) by default, which invokes your default shell (again: defined with a full path) as an stronginteractive login shell/strong (which  will in turn read both code.profile/code and code.bashrc/code and leave you with a working code$PATH/code). Your problem is strongnon-interactive shells/strong, which do neither, do not get any code$PATH/code settings. That seems to point to OS X’ default path settings having somehow been clobbered.   To check this, run codecat /etc/paths/code. The output should (at the very least) be  precode/usr/bin /bin /usr/sbin /sbin /code/pre  (these are the defaults on a pristine OS X install). If the first two are missing, you have your cause – and an easy solution:   precodemv /etc/paths /etc/paths.old # if you want to keep the current contents def_paths=(/usr/bin /bin /usr/sbin /sbin) for p in ${def_paths[@]}; do echo $p &gt;&gt; /etc/paths; done cat /etc/paths.old &gt;&gt; /etc/paths # append previous contents /code/pre  Note that as code/etc/paths/code is owned by coderoot/code, you will have to codesudo su/code for this to work.  <answer91586> In OS X it's launchd that sets the initial path for everything, not your terminal files.  Now, on an unrelated note, I just found out that in OS X   precodeps -E  /code/pre  will show the environment that the process has been given. I'm sure everybody knew this except for me,but I'm very excited! Why?  Because now I can provide a partial answer.  precodeps -EA /code/pre  Will show you the environment that every process started whether said process has a controlling terminal or not. You should see   precode/usr/bin:/bin:/usr/sbin:/sbin /code/pre  Which is what you should also get when you type in  precode/bin/launchctl getenv PATH /code/pre  since launchd sets the path. It is here where your problem lies, I feel, not in your dotfiles. You might find reading the manpage for codeenviron(7)/code as well as codepath_helper(8)/code useful. When the system is working properly, every app you run should have the same environment given it by launchd. The fact that Onyx is malfunctioning means that it's not shell issue, but rather a system one.   It's very important launchctl/launchd is setting the path correctly.  <comment58647> What does this command return: `grep PATH= .profile .bash*` ? <comment58651> .profile:export PATH=/opt/local/bin:/opt/local/sbin:/bin:/usr/bin:$PATH .profile:export PATH=$PATH .bash_history:export PATH="$PATH:"'/Users/gilstrauss/Applications/CrossOver.app/Contents/SharedSupport/CrossOver/bin' .bash_history:export PATH=/opt/local/bin:/opt/local/sbin:$PATH .bash_history:export PATH=${PATH}:/bin .bash_profile:export PATH=/bin:$PATH .bashrc:export PATH=${PATH}:/bin:/usr/bin <comment58657> Thanks but it didn't seems to solve the problem. I don't see that problem in a terminal but only when 3rd party apps tries to invoke access executables under /bin or /usr/bin. <comment58659> Can you give me an example of the third party trying to access these binaries? <comment58660> Yes, iTerm2 fails to run bash but only /bin/bash. You don't see that behavior when running bash from terminal. <comment58665> Both of OP’s problematic paths are in his (her?) `.bashrc` already (see the `grep` listing in  [the comment above](http://apple.stackexchange.com/questions/51305/executables-in-bin-and-usr-bin-are-not-found-in-path#comment58651_51305)). <comment58678> @user49204 - show that info by editing the question - and when saved check that the formatting makes it understandable <comment212224> Thanks tons.  It is interesting to see that my Bash terminal process was launched with a plain 'PATH=/usr/bin:/bin' path.   My '/bin/launchctl getenv PATH' returns nothing on Yosemite. <comment222562> What that means is that your path is being set by login(1). "The sequence of directories, separated by colons, searched by                 csh(1), sh(1), system(3), execvp(3), etc, when looking for an                 executable file.  PATH is set to ``/usr/bin:/bin'' initially                 by login(1)."
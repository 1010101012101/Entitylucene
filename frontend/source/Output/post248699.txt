How to change group owner on a large directory containing locked files <body> The command to change the group owner on a whole directory is:  precodechgrp -R newgroup dir_name /code/pre  For example:  precodechgrp -R staff . /code/pre  But when codedir_name/code contains emlocked/em files or directories, this command will fail with:  precodechgrp -R staff . chgrp: ./file.txt: Operation not permitted /code/pre  If you run the command with super user privileges it will fail too:  precode/usr/bin/sudo chgrp -R staff . Password: chgrp: ./file.txt: Operation not permitted /code/pre  If the number of files locked is small, there is a manual workaround through the use of the command codechflags/code.  Check that there is a specific flag (codeuchg/code) associated with a given locked file:  precodels -@delO file.txt  -rw-r--r--  1 bob  staff  uchg 32 Aug  8 11:38 file.txt /code/pre  Remove temporarily the codeuchg/code flag:  precodechflags nouchg file.txt /code/pre  Change recursively the group:  precodechgrp -R admin . /code/pre  Reset the initial codeuchg/code flag:  precodechflags uchg file.txt /code/pre  But this method can't adapt to a huge directory structure with hundreds of locked files. This receipe doesn't scale at all.  hr  What is the basic simple method to change the group owner of a whole directory structure containing locked files, while preserving this locked status?  The same problem arises with many commands to manage directories containing locked files but I focused here on a practical and simple case.  <answer248803> The following is an example of how I would workaround the issue by creating a emwrapper script/em for the codechgrp/code emcommand/em to act upon a emtarget directory/em having issues with emlocked files/em.  Using a embash script/em, named codechgrpld/code, I'd pass it the same command line arguments (emoptions/em, emoperand/em and emdirectory/em) I would if executing codechgrp/code on a emdirectory/em. Note that my naming convention was simply to add the letters codeld/code to it representing emlocked directory/em, in that it works on emdirectories/em that are emlocked/em, or not, and or containing emfiles/directories/em that are emlocked/em too. So where I'd normally use, e.g., codechgrp -R staff foo/code, where codefoo/code is a emdirectory/em, I'd use codechgrpld -R staff foo/code instead. The emscript/em is also coded to work on a emdirectory/em that is emnot locked/em and or does not contain emlocked filesystem objects/em as well, thus allow the use of codechgrpld/code as a regular replacement for codechgrp/code when targeting a emdirectory/em, if I don't want to check for emlocked filesystem objects/em first or have codechgrp/code fail first to then have to use codechgrpld/code anyway.  Note: This emscript/em employes a limited amount of error checking, enough to work under limited testing conditions. It strongis not/strong coded to handle an embedded newline in the name of a filesystem object, which IMO doesn't belong there in the first place! Feel free to modify as needed/wanted to suite your needs, adding additional error checking if/when wanted/needed.  The testing environment was OS X 10.11.5 in a temporary emdirectory/em, as shown in the listing below, having two emdirectories/em, each with one emfile/em in it and one of the emfiles/em locked. One emdirectory/file set/em is in the codeadmin/code emgroup/em and the other emset/em is in the codestaff/code emgroup/em and I'm wanting everything to be in the codestaff/code emgroup/em. (See Testing Note at end of answer for additional testing information.)  The Terminal output shows:  ul liA recursive emdirectory/em listing./li liAn attempt to use codechgrp/code, showing its error output./li liUsing codechgrpld/code, executing without error./li liAnother recursive emdirectory/em listing, to show the emgroup/em has changed./li /ul  hr  pre class="lang-none prettyprint-override"code$ ls -lRO total 0 drwxr-xr-x  3 user  staff  - 102 Aug  9 2:00 bar drwxr-xr-x  3 user  admin  - 102 Aug  9 2:00 foo  ./bar: total 0 -rw-r--r--  1 user  staff  - 0 Aug  9 2:00 foo  ./foo: total 0 -rw-r--r--  1 user  admin  uchg 0 Aug  9 2:00 bar $ chgrp -R staff foo chgrp: foo/bar: Operation not permitted $ chgrpld -R staff foo $ ls -lRO total 0 drwxr-xr-x  3 user  staff  - 102 Aug  9 2:00 bar drwxr-xr-x  3 user  staff  - 102 Aug  9 2:00 foo  ./bar: total 0 -rw-r--r--  1 user  staff  - 0 Aug  9 2:00 foo  ./foo: total 0 -rw-r--r--  1 user  staff  uchg 0 Aug  9 2:00 bar $  /code/pre  hr  To create the codechgrpld/code embash script/em and have it available at the emcommand prompt/em:  In Terminal:  ul liType, codetouch chgrpld/code and press kbdenter/kbd./li liType, codeopen chgrpld/code and press kbdenter/kbd./li /ul  From the Browser:  ul liCopy and paste, the emcode/em below into the opened codechgrpld/code file and save it, then close the file./li /ul  Back in Terminal:  ul liType, codechmod +x chgrpld/code and press kbdenter/kbd./li liType, codesudo mkdir -p /usr/local/bin/code and press kbdenter/kbd. Note that on a clean install of OS X 10.11.5, the codebin/code directory at code/usr/local/code did not exist even though it's already in the codePATH/code.  ul liType in empassword/em and press kbdenter/kbd./li /ul/li liType codesudo cp chgrpld /usr/local/bin/code and press kbdenter/kbd.  ul liType in empassword/em and press kbdenter/kbd. (If necessary.)/li /ul/li licodechgrpld/code should now be available to use, just like the codechgrp/code emcommand/em./li /ul  hr  Source emcode/em for codechgrpld/code:  pre class="lang-none prettyprint-override"code#!/bin/bash  o="${@:1:$(($#-1))}" d="${@: -1}" if [ -d "$d" ]; then     f=".locked_files_list_$(date "+%s")"     find "$d" -flags uchg &gt; "$f" 2&gt;/dev/null     if [ -s "$f" ]; then         while read -r l; do             chflags nouchg "$l"         done&lt;"$f"             $(chgrp $o "$d")         while read -r l; do             chflags uchg "$l"         done&lt;"$f"         rm "$f"     else         rm "$f"         $(chgrp $o "$d")     fi else     echo "  \"$d\" is not a directory!..."     exit 1 fi exit 0 /code/pre  hr  strongSynopsis:/strong codechgrpld [−fhv][−R[−H | −L | −P]] group directory/code  ul liSee codeman chgrp/code in Terminal for description of emoptions/em and codegroup/code emoperand/em./li licodedirectory/code is the emname/pathname/em of the target emdirectory/em that is emlocked/em, or not, and or containing emfiles/directories/em that are emlocked/em too. Note that unlike codechgrp/code which allows multiple emobjects/em, e.g. codegroup file .../code to act upon, codechgrpld/code is coded to act upon one target emdirectory/em, and recursively with the code-R/code emoption/em, at a time./li liNote: The user invoking strongchgrpld/strong must belong to the specified emgroup/em and be the emowner/em of the emdirectory/em and emlocked filesystem objects/em, or be the emsuper-user/em./li liAs expected in SIP versions of the OS, this will not work upon SIP protected emfilesystem objects/em if SIP is enabled./li /ul  hr  The image below shows syntactical highlighting of the emcode/em with spaced and indented comments for easier reading to help explain a little about what the emcode/em is doing.  img src="https://i.stack.imgur.com/VPq96.png" alt="Image of Code"  hr  Testing Note: Note that even though the testing environment shown above is limited nonetheless I did test it under a more complexed hierarchal directory structure with many more locked nested directories and files, with names containing spaces, and or backslashes within the filename, without issue. Obviously for demonstration purposes, I'm only showing a bare minimum structure for proof of concept. Again, as noted above, "emIt strongis not/strong coded to handle an embedded newline in the name of a filesystem object, which IMO doesn't belong there in the first place!/em".  <answer249585> h12 shells solution/h1  Finally after many attempts I built a 2 short shell scripts solution.  One pretty basic one which will do the:  precodechflags, chgrp, chflags /code/pre  A more serious one which will do the directory structure traversal:  precodefind ... do the chgrp correctly /code/pre  h2Small shell: chflags, chgrp, chflags/h2  Here is the content of codechgrpld1.sh/code which typically will work called from find with exactly 2 arguments.  precode#!/bin/sh # shell script to chgrp a file or directory # when there exists a lock flags (uchg)  _cn=`basename $0`  USAGE="Usage: ${_cn} group file"  case $# in 2)         _group=$1         _file="$2"         ;; *)         echo "$USAGE" &gt;&amp;2         exit 2         ;; esac  chflags nouchg "${_file}" chgrp ${_group} "${_file}" chflags uchg "${_file}" /code/pre  h2Big shell: find ... do the chgrp correctly/h2  Here is the content of codechgrpld.sh/code which will run a find on the directory structures, and avoid as much as possible error conditions in advance.  precode#!/bin/sh # shell script to recursively chgrp a file or directory # when there exists files which are locked  _cn=`basename $0`  USAGE="Usage: ${_cn} group file..."  case $# in 0|1)         echo "$USAGE" &gt;&amp;2         exit 2         ;; *)         _group=$1         shift         _file_list="$@"         ;; esac  TMPDIR=/tmp _file_flags_list=`mktemp -t ${_cn}`  clean() { rm -f ${_file_flags_list} ; }  trap clean 0 1 2 3  # first check if we don't have any sort of flags thus blocking this # script  find "${_file_list}" -flags +sappnd,schg,uappend -exec ls -@delO "{}" \; &gt;${_file_flags_list}  if [ -s ${_file_flags_list} ] ; then         echo "${_cn}: can't run because of other flags set:"         cat ${_file_flags_list}         exit 1 fi  # if flag present then call chgrpld1, else plain chgrp  find "${_file_list}" \( -flags uchg -exec chgrpld1 ${_group} "{}" \; \) -or \( -exec chgrp ${_group} "{}" \; \) /code/pre  h2Install/h2  To make these 2 shells work together, it is necessary to install both of them in a local directory which is in the codePATH/code. In my case I use code/local/bin/code to stay outside of the system PATH components, and outside of the ones used by package managers (codeport/code, codebrew/code…).  Copy the 2 precedent files within the choosen directory:  precodechgrpld1.sh chgrpld.sh  make chgrpld1 chgrpld  cp chgrpld1 chgrpld /local/bin /code/pre  h2Test/h2  To validate this shell runs correctly in every case, I made a test directory populated with all the combination of flags one could encounter with all the impossible filenames it should cope with without an error.  codedir-ok/code is the subdirectory containing the horrors on which my script should succeed, codedir-fail/code is the one containing all the case on which it should fail:  precode% ls -blOR total 0 drwxr-xr-x  2 bob  admin          - 204 Aug 16 16:50 dir-fail drwxr-xr-x  3 bob  localaccounts  - 238 Aug 16 16:55 dir-ok  ./dir-fail: total 0 -rw-r--r--  1 bob  admin  schg,uchg 0 Aug  9 18:59 file-multi-flags -rw-r--r--  1 bob  admin  sappnd    0 Aug 16 16:13 file-sappnd -rw-r--r--  1 bob  admin  schg      0 Aug 16 16:11 file-schg -rw-r--r--  1 bob  admin  uappnd    0 Aug 16 16:12 file-uappend  ./dir-ok: total 0 -rw-r--r--  1 bob  localaccounts  -      0 Aug 16 16:07 a\nb -rw-r--r--  1 bob  localaccounts  -      0 Aug  9 19:34 a b -rw-r--r--  1 bob  localaccounts  -      0 Aug  9 19:34 a'b -rw-r--r--  1 bob  localaccounts  -      0 Aug 16 16:46 a\\b drwxr-xr-x  2 bob  localaccounts  uchg 272 Aug 16 16:39 subdir  ./dir-ok/subdir: total 0 -rw-r--r--  1 bob  localaccounts  -      0 Aug 16 16:08 file -rw-r--r--  1 bob  localaccounts  arch   0 Aug 16 16:12 file-arch -rw-r--r--@ 1 bob  localaccounts  hidden 0 Aug 16 16:10 file-hidden -rw-r--r--  1 bob  localaccounts  nodump 0 Aug 16 16:11 file-nodump -rw-r--r--  1 bob  localaccounts  opaque 0 Aug 16 16:10 file-opaque -rw-r--r--  1 bob  localaccounts  uchg   0 Aug 16 16:08 file-uchg /code/pre  ul liRun on codedir-ok/code  precode$ chgrpld staff dir-ok $ ls -blOR dir-ok total 0 -rw-r--r--  1 bob  staff  -      0 Aug 16 16:07 a\nb -rw-r--r--  1 bob  staff  -      0 Aug  9 19:34 a b -rw-r--r--  1 bob  staff  -      0 Aug  9 19:34 a'b -rw-r--r--  1 bob  staff  -      0 Aug 16 16:46 a\\b drwxr-xr-x  2 bob  staff  uchg 272 Aug 16 16:39 subdir  dir-ok/subdir: total 0 -rw-r--r--  1 bob  staff  -      0 Aug 16 16:08 file -rw-r--r--  1 bob  staff  arch   0 Aug 16 16:12 file-arch -rw-r--r--@ 1 bob  staff  hidden 0 Aug 16 16:10 file-hidden -rw-r--r--  1 bob  staff  nodump 0 Aug 16 16:11 file-nodump -rw-r--r--  1 bob  staff  opaque 0 Aug 16 16:10 file-opaque -rw-r--r--  1 bob  staff  uchg   0 Aug 16 16:08 file-uchg $ /code/pre/li liRun on codedir-fail/code  precode$ chgrpld staff dir-fail/file-multi-flags  chgrpld: can't run because of other flags set: -rw-r--r--  1 bob  admin  schg,uchg 0 Aug  9 18:59 dir-fail/file-multi-flags  $ chgrpld staff dir-fail/file-sappnd       chgrpld: can't run because of other flags set: -rw-r--r--  1 bob  admin  sappnd 0 Aug 16 16:13 dir-fail/file-sappnd  $ chgrpld staff dir-fail/file-schg   chgrpld: can't run because of other flags set: -rw-r--r--  1 bob  admin  schg 0 Aug 16 16:11 dir-fail/file-schg  $ chgrpld staff dir-fail/file-uappend chgrpld: can't run because of other flags set: -rw-r--r--  1 bob  admin  uappnd 0 Aug 16 16:12 dir-fail/file-uappend $ /code/pre/li /ul  <comment308425> Simple & clean code! Nice for the limitation warning about newlines ;). <comment308438> What if a "file"  has multiple flags such as `hidden,uchg`or `schg,uchg`? Nice commenting in your script. <comment308442> @fd0, Let me start by saying I've already said "_The following is an example of how I would workaround the issue_" which covers the scenario of the filesystem object being locked and "_Feel free to modify as needed/wanted to suite your needs_" which covers being locked and hidden at the same time. What I've presented is an example of a workaround wrapper script to be used as a template. Yes, adding a check for and handling `uchg,hidden` flags is easy to do, if you want to. Thanks for the complement on code commenting, I'd like to look back in 6 mo. and know what and why I wrote it that way. :) <comment308548> @fd0, Out of idle curiosity I wrote a program that ran as root and analyzed the Flags on a recent and pretty clean, few user programs added, install of OS X 10.11.5 and there was only 1 file with just the `uchg` flag set and 0 with `uchg,hidden` set. However, here's the file totals for each individual and combined Flag(s) that were set: 35270 compressed; 80 hidden; 242946 restricted; 268419 restricted,compressed; 20 restricted,hidden; 3 restricted,sunlnk; 1 restricted,uchg; 467 sunlnk; 6 sunlnk,hidden; 1 uchg. I know `hidden` can stop `chgrp` from executing properly, haven't tested the others. <comment308649> Well, it seems odd that `hidden` or for that matter `compressed, opaque, nodump, archive` would effect modifying a file. <comment308655> @fd0, I just checked again and the file was set `uchg,hidden`, and at the time I though it was just `hidden` so when removing just `uchg` it worked as expected. Sorry for any confusion.
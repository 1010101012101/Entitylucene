Escaping variable in script <body> I'm using script.sh in an OS X Mavericks terminal containing only the following:  precodeecho ${1} ls ${1} /code/pre  Now, when I call code./script.sh "/Users/me/some\ directoy\ with\ whitespace/"/code, the echo command prints code/Users/me/some\ directoy\ with\ whitespace//code, but codels/code still insists on splitting everything up, so the results there are  precodels: /Users/me/some\: No such file or directory ls: directoy\: No such file or directory ls: with\: No such file or directory ls: whitespace/: No such file or directory /code/pre  Notice the code\/code at the end of the first three error lines. How do I do this correctly?  (I'm aware that using both "" and \ in the input argument leaves the \ in my variable, but I assume I would need those.)  I also tried using code./script.sh /Users/me/some\ directoy\ with\ whitespace//code without the quotes, then making the script  precodeecho ${1} ls "${1}" /code/pre  but that made the codeecho/code output not contain any code\/code now, and the codels/code output looks like this:  precodels: "/Users/me/some\: No such file or directory ls: directoy\: No such file or directory ls: with\: No such file or directory ls: whitespace/": No such file or directory /code/pre  Notice that all it did was add the quotes without seeming to understand them as syntax.  hr  It is somehow related to the IFS (input field separator) since if I make the script  precodeIFS=* ls ${1} /code/pre  and run it as code./script.sh /Users/me/some\ directoy\ with\ whitespace//code, it correctly shows me the content of the specified directory. I'm not sure why, though.  <answer157613> You don't need the braces. This should work just fine:  precodeecho $1 ls "$1" /code/pre  You don't want to use backslashes and quotes in the directory name. One or the other should be fine.  <answer162110> The correct script is  precode#!/bin/bash echo "${1}" ls "${1}" /code/pre  (You can start with code#!/bin/sh/code instead if you prefer.)  The syntax of bash and other shells is a bit weird. You might think that code$var/code means “the value of codevar/code”, but it doesn't. It means “take the value of codevar/code, split it at each whitespace sequence (or more generally, split it according tot he value of codeIFS/code), and interpret each part as a glob pattern which, if it matches any file, is replaced by the list of matches”. Yes, that's quite a mouthful — which is why you should always write code"$foo"/code instead. Always put double quotes around variable substitutions unless you know why you need to leave them out. Inside double quotes, the meaning of code"$foo"/code is “the value of the variable codefoo/code”.  See Why does my shell script choke on whitespace or other special characters? for further discussion of this topic.  To invoke your script, you can use any form of quoting — but only one:  precode./script.sh /Users/me/some\ directoy\ with\ whitespace/ ./script.sh "/Users/me/some directoy with whitespace/" ./script.sh '/Users/me/some directoy with whitespace/' /code/pre  If code./script.sh /Users/me/some\ directoy\ with\ whitespace//code doesn't work with the quotes in the script, then you aren't typing that in a bash shell. I can't guess what else you might be typing it in. Or else you didn't test with the version of the script you thought you had.  <comment185325> Tried it that way, didn't work either. I suspect something is wonky with my bash, because it works on Ubuntu. <comment185326> I just tested in Yosemite and it's fine. <comment185331> The above script also works for me. @G.Bach Did you notice mike's comment about not using slashes and quotes at the same time when you call it. Do this command: `./script.sh "/Users/me/some directory with whitespace/"` -- with quotes and no backslashes and in your script use `"$1"` not `"$(1)"` <comment185336> I tried that as well, it doesn't work in my OS X, but does in Ubuntu - very strange. Thank you both for trying it out! <comment189582> I don't quite remember how I fixed my problem, but I think I tried the script you suggested - without success. I must be on a very strange bash configuration with that OSX since everything works as intended in other OSes. Thanks for the link!
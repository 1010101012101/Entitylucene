`dd` never terminates on OS X <body> Working on both Linux and OS X (10.10.5), I'm using the command line tool dd to copy the contents of a USB flash drive to and from a compressed archive. To create the archive, I use the following on an unmounted drive (on Linux the format is something like code/dev/sdb/code; on OS X it's something like code/dev/disk2/code):  precodesudo dd if=/dev/disk1 bs=1m | gzip -c &gt; disk.image.gz /code/pre  which copies the entire drive's contents, compresses it, and then writes it to codedisk.image.gz/code. To unpack the image into a new drive, I use:  precodecat disk.image.gz | gunzip -c | sudo dd of=/dev/disk1 bs=1m /code/pre  which takes the compressed disk image, uncompresses it, and then writes it to the drive. (You can check the progress of either command by executing the following in a separate window on Linux:  precodesudo killall -USR1 dd /code/pre  or on OS X:  precodesudo killall -INFO dd /code/pre  which in both cases signals codedd/code to output a couple of lines on the amount of data transferred.)  Both processes work well on Linux. However, although the reading and compression work well on OS X, the decompression and writing never terminates. codedd/code keeps writing data and more data, even though the (decompressed) source file has ended, and the disk drive should be full. If I wait until more data has written than should fit on the flash drive, and then code^C/code to terminate the command, the resulting drive seems to mount and operate just fine. But, it worries me that the behavior isn't what I expect.  Any idea why codedd/code's writing never terminates, even though it is no longer receiving data?  (BTW: if you're using this as instructions to burn your own disk drives, strongMAKE SURE/strong you have the right device identifiers (e.g. the code/dev/sdb/code or code/dev/disk2/code mentioned above). codedd/code does exactly what you tell it to do, so if you get the wrong identifier and tell it to overwrite your boot drive, it'll happily do so. Look elsewhere on how to determine the right device.)  <answer278722> This might not really answer the question, but might provide a solution.  Instead of using codedd/code which seems to behave oddly for you, just use codecat/code or codecp/code. At least on OS X, they work very well on block devices. So:  precodesudo dd if=/dev/disk1 bs=1m | gzip -c &gt; disk.image.gz /code/pre  becomes  precodesudo cat /dev/disk1 | gzip -c &gt; disk.image.gz /code/pre  hr If you want the reverse, just redirect codegunzip/code's output:  precodecat disk.image.gz | gunzip -c | sudo dd of=/dev/disk1 bs=1m /code/pre  becomes  precodegunzip -c disk.image.gz | sudo tee /dev/disk1 &gt; /dev/null /code/pre  hr  If you just want to copy a block device  precodesudo dd if=/dev/disk1 of=disk.image bs=1m /code/pre  becomes  precodesudo cp /dev/disk1 disk.image /code/pre  hr  If you just want to copy an image to a block device (e.g. Raspbian to SD card)  precodesudo dd if=disk.image of=/dev/disk1 bs=1m /code/pre  becomes  precodesudo cp disk.image /dev/disk1 /code/pre  This also prevents any hassle with block sizes.  <comment350779> Are you sure you have your drive identifiers correct?  On OS X, they are `/dev/disk1`, `/dev/disk2`, etc. <comment350784> Yes; my examples used the Linux identifiers, but on OS X I used `/dev/disk2` (checking thrice so I didn't trash my boot drive). I'll clarify in the question. <comment350790> @DanielGriscom You might want to use `cp` instead of `dd` if you do not have special needs and just want to copy the contents of a block device. <comment350791> @DanielGriscom Or `cat` if you want to pipe it somewhere. <comment350794> @DanielGriscom Besides: You should use rdisk devices for those actions: https://superuser.com/questions/631592/why-is-dev-rdisk-about-20-times-faster-than-dev-disk-in-mac-os-x <comment350797> @MaxRied Interesting. If I make a disk image by reading from `/dev/diskX`, can I then write it to a drive through `/dev/rdiskX`? (Is the difference only in the data handling, not the data itself?) <comment350799> @DanielGriscom exactly <comment350875> I just tried the above `gunzip -c disk.image.gz | sudo tee /dev/disk1  /dev/null` twice. It failed once (continuing far longer than expected; I couldn't measure the data transferred because I wasn't using `dd`), and succeeded once. Looks like something else is going on. <comment350910> @DanielGriscom There is an open source project named `progress`, previously named `cv` that displays the progress of a lot of utilities. You might want to try this. <comment350924> Looks interesting: thanks.
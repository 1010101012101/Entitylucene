Copying ISO file to USB drive in OS X? <body> I have tried to copy an ISO file to a USB drive. I am unable to do it with Disk Utility. How can I copy the ISO file to a USB drive?  img src="https://i.stack.imgur.com/2mvtz.png" alt="enter image description here"  But I get the below. I have enough space in the 16GB USB drive for the 2GB ISO file. What am I doing wrong?  img src="https://i.stack.imgur.com/1mPcY.png" alt="enter image description here"  strongDebugging/strong     Bmike commented em"You can isolate the scanning of the image from the restoring to see if the problem lies with the image or the copy. Images - Scan Image for Restore... from the menu of Disk Utility."/em but the procedure fires the error below. What does it mean?           img src="https://i.stack.imgur.com/M4EVN.png" alt="enter image description here"      <answer73234> This thread here outlines a graphical way of turning a USB drive into a boot disk. The user jbdjunk mentions the proceduce below, copy-pasted from the earlier site.     ol   liOpen Disk Utility/li   liPlug in USB/li   liFormat USB to Mac Extended (Journaled)/li   liCreate Partition on USB [GUID for Intel chips, APM for PPC]/li   liUnmount created Partition/li   liDrag and Drop disk image (dmg or iso) into Disk Utility/li   liOpen disk image (double click or button in DU)/li   liSelect opened disk image on left menu/li   liClick over to Restore/li   liDrag and drop selected image into source field/li   liDrag and drop (unmounted) USB partition into destination/li   liOK (may have to type in admin passwords and such)/li   liWait/li   liEnjoy!/li   /ol   <answer73239> You can find the Debian-style-/dev/sdb location after code$ sudo port install watch/code and then getting the address from the kernel ring buffer with code$ sudo watch --interval=1 'dmesg|tail'/code so  img src="https://i.stack.imgur.com/fjmgd.png" alt="enter image description here"  now you know the address to be something like code/Volumes/disk1s1/code and for the mount-point like code/Volumes/Untitled 1/code but Apple requires some syntactic sugar in code$ sudo umount /Volumes/UNTITLED\ 1/ umount(/Volumes/UNTITLED 1): Resource busy -- try 'diskutil unmount'/code but it won't stop us! So everything as one-liners below, enjoy!  precode$ sudo watch --interval=1 'dmesg|tail' $ sudo diskutil umount /Volumes/UNTITLED\ 1/ Volume UNTITLED on disk1s1 unmounted $ sudo dd if=en_windows_8_x86_dvd_915417.iso of=/dev/disk1s1 bs=1m  /code/pre  This so far is very close to working with distros such as Ubuntu here. Now we make only a small difference to this procedure to get it working with Apple computers, namely converting the ISO into special format usually labelled with DMG or just IMG.  strongApple way/strong     The only difference to Apple is that you need to make the ISO file into special DMG file and upload that. An answer provided a video that solved the issue but this screenshot should contain all essential.      img src="https://i.stack.imgur.com/hV42I.png" alt="enter image description here"   <answer73465> From http://www.youtube.com/watch?v=fu2g_E2ZK8A:  img src="https://i.stack.imgur.com/oax7c.jpg" alt="Screen shot from video"  You can also can try this. It works for me.  This is a rather "raw" copy and will typically not work for a bootable USB, but will work for other cases.  Here is a transcription of the commands from the screen shot for your copy/paste pleasure.  precodediskutil list                                            # shows disks hdiutil convert -format UDRW -o destino.img origen.iso   # convert to dmg sudo dd if=destino.img.dmg of=/dev/rdisk1 bs=1m          # copy to USB on rdisk1 /code/pre  <answer83960> Quoting from the ubuntu article linked earlier:     I think the key is to use the drive (/dev/sdb), not the partition (/dev/sdb1), in the of= option:      strongsudo dd if=dban.iso of=/dev/sdb bs=1m/strong   <answer100458> IMHO the easiest way is in terminal:  ul liFirst run codediskutil list/code/li lithen insert your usb stick/li liand run codediskutil list/code again to see the disk node (e.g. /dev/disk2)./li liNow run codediskutil unmountDisk /dev/diskN/code/li liand do codesudo dd if=/path-to.iso of=/dev/rdiskN bs=1m/code (or codebs=1M/code with homebrew)/li liWhen finished codediskutil eject /dev/diskN/code/li /ul  <answer234290> If you want your USB  to be "bootable" when all is said and done (ex: windows install disk), you're going to either want to use the codeBoot Camp Assistant/code (only check the "Create a Windows 7 or later version install disk" checkbox, then follow the prompts, it will create a FAT32 (i.e. bootable) USB version of your ISO file).    Some ISO's are created "special" to not need this, but not all are (ex: windows install disks). Details: https://superuser.com/q/1063220/39364   I.e. codedd/code is not always enough.  <answer243924> You can use an open source tool named UNetbootin.br Also you can see an step-by-step tutorial with images by Ubuntu in here.br img src="https://i.stack.imgur.com/iNWPp.jpg" alt="enter image description here"  <answer268157> I can confirm that an 'official' Win10 (and also Win 7.1) iso obtained from University contract distributor winds up with a UDF formatted USB stick when copied with dd.  Rogerdpack's answer explains why.   Note that some versions of Boot Camp Assistant do not offer a "Win 7 or later" option; Version 3 (.2) and later do.  Also, if you have copied your iso fruitlessly to the USB drive (now in UDF format) Boot Camp Assistant may (will) complain about your 8 GB flash being too small. Reformat this drive before using it in Boot Camp Assistant.  <answer294530> If you want to make a bootable USB then I would suggest Unetbootin  <comment84995> You can isolate the scanning of the image from the restoring to see if the problem lies with the image or the copy. **Images - Scan Image for Restore...** from the menu of Disk Utility. <comment85072> ...so here I did not even try to solve the original GUI problem (there may be so many reasons for malfunctioning!), I chose the Unix -way of doing it. The error probably had something to do with some GUI thing that I cannot yet understand -- could someone help with the original err? Why did it not work like the above? <comment85077> ...it is getting too long time to burn the ISO: A) it may be that I have poor USB stick (slow writing time) but it may be that there is clearly something broken in the system -- if this method and the GUI method do not work, it is probably not a good sign or? <comment85082> The command can be improved, try using the raw block device and setting a decent block size: `sudo dd if=en_windows_8_x86_dvd_915417.iso of=/dev/rdisk1s1 bs=1m` <comment85083> You can also convert the image file from an ISO into an apple image DMG format, then do it from the GUI.  It still needs a trip to the terminal to do the convert tho, as I don't think you can do this in diskutil : `StuffeMac:~ stuffe$ hdiutil convert -format UDRW -o ./runtimelivecd.img ./runtimelivecd.iso` <comment85084> @stuffe is it somehow easier to send packages in 1 Megabytes' blocks? Could you outline this process in answer? It had sent 1.4GB files of 2GB in 2.4k seconds when I intercepted it so the original command works but it is just a large file. Or? <comment85086> @stuffe WoW! `"2632460288 bytes transferred in 746.013254 secs"` -- it was much faster to transfer things with `"bs=1m"`, why? <comment85087> The default block size is 512bytes, this results in many thousands more read/write operations than is required.  Using larger values means it can get it's teeth stuck into it more, for want of a better analogy, you can go way higher if the device merits it (a large hard disk for example) but 1Mb is generally OK for a USB stick which isn't all that fast. Read this for some background http://forums.freebsd.org/showthread.php?t=11585 <comment85089> Also, you are using the raw device now, which hits the drive direct and ignores any buffers and caches etc which can slow things down for a massively long write operation where it's not required to use them.  I doubt that this would make much difference on a USB stick, but on a hard drive with loads of fancy caching it will also boost things a lot - always a good thing to use though if you are doing an entire partition. <comment85382> ...gracias +1 and bs=1M to speed up the transfer for larger files NB comments. <comment85412> Whilst your answer may theoretically answer the question, [it would be preferable](http://meta.stackexchange.com/q/8259) to include the essential parts of the article in an answer below, and provide the link for reference <comment86402> @Pfitz point 2:28 should have all essential info, created a screenshot of the point to my answer but perhaps useful to add here also. <comment96619> `ls: /dev/sdb: No such file or directory`, hmm. <comment152846> Using of=/dev/rdiskN (with an "r" for "raw") instead of of=/dev/diskN is much faster. I edited the answer. <comment152850> In my case, with `diskN`, the process took about 5 minutes for 1GB. With `rdiskN`, it took about 30 seconds. <comment152859> The reason it won't work this way is because OS X does not natively read the file format of that particular iso, which is likely ntfs. The reason [dd](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dd.1.html) works is because it is a low-level block copy utility, thus the file system is irrelevant. <comment164154> I've been trying to use `dd` to copy a Windows 7 install DVD to a partition on a USB disk, but it always results in an unmountable partition, any ideas why this would be? The data appears to copy without any issues, and the source image is a .dmg, and the partition is already FAT32 (not sure if that part matters?) but the finished partition just won't mount anything. <comment220309> I ran this with a windows xp iso image and tried to boot with it -- no luck. <comment257954> That's the way to go now that they completely changed `Disk Utility` in OSX El Capitan. <comment269481> The above method worked under OSX El Capitan with a .dmg image. <comment277332> While `dd` is running, press Ctrl-T to see its progress. If your `bs=1m` then `182+0 records out` means 182 MB have been transferred. <comment286426> @Haravikk double check to make sure the end result is FAT32, apparently that part is required for it to be "bootable" http://superuser.com/q/1063220/39364 <comment286427> A little more detail please, perhaps? <comment286428> This method does mostly work, it creates a (typically, depending on what you ISO was) a UDF formatted USB drive. These are readable in OS X, and probably Linux (but not windows). But (and note well), do not do this for a USB you want to "boot" from (ex: windows install disk) because those have to be reformatted to FAT32:http://superuser.com/q/1063220/39364 <comment291123> This method didn't work for me either to boot Windows 10's install. I had to use @rogerdpack's solution. <comment304957> This actually worked! So difficult on OSX! <comment323590> I get an error: **dd: /dev/rdiskN: Operation not permitted** <comment323591> Why **Mac Extended (Journaled)** vs **MS-DOS FAT**? <comment323610> @IgorGanapolsky you need to specify the disk you found in step 2, eg. rdisk2 <comment324181> Note that UNetbootin does not support UEFI mode disks, so if you just want to install on one partition of an already-formatted GPT disk (like if you have Windows 8 or you want to dual-boot with a Mac's internal HD) then this won't work. <comment356078> I suspect that questioneer's answer shows a familiarity with other UNIX operating systems, ( FreeBSD, Linux, Solaris, etc. ) where a device file like /dev/sdb usually references the second SCSI drive in the system.  The OS X equivalent would be /dev/disk1 or /dev/rdisk1. <comment370032> In my experience UNetbootin creates broken installers. Tested with CentOS, Debian and Ubuntu on a USB flash drive. All installers boot fine, but then experience problems launching the install process. <comment371650> This is awesome <comment371711> On Mac OS Sierra I got "dd: invalid number: '1m'".  Apparently you have to use 1M now (capital M). <comment371776> @AmigoNico you are probably using homebrew `/bin/dd` uses 1m on sierra.
2010 2.66 GHz 12 core Mac Pro not utilizing all 24 threads? <body> I just recently purchased a 2010 Mac Pro.  img src="https://i.stack.imgur.com/AQ3cF.png" alt="Here are the specs"   I am wondering why all 24 threads never go past 50% usage when doing CPU intensive tasks. My coworker has a 2009 2.93 GHz 8 core Mac Pro and we both tried converting a dvd with Handbrake, and in activity monitor on the 2009 Mac Pro all 8 cores/16 threads were close to 100% usage but on the 2010 Mac Pro all 12 cores/24 threads never went passed 55% usage. We are running Mountain Lion on both Mac Pro's  <answer92667> It could be as simple as the application you used to test had a resource constraint other than CPU that prevented it from saturating the CPUs. For example, perhaps handbrake was limited in how quickly it could stream data to or from disk. That would limit how much work the CPUs could be given to do. Given that your CPUs will be faster and more plentiful than the older Mac, it isn't a surprised to not saturate the CPUs with the same workload.  I/O contention is used as an example. Without analysis, I don't know what would prevent the CPUs from being the bottleneck. It could be synchronization between that many threads, I/O, a lack of work that can be done in parallel, etc.  Here is a quick test you can use to give the system independent tasks. Open terminal and run the following command. Change the 8 to double the number of CPU cores you have. (double to allow for hyper threading)  precodefor ((g=1;g&lt;=8;g++)); do ( dd if=/dev/zero bs=100m count=10 | bzip2 -c &gt; /dev/null &amp; ); done /code/pre  Running that was enough to keep my CPU busy for 10-15 seconds. I have a quad core i7 macbook pro. Your CPUs may need more work, so you can change "count=10" to some larger number as well.  <comment108721> I ran the test and all my threads went to 100%. So what does that mean to me. <comment108727> It just demonstrates a contrived workload that can saturate your CPUs. That in itself isn't interesting, but I provided it just to contrast with your handbrake workload that did not saturate them. The net of this is that handbrake has a parallel scale limit that you have encountered. <comment108734> I understand. Thanks.
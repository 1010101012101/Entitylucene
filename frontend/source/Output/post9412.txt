How to get a notification when my commands are done <body> I'm running a series of commands on the command line that takes approximately twenty minutes to complete.  I'd like to see some sort of notification on my Mac when these are finished so I don't need to monitor the terminal for when it finishes.  Is there a way to do this?  precode$ svn update . &amp;&amp; ant clean build start &amp;&amp; *notify_me_somehow* /code/pre  strongEdit/strong:  I could use codexclock/code but this seems like a hack.  Ideally I could send the notification anywhere, like my phone, screen, etc.  <answer9413> Use strongGrowl/strong.  In the code.dmg/code file, look for the extras, there's a growlnotify binary. Install it, something like in code/usr/local/bin/code. Then you can use this command  precodegrowlnotify --sticky --appIcon &lt;icon&gt; --message &lt;message&gt; -t &lt;title&gt; /code/pre  to show a popup, like that:  img src="https://i.stack.imgur.com/hU6hi.png" alt="growl"  <answer9420> You could also use the build in say command for notification, e.g.: say "ant: build: done." See: man say in the terminal.  <answer9422> code(svn update . &amp;&amp; ant clean build start &amp;&amp; say done) || say error/code  <answer22354> As of Mac OS X Lion 10.7, Terminal has some new status indicators to help with issues like this:  In tabs:  ul liActivity: an activity indicator (spinning progress indicator) is displayed when there's been recent output to the terminal. This enables you to see whether it is currently busy or has completed a long process. (Or, of course, you can use it to tell when it has begun producing output after silently performing work for a while.)/li liUnread: an ellipsis "…" is displayed to indicate new, unread text in background tabs. When you select the tab, the indicator is cleared./li liAlert: a "bell" is displayed to indicate when a BEL has been written to background tabs or background windows. In addition, Terminal displays a red badge on the application icon, indicating the number of "unread" alerts/bells in all terminals. If Terminal itself is in the background, it also bounces its Dock icon when a bell is played./li /ul  In minimized window Dock icons:  ul liActivity: activity is indicated by displaying the name of the foreground process./li liUnread: unread text is indicated with an ellipsis./li liMinimized terminal windows show live content in their Dock icons. This can be used to see whether there's activity, or even to determine what the terminal is doing, if the output you're looking for is identifiable (e.g., a "top" display is fairly easy to recognize even at small sizes). This is especially useful when Dock magnification is turned on or you have room for a large Dock./li /ul  In addition, you could display something in the terminal to catch your attention (which would be visible even in minimized windows). For example:  ul liDisplay a large asterisk: codebanner \*/code/li liInvert the display: codeprintf '\e[?5h'/code/li liPaint the display red: codetput setab 1; tput clear/code/li liSit in a loop, flashing the screen: codewhile true; do printf '\e[?5h'; sleep 1; printf '\e[?5l'; sleep 1; done/code/li /ul  There are also escape codes for manipulating windows (move, set size, zoom, minimize, etc.). You could zoom the Terminal window, for example:  precodeprintf '\e[9;1t' /code/pre  See "window manipulation" at http://invisible-island.net/xterm/ctlseqs/ctlseqs.html for details.  Another approach is to use AppleScript to display an alert in a separate window:  precodeosascript -e 'tell app "System Events" to display alert "Build Completed" message "The checkout and build have completed."' /code/pre  <answer22476> I present in this answer two things:  ul liThe option of using strongcodeafplay/code, which plays sound files/strong, for notification./li limy tools for strongreporting exit status/strong along with the notification./li /ul  hr  I have this script, code~/bin/donebeep/code:  precode#!/bin/bash if [ "$@" = 0 ]; then   afplay -v 2 /System/Library/Sounds/Blow.aiff &amp; else   afplay -v 2 /System/Library/Sounds/Sosumi.aiff &amp; fi /code/pre  This plays a different sound depending on whether the argument is 0. Then I have an alias:  precodealias donebeep='(savestatus=$?; ~/bin/donebeep $savestatus "$@"; exit $savestatus)' /code/pre  (That they have the same name is irrelevant and probably a bad idea.)  To use it in your example, codesvn update . &amp;&amp; ant clean build start; donebeep/code. Note that I am using code;/code rather than code&amp;&amp;/code, so that it can notify me on failure as well as success.  Before I learned about codeafplay/code, I used codesay/code to speak messages instead. The role of codedonebeep/code was played by this script:  precode#!/bin/bash say -v Bruce "Done $(basename "$(pwd)"), $@." &amp; /code/pre  This script speaks the exit code directly instead of having two different messages. It also mentions the name of the current directory (to help clarify which task is done), and can be given additional text to say by passing parameters to the alias (that's why the alias has code"$@"/code in it). Note the trailing code&amp;/code so that you do not need to wait for the speech to finish before getting a prompt.  hr  The man page for codeafplay/code is incomplete; codeafplay -h/code lists all options:  precodeUsage: afplay [option...] audio_file  Options: (may appear before or after arguments)   {-v | --volume} VOLUME     set the volume for playback of the file   {-h | --help}     print help   { --leaks}     run leaks analysis  {-t | --time} TIME     play for TIME seconds   {-r | --rate} RATE     play at playback rate   {-q | --rQuality} QUALITY     set the quality used for rate-scaled playback (default is 0 - low quality, 1 - high quality)   {-d | --debug}     debug print output /code/pre  <answer40695> Ubuntu ships the following alias in ~/.bashrc:  precodealias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"' /code/pre  With this, you can then do things like:  precodemake; alert sleep 10; alert /code/pre  Perhaps there's an equivalent to codenotify-send/code in Mac OSX?  I've seen similar popup Windows in both Mac and Ubuntu.  <answer56602> I know I'm late to the question but I think there's a little missing piece that may be helpful. I've found that, while it's neat, having your terminal talk with you isn't exactly functional. What's better is something more subtile like this:   img src="https://i.stack.imgur.com/FaZmF.png" alt="http://i.stack.imgur.com/FaZmF.png"  As Chris pointed out, Lion has added little notification badges when a BEL is thrown. You can throw it yourself this with the command:   precodetput bel /code/pre  So, if you're doing some work in the background and want a notification when it finishes you can try something like:   precodeping -c 5 www.google.com &amp;&amp; tput bel &amp; /code/pre  This runs the ping command as a background task (the hanging &amp; accomplishes this) and has it throw a simple alert when it finishes. Historically BEL has been used to make that [horrible] hardware beep, however Lion has tastefully replaced that with the "invalid command" sound effect, a notification badge, and the terminal icon bouncing twice in the dock.   <answer85969> In Mac OS 10.8 you can send yourself Notification Center messages (similar to Growl but built in to Mac OS). Check out this page to see how to install a Ruby gem which will allow you to send notifications from the commandline. To simplify the common usecase of just caring about the fact of something in the terminal being done, add an alias to your .bash_profile, e.g.  precodealias notifyDone='terminal-notifier -title "Terminal" -message "Done with task!"' /code/pre  Then you can simply do  precode$ &lt;long-running task&gt; ; notifyDone /code/pre  Once the long-running task finishes you'll get a nice modal popup that persists until you click on it:  img src="https://i.stack.imgur.com/0QOoX.png" alt="Notification Center popup"  <answer86471> My problem with sounds and modal windows is that I cannot tell where they come from.  I currently work with a bunch of spaces, and sometimes upwards of 20 terminal windows.  My solution is portable to the unix side, and should work with anything that supports ansi escape sequences. This solution works with Snow Leopard, and will probably work with more ancient versions of terminal.  Single line in .bash_profile  precodefunction watch { $* ; echo -n -e "\033[41m" ;  echo $* DONE ;  date ;  echo -n -e "\033[0m" ; } /code/pre  Breaking that down:  precode$* expands to the original command I want to watch. first escape sequence changes background color to red echo repeats the command (with red background, the word DONE. Running Date tells you when it finished. last escape resets the terminal to what it was. /code/pre  If you don't like red, google ascii escape codes background color.  Note that this does not change the whole screen red, but just anything output after the command has finished.  <answer133297> I create a simple tool that does exactly this. https://github.com/vikfroberg/brb  strongInstallation/strong  Node.js needs to be installed: http://nodejs.org  precode$ npm install -g brb /code/pre  strongInstructions/strong  precode$ sleep 3; brb /code/pre  <answer238869> I wrote codentfy/code for exactly this purpose. It is strongcross-platform/strong and can strongautomatically/strong send notifications when long running commands finish.  If you have Python's codepip/code (most Linux distros and MacOS have it), here's how to install it and enable automatic notifications:  precode$ sudo pip install ntfy $ echo 'eval "$(ntfy shell-integration)"' &gt;&gt; ~/.bashrc $ # restart your shell /code/pre  Check it out at http://ntfy.rtfd.io  In addition to that, it also can:  ul lisupress automatic notifications when the terminal is in the foreground (X11, iTerm2 &amp; Terminal.app supported and enabled by default)/li lisend cloud-based notifications (Pushover, Pushbullet, and XMPP) /li libe used to send notifications when a process ends (not the aforementioned automatic support)/li limanually send notifications (good for use in scripts!)/li /ul  <answer257367> I made a script to solve this which is here. You don't need any extra software for this. Installation:br codebrew install akashaggarwal7/tools/tsay/codebr Usage:br codesleep 5; tsay/code  Feel free to contribute!  <answer294274> Here is my bash function (just put it anywhere in your code~/.bashrc/code or code~/.zshrc/code:  precodewatch(){   cmd=$@ # Somehow interpolate $@ directly doesn't work.   $@ &amp;&amp; say 'Watch Completed!' &amp;&amp; osascript -e "display notification \"Completed: $cmd\" with title \"Watch Alert\"" } /code/pre  To use it:  codewatch echo 'hi there'/code   You can also customize the notification sound as documented here: https://apple.stackexchange.com/a/115373/9622  <comment9915> Although you're at the command line, I think the answer here is actually Mac-specific and not Unix/Linux related. That's because I think you probably want to use Growl and `grownlnotify`. <comment9916> That isn't a build in command, at least on my box. <comment9919> http://growl.info/ Growl is the program referred to by @mattdm. <comment9923> I use nearly this exact approach but I extend Growl with [Prowl](http://www.prowlapp.com/) so that Growl can push the notification to my iPhone. <comment24797> This is a wonderful example of using shell operators `&&` to chain together several commands and wrap it up with a collective `||` or statement to raise an error. +1 indeed <comment24798> Excellent use of tput, and escape sequences - you've got everything except for a scrolling message in the title bar! <comment46046> You're on the Apple site. To make this an answer, please explain how to get `notify-send` on Mac OS X. <comment56654> I agree that this is kind of inappropriate, but I actually found this helpful. I came to this question from Google, and my original question was not Mac-specific. Like the original poster, I want a way to not have to monitor my terminal when running command that takes a long time; I just happen to be using Ubuntu :/ <comment65059> `printf '\a'` would be equivalent to `tput bel`. Note that Terminal doesn't bounce the Dock icon if the tab that caused the alert is currently active. <comment109552> Mountain Lion's Notification Center makes Growl unnecessary... see [my answer](http://apple.stackexchange.com/a/85969/45503) for how to use it for this. <comment146203> Nice! To be able to do that quickly though, I give up the error vs. success information and added a global alias to my zsh: `alias -g sd='; say done'`. This means I only have to add `sd` to any command, and I'll get notified. <comment191605> [terminal-notifier](https://github.com/alloy/terminal-notifier) can be installed via [homebrew](https://github.com/mxcl/homebrew), too: `brew install terminal-notifier`.  Then you can just write `myCommand && terminal-notifier -message 'finished'`.  Tested on OS X Yosemite (10.10.1). <comment197844> You should run `myCommand; terminal-notifier -message 'finished'` otherwise the notification will not be shown if `myCommand` fails. <comment232443> Awesome solution! By the way, this does not produce any sound like other OS X notifications. Any solution for that? <comment232478> @Cupidvogel you could just add a `say` command, e.g.  `my command ; terminal-notifier -message 'finished' ; say finished` <comment269691> nice one. and now i have something to play with <comment285029> Various answers to this question give lots more details: https://apple.stackexchange.com/questions/57412/how-can-i-trigger-a-notification-center-notification-from-an-applescript-or-shel <comment293613> Tried and both done and error are always being said :( Example: `(echo alik && echo Orly && say done) || say error` <comment293619> Found the problem. `say` returns an error :( - GSSpeechServer[4039] No handle for event rport on descriptor 12 <comment293621> `echo alik && (say done ; echo done) || (echo error ; say error)` - works even when say returns an error. <comment293710> Something is wrong with your OSX installation, then. My clean OSX 10.11 doesn't return error -- `say a && echo $?` gives 0. <comment304145> Very handy. I've been echoing with ```say -v Zarvox``` which makes everyone in the vicinity jump, this is a slightly less alarming notification.
Sending Control+Alt+ <char> to terminal in iTerm2 <body> When I press codeControl + Command + i/code I would like iTerm2 to send the shortcut as codeC-M-i/code (i.e. codectrl/code+codealt/code+codei/code) to my terminal.   I have   How can I do that?  I have tried with the following with no luck: img src="https://i.stack.imgur.com/hjNVa.png" alt="enter image description here"  Any thoughts on how to get this to work?  h2Update:/h2  I read the following here:   precodeTo have iTerm2 send "C-M-Space" to the terminal: 1) Open: Preferences &gt; Profiles &gt; some session you wish to edit &gt; Keys. 2) Add a new key binding by pressing the "+" button. 3) Select the "Keyboard Shortcut" field, and press ctrl + option + space. 4) Select "Send Hex Code" in the "Action" list. 5) Type "0x1b 0x00" to the field below the list. 6) Click OK and close the preferences window. /code/pre   I wonder if I can follow the same approach for my problem. How do I find out which Hex Code I need to send for codeControl+Command+i/code?  h2Update 2/h2  After reading this thread, I installed codeKey Codes/code and found the following info for codeControl + Command + i/code. What specifically am I supposed to enter as a codehex code/codein iTerm2 for this to work?  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; img src="https://i.stack.imgur.com/ct5Xj.png" alt="enter image description here"  <answer144614> (The theory is in the following 3 paragraphs and the best guess answer is developed in the remainder of this long winded explanation. The spoiler is our educated guess of code0x89/code as the answer to the given question. If not then you'll probably need to read much of the rest and do some searching on your own to see exactly what you should send and how. I do hope this helps.)  To sort this out the first thing is to realize that codeC-M-i/code is not the same as codeControl + Command + I/code except when (in a specific context such as an OS or a program) the codeCommand/code key is set to be the codeMeta/code key. In iTerm the choices for the codeMeta/code key are one or the other of the Option (Alt) keys. In iTerm one can't speak of the Command key as the Meta key although it's possible to capture the Command key press by defining it as an codeiTerm/code keyboard shortcut. So what does it mean in iTerm to press codeControl + Command + i/code? It's not defined; it sends no visible or invisible characters at all. (This is best seen by invoking codecat -v/code, codevis -o/code or another program that will visibly display invisible codes and trying various keystrokes.)\  But the idea of pressing codeC-M-i/code is somewhat defined and often including the codeMeta/code key with another key combination is equivalent to pressing the codeESCape/code key followed by the same key combination. That appears to be what you were trying to do by setting a key to output the escape sequence: codeESC + ^i/code. If that didn't work then we need to know what string of characters/bytes is actually wanted by whatever program you are trying to control. Following the example you pointed to I created a hex sequence of code0x1B 0x09/code which produced the same output as your ESC sequence. (Hex code1B/code or code0x1B/code = Binary code000110111/code = Octal code033/code or \033 = Decimal code27/code…value of code27/code strongnot/strong code2/code followed by code7/code; after a while these particular numbers all start to mean codeESCape/code character when one sees them.)  Now, codeKey Codes/code was a good try being the same sort of idea as using codecat/code or codevis/code to visualize the characters that get sent. The problem is that codeKey Codes/code is not running within codeiTerm/code but is running within codeOS X./code One could say the codeCommand/code key is codeOS X's/code codeMeta/code key but that train of thought isn't useful since codeOS X/code defines the function of its codeMeta/code key quite differently from how codeiTerm/code defines its codeMeta/code key. If you go into codeKey Codes/code and try pressing codeControl + i/code with and without the codeCommand/code key you'll see that the difference is in the resulting modifiers; but the modifiers are internal flags within codeOS X/code that codeOS X/code creates by examining what keys are pressed. The actual output code is closest to the Unicode character shown (code0x09/code) and you'll see that both with and without the codeCommand/code key you receive the same character. But that's illusory anyway since what actually happens is that codeOS X/code gets the Key Code and the Modifers values and interprets those codes as it wants. codeControl + i/code comes closest to "sending" a code^i/code but add the codeCommand/code key and, if the codeFinder/code is the receiving the results, you get one of the various codeGet Info/code commands; another program may interpret it as it likes. It's turtles on turtles on turtles all the way down, i.e., what you begin with may end up doing many different things depending on what is re-interpreting what, and so on.  Now I have to try to give you an answer that will work for you, but the preceding was necessary to show why I can't say for sure. But I can make an educated guess. First, the context is codeiTerm/code and I assume you are running a program in iTerm that does something in response to what is said to be codeC-M-i./code If, in codeiTerm/code I set one Option/Alt key to be the Meta key and then press that key with the code^i/code keys we will expect that we will get what we want to happen to happen. So let's find out what gets sent by doing that. If you use codeKey Caps/code it won't say anything different since you're back outside of codeiTerm./code But when I use the codecat -v/code command which does it's best to make the invisible visible on the screen and press codeC-M-i,/code then along with a strange diamond shape character I get the string codeM-^i/code which seems to be a way to say codeM-C-i/code. That looks good.  Now I get out of the codecat/code program and go to the codevis -o/code program which will try to give me some octal values for some of the invisible characters. Now pressing codeC-M-i/code gives me an octal value (after pressing return) of code\211/code as well as that funny diamond. (Octal code211/code or code\211/code = Binary code10001001/code = Hex code89/code or code0x89;/code which is encouraging since when I earlier turned on the codeMeta/code key in codeiTerm/code it gave me a warning a that codeMeta/code was usually used on older systems and new systems generally use the code+ESC/code code sequence…back to where you started! I also have seen that what the codeMeta/code key often did was to output the ASCII 7-bit printable character with its high-order bit (leftmost bit usually set to zero) set to 1. If you strip the leftmost 1 from the binary coding of what we received you're left with a code1001/code binary = Decimal 9! code9/code is the character that pressing code^i/code "sends out." That looks good.  Just to go full circle and check it out further I can go back to codeiTerm,/code make sure I've turned off my codeMeta/code key options (just in case) and define a new keyboard shortcut to some key that sends a code0x89/code (Hex code89/code). Then open a new window so that the changes are active and press the key you assigned the code0x89/code with codevis -o/code running to interpret your characters. Out comes the same funny diamond shape and the octal string code\211/code. So it appears we have set up a shortcut key to produce codeC-M-i/code to the best of what we know.  Whether that key will do what you want depends on whether the program that wants that keyboard code handles what we gave it. Not knowing more this is a best educated guess. If it fails then it's necessary to delve further into the end program that is being controlled [I'd venture codeEmacs/code but, emhey/em, I use codevi/code so what do I know ;-] Hopefully some of the techniques and ideas presented here would help you determine how to send the correct codes once you found them. I hope that this works for you. Note that without all the fuss you can get a pretty good idea that it will or won't work by turning on a codeMeta/code key in codeiTerm/code and pressing codeC-M-i/code to see if that works; if so then proceed to define your shortcut key.  <answer144903> I finally sorted out the various issues to come up with a solution.  The problem seems to be that if the codeControl key/code is part of the keyboard shortcut  then no other modifier keys that are also pressed will change the code that is sent by that keypress.  If codeControl + i/code produces the code^i/code (codetab/code) character then adding more modifiers to the shortcut will still produce the same code^i/code code, at least when using codeiTerm2/code.  This may be occurring at the OSX level or perhaps at the Unix level where a codetermcap/code table handles the translation of "terminal keys" to "output codes." It can be observed with codeiTerm2/code by using code"cat -v"/code or code"vis -o"/code to see the output being generated and is also seen when using codeKey Codes/code (without codeiTerm2/code running) which makes OSX the more likely culprit. That conclusion is supported by noting that the general user is not able to redefine certain keyboard shortcuts (without difficulty) that are reserved for basic OSX functions (such as codeCommand-Tab/code for program switching).  It is possible to programmatically differentiate any set of modifiers pressed with a character key but those modifier flags are accessible programmatically within OSX and by a totally unique set of codes for every different set of keys pressed. To witness this, use codeKey Codes/code and while holding the codeControl/code key and pressing a character key and then doing the same while pressing additional modifier keys at the same time, note that it is always the same character code that is produced. Yet codeKey Codes/code has access to the various keys being held and is able to display them to us in the "modifier" field that it reveals. And, if codeiTerm2/code could only see the standard codes produced from various key presses and not also see the modifier flags then codeiTerm2/code itself wouldn’t be able to define the range of shortcut keys that it is actually able to define.  On the other hand, after identifying each set differently modified keys in a unique manner, codeiTerm2/code appears to pass it’s generated codes to OSX where they are handled in the same way as if they’d been keyed on a keyboard, resulting in identical output for groups distinguishable keystrokes.  So, for example, codeiTerm2/code may pass the unique codeControl + Alt + i/code determined code(s) out for the use of codetmux/code but OSX takes them and tosses out a few details before delivery, making the code appear to be just code^i/code when it finally arrives for codetmux/code to handle. The shortcut binding in codetmux/code expects to receive the code we thought we were sending but along the way OSX has removed the information about the codeAlt (Meta)/code key, the same as it would do if the keyboard shortcut had been typed on a keyboard.  The solution is to find a key combination that won’t be used for something else and that can be transmitted without being changed to another key combination that you do want to use. That’s where codeKey Codes/code is useful since it let's you test many key  combinations and find what the key presses are translated to be "unique enough."  Here’s the process I used to make it work for me:  strongGoal: Running codetmux/code in codeiTerm2/code, I want to be able to press codeCommand-Control-i/code and have codetmux/code execute the "codeselect-pane -U/code"command./strong  ul liChoose an esoteric key press that you won’t be using. Consider a multi-key sequence with the codetmux/code escape character followed by another unusual key press making it much less likely to be needed.  I’m choosing to send the standard tmux escape character (code0x02 = ^b/code) followed by the ansi code sequence for codeF1/code (code0x1b 0x4f 0x50/code).  Good keys to look at are the less used characters generated on a Mac by holding down codeAlt/code (codeOption/code) and codeShift/code with another character key./li liWithin iTerm2 open Preferences and define the Command+Control+i shortcut in either the global key shortcuts or as a keyboard shortcut for a specific profile.  ul liPress the code+/code button to add a new shortcut. /li liClick in the Keyboard Shortcut field and hold down the codeCommand/code and codeControl/code keys while you press the "codei/code" key./li liUse the mouse to select "codeSend Hex Code/code" in the codeAction/code drop-down. (Trying to use codeTab/code to leave the Shortcut field will change the value for the shortcut.)/li liType the string "code0x02 0x1b 0x4f 0x50/code" (without the quotes and assuming that you are using the default codetmux/code escape character, code^b = 0x02/code)./li liPress the codeOK/code button to commit your shortcut. Close codePreferences/code./li /ul/li liWithin codeiTerm2/code, invoke a codetmux/code session and define the key binding for the codes codeiTerm2/code will send.  ul liInvoke tmux as you normally would./li liIn the codetmux/code window type the command: "codetmux bind-key F1 select-pane -U/code" (without the quotes.)/li /ul/li /ul  Test it by splitting your codetmux/code window into several appropriate panes and try using codeCommand+Control+i/code to move through panes vertically. If successful, you'll probably want to record your key-binding with the start-up bindings invoked by codetmux/code on startup.  This method worked fine for me and should work well unless you have somehow used all the possible keyboard combinations for other uses.  Methods like this one combined with practice and experience guessing the inner workings of a system should can help work around situations like this one that may feel foreign and overwhelming. Some parts of the above explanation are reasonable guesses as to what is occurring or that may assign blame to the wrong process but I hope that it’s helpful as a guide to how problems like this can be approached with less than a complete understanding of the whole system.   <answer219677> The easiest method to send key-combinations to terminal is to activate +Esc is Key setting.  iTerm2  Preferences  Profile  Keys  change "option key acts" from normal to +Esc  <comment170194> How exactly do you expect to send the command key to the terminal? <comment170208> Thanks @0942v8653 I would like to send it as `Alt` <comment170446> Thanks a lot Zhora. This is extremely helpful, although unfortunately `0X89` didn't do it. The receiving program is actually `tmux` where I have `.tmux.conf` listening to `bind-key -n C-M-i select-pane -U` (i.e. the shortcut `C-M-i` is supposed to call `select-pane -U`. I am able to do this get this to work if I set it to `M-i` (and ask iTerm to send the appropiate Esc+i, but not with `C-M-i`. <comment170447> To be clear, yes I am running Tmux on the shell, even though iTerm technically itself relies on Tmux. This shouldn't matter. I have been doing this for years. I do this because (1) I don't like relying exclusively relying on `iTerm2` for multiplexing, and because (2) this allows me to detach from remote sessions. <comment170690> I once wrote up a brief for small claims court and the rigid deadline for filing prevented me from sleeping for 3 days and nights; the result was an absolute mess to say the least. As I look back at your question and my answer I’m reminded of that experience (but to a lesser degree by far). In rereading it I think I may have confused and switched around parts of the question with parts of my intended solution.  I do hope it helped somewhat and I think my newer answer will clarify things and provide a definite solution.
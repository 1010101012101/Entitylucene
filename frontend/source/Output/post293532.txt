Can you actually use Terminal to crash your computer? <body> People who don't understand Terminal are often afraid to use it for fear that they might mess up their command and crash their computer. Those who know Terminal better know that that's not the case - usually Terminal will just output an error. But are there actually commands that will crash your computer?    h1WARNING: you could lose data if you type these or copy paste, especially codesudo/code and coderm/code commands./h1  <answer293534> Not sure what you mean about 'crash'ing the computer - if you would re-phrase it to say 'render the computer unusable', then yes.  Certainly all it takes is a single stray command - just a moment where you're not thinking clearly about what you're doing, similar to when you speak without thinking, and the damage can be immense and almost immediate.  The classic example:  precode$ sudo rm -rf / /code/pre  If you let that command run for even just one second, that can wipe out enough of your system to render it unbootable, and possibly cause irreversible data loss.  Don't do it.  <answer293543> Sure, make sure you have a backup and save any files you care about, then type codehalt/code  Assuming you then use codesudo/code to be root, the Mac will crash.   The biggest risk from command line is data loss. The macOS interface is designed over decades to not surprise people and shred their data or settings or apps. The macOS graphical interface also exists to remove the learning curve (a steep one) to being safe and mastering shell scripting.   You lose those protections which is why I caution people starting with terminal app or ssh. If you have a backup you know works and have the time and confidence/skill to perform a restore, then you should dive in and learn and even break things.   <answer293546> Causing a kernel panic is a more akin to crashing than the other answers I've seen here thus far:  precodesudo dtrace -w -n "BEGIN{ panic();}" /code/pre  (code taken from here and also found in Apple's own documentation)  You might also try:  precodesudo killall kernel_task /code/pre  I haven't verified that the second one there actually works (and I don't intend to as I actually have some work open right now).  <answer293554> One way to crash a computer is to execute a so called fork-bomb.   You can execute it on a unix-sytem by:  precode:(){ :|: &amp; };: /code/pre  It's a command that will recursively spawn processes till the OS is so busy it won't respond to any action anymore.  <answer293567> Suppose you don't know what your doing and attempting to do a backup of some hard drive   precodedd if=/dev/disk1 of=/dev/disk2  /code/pre  Well if you mix those up (switch if and of), it will overwrite the fresh data with old data, no questions asked.  Similar mix ups can happen with archive utils. And frankly with most command line utilities.  If you want an example of a one character mix up that will crash your system take a look at this scenario: You want to move all the files in the current directory to another one:  precode mv -f ./* /path/to/other/dir /code/pre  Let's accept the fact that you learned to use code.//code to denote the current directory. (I do) Well if you omit the dot, it will start moving emall/em your files. Including your system files. You are lucky you didn't sudo this. But if you read somewhere that with 'sudo -i' you will never again have to type in sudo you are logged in as root now. And now your system is eating itself in front of your very eyes.  But again I think stuff like overwriting my precious code files with garbage, because I messed up one character or because I mixed up the order of parameters, is more trouble.  Let's say I want to check out the assembler code that gcc is generating:  precodegcc -S program.c &gt; program.s /code/pre  Suppose I already had a program.s and I use TAB completion. I am in a hurry and forget to TAB twice:  precodegcc -S program.c &gt; program.c /code/pre  Now I have the assembler code in my program.c and no c code anymore. Which is at least a real setback for some, but to others it's start-over-from-scratch-time.  I think these are the ones that will cause real "harm". I don't really care if my system crashes. I would care about my data being lost.  Unfortunately these are the mistakes that will have to be made until you learn to use the terminal with the proper precautions.  <answer293634> Answers that call codesudo/code should be considered invalid. These already assume administrative access to the system.  Try codeperl -e 'exit if fork;for(;;){fork;}'/code. OSX may have some safeguard against this now. If is presents an apple bubble asking if you want to terminate Terminal app and subprocesses, you're (almost) good.   codewhile true ; do cat /dev/zero &gt; /dev/null &amp; done/code is also very handy, esp. if you don't have codeperl/code.  codefor i in 1 2 3 4 ; do cat /dev/zero &gt; /dev/null &amp; done/code will just do a funny little CPU load test. Very good for checking if your heatsink and fan are up to par.  <answer293642> Another one you can do (that I have done by mistake before) is:  precodesudo chmod 0 / /code/pre  This will render your entire file system (which means all commands and programs) unaccessible...except by the root user. This means you would need to log in directly as the root user and restore the file system, BUT you are unable to access the codesudo/code command (or any other command, for that matter). You can restore access to commands and files by booting into single-user mode, mounting and restoring the file system with codechmod 755 //code.   If this is done recursively with codechmod -R 0 //code then this will render the system unusable. The proper fix at that point is to use Disk Utility from the recovery partition to repair disk permissions. You may be better off just to restore a snapshot or backup of your file system if this was run recursively.  <answer293716> I am only a bash beginner, but you could set a while True; do COMMAND; done; Most people would try Ctrl+C that will stop command, not the external process (ctrl+Z, which then need to be killed). I guess that if command is some heavy operation like multiplying large number to their own power, that could mess with your ressources. But indeed, modern OS usually are protected against such mess.  <answer293782> Yes, you can completely destroy your system. Accidentally doing something with codesudo/code privileges is one example that has been posted, whether it's forgetting a few characters that instruct the terminal to do something completely different than you intended. coderm/codeing code//code instead of code/tmp/\*/code is only a 5 character difference. Putting a space in the wrong place could do something completely different as well. Other times, seemingly well meaning instructions could have malicious code obfuscated into it. Some people on the internet are very good at obfuscating code.  There are also commands that, using html, can be made font size zero, so something completely innocuous looking, when copied to the clipboard, could in fact be installing someone's git repo as a trusted source and downloading malware.   And there are commands that you can run that open you to exploit, or that could be perfectly well intended but removes important files or programs or corrupts your disk. In fact, using tools incorrectly could do something as basic as accidentally writing over your boot sector, or the head of your disk, or lots of other issues.  An example of something less destructive that hasn't been posted is opening binary files in codevi/code. If you've ever tried it, you'll know that it can mess up your terminal to the point that it's unusable until it is codereset/code.  Alternatively, there are commands that will bog down your machine, like:  precodeyes &gt;&gt; /dev/null &amp; yes &gt;&gt; /dev/null &amp; yes &gt;&gt; /dev/null &amp; yes &gt;&gt; /dev/null &amp;  /code/pre  You can try that one, it's not going to do damage, but it will bog down your processor, and you'll have to kill each process you've spawned.  That being said, in computing it's generally taken that you can't make an omelette without breaking a few eggs. You should be cautious at the terminal, but the only way that one can become better at using the OS is by learning and practicing.  <answer293785> Modern macOS makes it emreally/em hard to crash your machine as an unprivileged user (i.e. without using codesudo/code), because UNIX systems are meant to handle thousands of users without letting any of them break the whole system. So, thankfully, you'll usually have to be prompted before you do something that destroys your machine.  Unfortunately, that protection only applies to the system itself. As xkcd illustrates, there's lots of stuff that emyou/em care about that isn't protected by System Integrity Protection, root privileges or password prompts:  img src="https://imgs.xkcd.com/comics/authorization.png" alt="XKCD 1200"  So, there's tons of stuff you can type in that will just wreck your user account and all your files if you aren't careful. A few examples:  ul licoderm -rf ${TEMPDIR}/*/code. This seems totally reasonable, until you realize that the environment variable is spelt strongcodeTMPDIR/code/strong. codeTEMPDIR/code is usually undefined, which makes this coderm -rf //code. Even without codesudo/code, this will happily remove anything you have delete permissions to, which will usually include your entire home folder. If you let this run long enough, it'll nuke any drive connected to your machine, too, since you usually have write permissions to those./li licodefind ~ -name "TEMP*" -o -print | xargs rm/code. codefind/code will normally locate files matching certain criteria and print them out. Without the code-o/code this does what you'd expect and deletes every file starting with codeTEMP*/code (emas long as you don't have spaces in the path/em). But, the code-o/code means "or" (not "output" as it does for many other commands!), causing this command to actually delete all your files. Bummer./li licodeln -sf link_name /some/important/file/code. I get the syntax for this command wrong occasionally, and it will rather happily overwrite your important file with a useless symbolic link./li licodekill -9 -1/code will kill every one of your programs, logging you out rather quickly and possibly causing data loss./li /ul  <answer293864> precodesudo kill -9 -1   /code/pre  I accidently performed a codekill -9 -1/code in a perl-script, running as root. That was as fast, as pulling the power-cord. On reboot, the server made a filesystem-check and continued running properly.  I never tried that codesudo kill -9 -1/code command on the commandline. It might not work, because the process-ID "-1" means "kill all processes that belongs to the caller's process-group".    Not sure, if with sudo, that also means init and all the kernel-stuff...  But if you are root, codekill -9 -1/code will definitely make an immediate stop - just like pulling the power-cord.  By the way - nothing will appear in logfiles, because that command is the fastest killer in the west!    Actually, to recover, I went to our sysadmins and told them, what I did. They did a hard reboot, because there was no way to log in on that server (RHEL6).  A codekill -9 -1/code as root kills every process, that runs as root. That is i.e. sshd. That logged me out immediately and prevented anyone from logging in again.  Any process started by init - including init have been killed, unless they changed UID or GID. Even logging in through serial console wasn't possible any more. codeps -eaf | grep root/code shows some fancy processes, which, if they react on a SIGKILL in the default way, would pretty much stop even basic writing to HD.    I will not try this now on my laptop :-) I am not curious enough to finding out, if a codekill -9 165/code ([ext4-rsv-conver]) would really stop writing to the HD.  <answer293891> It's a little ambiguous what you mean by "crash" your computer... and there's no definitive correct answer for that, although there's some useful examples in other answers. Since your question is more ambiguous and general, I'd like to focus on the nature of the question and give a more general answer.     People who don't understand Terminal are often afraid to use it for fear that they might mess up their command and crash their computer   I think the command line is a double-edged sword, and often a very sharp one. It's greatest strength is also it's biggest weakness for new users: CLI programs do what you say, witout asking if it's really what you meant. They often don't ask for confirmation, they don't provide hand-holding or interactive help, and their options are short, often terse, sometimes confusing text-based strings. Note that they strongare/strong generally emvery well/em documented, one just has to read the manual (which is almost always codeman &lt;command you are about to run&gt;/code) and take the time to understand what the command line they are going to run will do.  This mode of operation is empowerful/em -- it means that seasoned CLI users can craft long command "pipelines" which do complext tasks with single commands. This is because the task won't ask "Are you sure?" every step of the way, it does what it's told. But for a user unfamiliar with this mode, and used to a GUI where online help is ema click/em away, it's unfamiliar and scary.     But are there actually commands that will crash your computer?    Can you "crash" your computer using the CLI? Maybe. You can certainly cause data loss if you use a destructive command incorrectly. E.G. many of the answers here mention coderm/code, a command which deletes files. Obviously, you can cause data loss with that command, emit's what the command was designed to do./em  As other answers have pointed out, you can use the command line to render your machine virtual unusable for a period of time: you can shut down without confirmation, cause a process to use 100% of your available resources without confirmation, kill all your programs or destroy your filesystem. If you really wanted to, you could use the CLI to craft a kernel extension which causes the kernel to panic (which is the closest to a "crash" I can think of)  The command line (accessed via the Terminal) is a powerful tool. Often it's faster to solve a problem using Terminal than the GUI. Some solutions are only available using Terminal commands. However, they key to the CLI is emunderstanding/em. Don't execute random commands you see online. Read the man pages and understand what commands do. If you're unsure, ask someone or learn more about a command before running it.  <answer294570> Surely you still can cause a system crash using commands entered with Terminal.  With years it's getting harder probably due to all kinds of limits and protective measures applied but as Murphy's-like law states: "Nothing is foolproof to a sufficiently capable fool."  "Fork bombs" and all that coderm -rf/code script kiddies stuff are anciently known things for UNIX. With Mac OS X you can have more fun using its GUI sub-system parts (codeWindowServer/code to mention) or something like OpenBSD firewall aka codePF/code that Apple's engineers brought in but never managed to update since its 2008 state of things. codePF/code works in kernel so when it catches a quirk it's time Apple tells you "emyou/em restarted computer due to a panic" or stuff like this.  The worst part of this is you never can have an idea of where-n-why it panicked —  cause Apple doesn't provide any meaningful stack traces; you can only have hex numbers of stack frame's return addresses.  <comment370389> And just to share why I wanted to clarify the re-phrasing .. to 'crash' the computer in the traditional sense - to make it lock up - you'd need to give the CPU enough work to do that it can't respond in a timely fashion to other jobs .. like updating the graphics and move the cursor, for example.  I'm sure there's a way to do that from the command-line. <comment370401> Why invoke `rm` when `halt` will do the job? Or at l awe point the remove command at files you know don’t need to be backed up and cause permanent data loss? <comment370402> Out of curiosity: I know `sudo` is super user, and `rm` removes files, but what does `-rf /` do? Which files in particular does this remove? (Also, doesn't `sudo` require an admin password to run? I don't know about you, but if my computer prompts me for my password - not my Touch ID - I look twice to see what exactly is asking for it.) <comment370403> @DonielF `-r` means to recursively delete files in a directory. `-f` means "force" as in don't ask for confirmation, regardless of a given file's permissions. `/` is the root directory of the filesystem, which means it will destroy anything and everything, except maybe some special files that don't behave as typical files. Also, you'll have a pretty hard time finding a brief command that will crash your system without root / admin permissions. <comment370405> @GDP2 Ouch. [15] <comment370409> Just tried the second one in a 10.12.3 VM, and it just says: `No matching processes were found` <comment370410> Also, the first one doesn't seem to work, at least if SIP is enabled, `dtrace: system integrity protection is on, some features will not be available` `dtrace: description 'BEGIN' matched 1 probe` `dtrace: could not enable tracing: Permission denied` <comment370414> This one is a common one. And `rm` will go for the alphabetical order so `bin` will disappear rather early making any later command fail. Note also that `$ sudo rm -rf *` (clear anything in the current directory) will do the same if you've earlier done `cd /`. It's much more common to fail this way, and to empty the content of a directory you did not ment to empty. <comment370417> Better: `:(){sudo rm -rf /;:|:&};:`. Not sure if it works properly though, I don't have a proper VM set at the moment. <comment370421> @bunyaCloven if I understand your command correctly, then it's a command to *remove all folders without prompting*, which is **very dangerous if it works**. I wish you wrote a warning notice for that. <comment370432> @AndrewT. People shouldn't just type random commands they found on the Internet all willy-nilly. (especially ones in a thread called "can you crash your computer via terminal") <comment370436> I tried `rm -rf /` a while back, and `rm` said that if you want to remove root, then use such-and-such flag. No data was lost. It seems like there is a security protection now from blindly running `rm -rf /`. <comment370449> To my understanding modern versions of MacOS are "rootless" so this can be avoided. <comment370451> Your last point is one of many reasons why everyone should use version control <comment370459> +1, had a Sencha CMD once bugging out and stomping a file it uses for generating the final app due to a `+#` added at the end of the cmd (those keys are near enter so they can be added accidently). took some time to notice what happened but a git checkout of that file fixed that immediately <comment370482> @alexy13 That's only happening on Linux versions of `rm` AFAIK. macOS has SIP which (among other things) prevents you from wiping the OS by a careless `rm`. <comment370484> --no-preserve-root flag has been required since 2006 for this to work as intended <comment370486> The command sudo rm -rf / was messaged about when i was at Uni - made out it was a "new" chat program.... :) lots got caught ... Most of us always did a man page to verify commands before ever putting them on the command line.... learn quick ! <comment370487> The OP asked for a crash from the terminal, not a wipe. <comment370489> The fork bomb will actually do minimal damage on Mac OS X as it has upper bounds for the number of processes. <comment370491> @AlexanderO'Mara Not very surprised with your results on the second command; I figured that Mac OS X wouldn't allow you to just take down the kernel process in such a way. The results for the first command are also to be expected, as [`dtrace` was effectively neutered by SIP.](https://apple.stackexchange.com/a/208185/79496) <comment370496> -1 What alexy13 is saying: This will NOT do any damage nowadays. <comment370498> @DavidMulder your comment isn't super clear but I think I agree with it - that nobody should be saying that running rm won't do irreversible damage.  It's like saying that it's okay to point a loaded gun at someone because the safety is on - it's true that (most often) the gun won't fire, but the intent of the rm tool is to destroy whatever it's pointed at; the safety being in the way doesn't make it a good idea to point it at something important. <comment370499> @Harv No one is talking about actually using the command, but this answer is simply incorrect. The answer provides a command that will not do anything except show a string. <comment370500> `kernel_task` is not a normal process. It's immortal; It can't be killed except through an error of its own (and that would be called a KP and brings the entire machine down). `kernel_task`'s PID is nominally 0, but if you supply that to the `kill(pid, sig)` syscall, the man page says _If `pid` equals 0, then `sig` is sent to every process in the process group of the calling process._. So you're simply unable to send `kernel_task` a signal. <comment370502> @IwillnotexistIdonotexist Yeah, I figured as much would be the case; thanks for the info, though. Good stuff to have in mind. <comment370503> @DavidMulder oh I see, you're saying my answer only shows a string.  That's not true on all systems. <comment370504> @Harv Which Mac OS system is this not true on? Considering this is the Apple SE. You might well be right, I am not much of an Apple fan. <comment370505> @DavidMulder any system before SIP was introduced, which I believe was 10.10 or 10.11.  These new rm protection features, as far as I'm aware, are *very* new, and thus dangerous for people to think it's safe to just run willy-nilly.  See here: https://support.apple.com/en-us/HT204899 <comment370546> [Here](https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/commit/a047be85247755cdbe0acce6f1dafc8beb84f2ac#diff-3fbb47e318cd8802bd325e7da9aaabe8L351)'s a real-world case in which this actually happened - a `rm -rf` _really_ similar to a legal one, that went really wrong :/ <comment370558> You said, "... and even break things.", which is a good use case for one to do risky stuff in a virtual machine. :) <comment370602> I've mistyped 'find and remove' commands such that they find every file. <comment370622> @mgarciaisaia and [here is another](https://www.theregister.co.uk/2015/01/17/scary_code_of_the_week_steam_cleans_linux_pcs/) that was well publicised at the time. <comment370632> @bunyaCloven replace the `;` with an `&` and you get to remove all files and fork bomb at the same time, and see which breaks the system first! <comment370661> It just runs really fast, it won't crash anything. You just got to fork some intensive calculations so kernel maxprocs doesn't make you sad. try `while true do cat /dev/zero  /dev/null & done` <comment370666> thanks. I would have expected handling large numbers to make the computer go slow, it sometimes happened with very simple java/python programs I used for machine learning. <comment370668> The cat zero to null bit is a big number operation, in I/O at least. I use one of these per core of a CPU to do thermal tests. <comment370675> @sgr how does that make sense? If it begs people to try it and see if it works, then those people are **knowingly** trying something that they know if it works could destroy their system. I'm not sure how this ends up tricking someone into doing something they didn't expect. <comment370676> @piersb wiping a machine tends to crash it. <comment370677> @SGR so you're suggesting some user will see a question labeled "crash your computer", and decide to just copy-paste things into their terminal? `sudo rm -rf /` literally does nothing nowadays anyways. <comment370687> _"You can fix it by ... chmod 755 / "_ - **No you cannot.** Many files require different permissions from 755, either for security, or to work at all. `chmod 755 /` will leave your system insecure and broken in subtle ways. The only full recovery from `chmod 0 /` is through snapshot restore, backup restore, and/or reinstall. <comment370689> I remember there was a case here on stackexchange with a command like `rm -rf /${xyz}` and by accident value of `$xyz` was an empty string - bad luck because even the backup drive was mounted to local file system! <comment370698> @marcelm Good point. My suggestion was only to restore access to commands, not as a permanent fix. I've updated my answer to reflect that. As far as I know, chmod is not recursive unless you use the `-R` flag - so I thought subdirectories' permissions would not be affected? <comment370715> I once destroyed a program I was working on using `gcc program.c -o program.c` thanks precisely to tab completion. I learned to use version control religiously after that. <comment370737> @marcelm you are right, but the command shown is **not** recursive so only `/` is affected. <comment370746> The best answer so far, posting legitimately-looking commands that *could* be results of a simple typo and yet can result in a major damage. <comment370751> IIRC all this does is on macOS is print out "bash: Resource temporarily unavailable" repeatedly while using a fairly minimal amount of resources. macOS appears to set a hard limit on how quickly processes can spawn, or something like that. It's easy to Ctrl+C or just close the controlling terminal (killing all attached processes). <comment370752> This is really easy to do *by accident* with undefined variables in Bash. Something like `PROGDIR=/home/.local/removeme ; rm -rf ${PORGDIR}/*` will cause *immense* damage very quickly. Famous example of this happening with a well-known software company: https://github.com/valvesoftware/steam-for-linux/issues/3671 <comment370753> I once `sudo chmod -R 700 /` a new computer, figuring it would be a lot more secure if I did that. Surprisingly, it booted, and ended up with an empty menubar and blank desktop. Nothing else worked, but the recovery partition's Disk Utility Restore Permissions actually managed to set almost everything right! <comment370754> Some guy accidentally wiped all of his company computers in one line, I saw it on this site a couple years ago, it was fake but, it still could easily happen. I'll link if I can find it. <comment370785> Your first example is hardly harmful. Vim is actually quite sane when editing binary files. And in the worst case you can just close down the window. The second example with "yes" is annoying and will use up a fair bit of user CPU, but the system will remain responsive and you can easily kill the parent terminal window. <comment370796> The Terminal is just a *command-line interface* to running programs.  It is an alternative to a *graphical user interface*.  You can run arbitrary programs from either one.  Your question therefore doesn't really make a lot of sense; you instead should be asking: Can you crash your computer by running a program? <comment370797> Even with SIP enabled `rm -rf /` will still wipe `/etc` (and practically everything below `/Users` of course). The system may not immediately crash but the next reboot will surely be interesting... <comment370822> @musicman523 @AndreaLazzarotto Ah, good point about not having `-r`, I missed that. Yes, that would certainly change things. For the recursive case, my original comment still holds though :) <comment370823> Ugh... I want to try this so bad.  <comment370826> Could you explain command? How does this remove files? <comment370829> @patrix  `rm -rf /` is completely harmless on Linux and has been so for many many years. Additionally, the [POSIX specs](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/rm.html) require that `rm` not be capable of deleting `/`, so all POSIX-compliant systems will support it. So actually, it is BSD (and by extension macos) versions of `rm` that this is happening with and not Linux. <comment370835> @Muzer that's what i intended. Forgot that ; actually waits for the first command to finish. <comment370837> @GDP2 won't this minimal damage still force you to reboot your Mac? You'll not be able to spawn any killer process otherwise. <comment370839> @terdon As AD focuses on macOS etc a discussion of features the Linux version of `rm` has seems rather odd and may give users the impression that it is safe to play around with `rm -rf /`. Of course it will not delete `/` itself but everything deletable beneath it (which will do a lot of damage) <comment370840> You can use `rm -rf /*` to avoid `--no-preserve-root` warning. <comment370847> @patrix I quite agree that it seems odd, but, well, [you started it](https://apple.stackexchange.com/questions/293532/can-you-actually-use-terminal-to-crash-your-computer/293534?noredirect=1#comment370482_293534)! :P I was responding to your comment which falsely claimed that `rm -rf /` is dangerous on Linux. Of course this isn't the place to discuss Linux, but that's no reason to leave misinformation lying around. <comment370875> You can't "kill" the kernel, and this shouldn't cause a filesystem check in and of itself. How did you recover from the situation? Did you do a hard reboot? Because that's probably what caused the filesystem check :) <comment370876> What do you mean by "crash"? Commands run in the terminal can often be _powerful_ and will often "do what you say and not what you mean" without asking, unlike most Mac OS X GUI commands. But unless you intentionally _try_ to, you're unlikely to _crash_ the machine. (I can think of a few ways to intentionally do so however) <comment370878> FYI (for others reading this) `find` has a `-delete` argument which is _much safer_ than piping to `xargs rm` <comment370879> I disagree with "mess up your terminal to the point that it's unusable until you restart" -- try `reset`, that should clear up a terminal which has had binary output printed to it. or, just spawn a new TTY <comment370882> @marcelm Disk utility has a "Fix Permissions" option which should correct this without a full system restore <comment370884> This is known as a [Fork Bomb](https://en.wikipedia.org/wiki/Fork_bomb) and will likely render the system unusable (could be considered a "crash") but will not likely cause any permanent damage. But it's nasty! <comment370885> And `^C` _will_ kill the while loop also, but it just repeats too fast for the interrupt to be caught. Holding down `^C` may break out of the loop. Closing the terminal also will :) <comment370887> How will this crash? It just shuts the system down immediately. It even flushes kernel buffers so there's no (saved) data loss. https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man8/reboot.8.html <comment370903> @Ruslan I've run the fork bomb before, and while it may cause mild problems, it does not force a reboot. Now, if you set your max process limits higher than the defaults that might force you to reboot, if it's set high enough. The way to do that is: `launchctl limit maxproc soft hard` and `launchctl limit maxfiles soft hard`. Also, from `man setrlimit`: "When a soft limit is exceeded a process may receive a signal (for example, if the cpu time or file size is exceeded), but it will be allowed to continue execution until it reaches the hard limit (or modifies its resource limit)." <comment370908> Your edited answer makes sense. You can't actually kill `init` normally, but you can kill all gettys and SSH sessions and render the machine unusable. A [Magic SysRq](https://en.wikipedia.org/wiki/Magic_SysRq_key) should have allowed for a clean reboot, but it's often easier to just power-cycle and rely on the FS journal :) <comment370911> @Josh I didn't know how to recover. I meant to use softer language, but forgot to go back and  edit that. <comment370913> Cool, nw @JFA. It actually took me nay years to learn the `reset` trick! For more info: https://unix.stackexchange.com/questions/79684 <comment370914> @Josh thank you for that, it was a big help. It has indeed been many years for me :P <comment370937> Is modern MacOS really more crashproof? Most of these systems are for a single user. Do they really have sane maxprocs/cpulimits? Can you provide a reference? <comment370939> @Josh Then 'stty sane^M' and 'tput reset' should also be exciting for you. <comment370940> @Josh It is easier to catch INT if there's a tiny pause, like sleep 0.1, after the cpu-intensive task. <comment370942> Much easier, yeah. Gives the user event time to be handled <comment370956> Obligatory +1 for the XKCD comic. <comment370977> "Now I have the assembler code in my program.c" Nope. You have nothing. The redirection truncated the file before GCC even opened it. <comment370984> You, of all people, would know well the damage `ln -sf` can do... [and how to recover from it :-)](https://stackoverflow.com/questions/27489744/i-just-destroyed-libc-so-on-my-machine-what-can-i-do-now) <comment371021> @Josh: thanks for pointing that out. And, in the general case, one should use `find -print0 | xargs -0` to safely handle strange characters in filenames. <comment371025> @GDP2 Maybe that's the case with OS X _now_, but I can speak from personal experience in saying that its default limits were not sufficient to stop a fork bomb from bringing down the machine about 10 years ago. This personal experience consisted of finding that some student had run a fork bomb on the Computer Science Department's shell server at my university. We had to do a hard reset on the server to stop it. The student in question was trying to answer a question of "which of the following programs would crash a computer." He found the right answer. By experimenting on our server. <comment371026> @GDP2 As a side note, the student in question got his own special line in the ssh config file after that incident, making it quite difficult for him to log into the shell server... <comment371032> @Josh "but will not likely cause any permanent damage" Except for any currently-open unsaved work. <comment371042> @reirab Josh added the catch-all 'likely' to his statement. But MacOS is mostly for editing photos and video now. Don't the Adobe programs have automatic auto-save? <comment371057> Also, unsaved work is always at risk until it's saved. If your computer is rendered unusable, then you can't save anything you have open :) <comment371060> Agreed. More useful xargs advice: use `whatever | xargs echo something` first, to preview what commands xargs will actually run. xargs is a great example of why the CLI is so powerful: you can operate on many, many items at once without pesky confirmation and hand-holding... just make sure you're telling it to do what you want. <comment371061> @Josh MacOS is so easy to save stuff in. It's always -S. You shouldn't have written 'likely'  <comment371129> @reirab Lol, yeah, I believe it. Certainly the fork bomb is not a toy, although I believe it is not a severe threat on more modern, properly protected systems. <comment371147> Pasting commands wrom the web can be [very dangerous](https://thejh.net/misc/website-terminal-copy-paste). Regardless of possibility to hang your machine. Typing commands that you understand at least vaguely shouldn't be dangerous though. Otherwise a lot of ways to screw your computer. It's like clicking on random system configuration settings in GUI but in GUI at least possibilities are more limited. wrt the danger of pasting commands - the text you visually see copied can be different from the actual text copied, thus it can contain malicious commands intermixed. <comment371162> I use this all the time in front of Linux people, and my machine handles it mostly fine (and the side-effects seem to disappear after a few minutes) where as theirs crashes instantly. <comment371459> That's a bit of a contrived example.  `gcc -S program.c` writes the asm to `program.s`, not to stdout.  (use [`gcc a_function.c -O3  -S -o- | less`](https://stackoverflow.com/questions/38552116/how-to-remove-noise-from-gcc-clang-assembly-output) if that's what you want.)  As @nneonneo says, the plausible scenario is that you want to override the `a.out` default name for the executable, and tab-complete `gcc program.c -o program.c`.  But when that happens,  just go back into your editor and re-save the file, assuming you suspended it or tabbed away instead of exiting. <comment371479> With gcc5.4, doing `gcc program.c -o program.c` gives `gcc: fatal error: input file ‘program.c’ is the same as output file compilation terminated.` <comment371515> Oh man, I am actually really happy they added that user-interface improvement in GCC. It's been a while since my last blunder, but it's nice to see that I'll have a little protection from that next time. <comment371516> @иσαнcяişтiпσ Maybe https://serverfault.com/questions/769357/recovering-from-a-rm-rf <comment371609> @wythagoras that's the one <comment371616> @nneonneo You're right, I left the super malicious answers until the end. Other answers have better examples, so I tried to put examples that weren't in other answers. These two aren't as harmful, but they can be encountered on a daily basis.
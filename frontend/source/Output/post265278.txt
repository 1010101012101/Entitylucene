Applescript Validating USB Stick - Matching serial and mount point <body> I want to be sure that the USB stick at 'usbMountPoint' is also the one with the matching 'usbSerialNumber'  precode-- Get Mount Point of script's USB host tell application "Finder"    try        set usbMountPoint to text 1 thru -2 of POSIX path of (disk of (path to me) as alias)        log usbMountPoint --&gt; Output: /Volumes/usb-drive-name    on error        set usbMountPoint to POSIX path of (disk of (path to me) as alias) --&gt; if file is on desktop, path: '/', can't have ' ' hence no removing        log usbMountPoint --&gt; Output: /Volumes/usb-drive-name    end try end tell  -- Set Serial Num of USB Stick set usbSerialNumber to "C86000BDB9F2BFA04A31E8A1"  -- Check if usbMountPoint and usbSerialNumber exist set sysProfileUSB to (do shell script "system_profiler SPUSBDataType") as text if sysProfileUSB contains "Serial Number: " &amp; usbSerialNumber and sysProfileUSB contains "Mount Point: " &amp; usbMountPoint then    log "USB Stick Found!" else    log "USB Stick Not found." end if /code/pre  When validating to check if usbMountPoint and usbSerialNumber exist in system_profiler, the code should check if the USB device at 'usbMountPoint' has the serial number of 'usbSerialNumber'. Without this "matching/pairing", the user could simply have two USBs connected - one with the right serial number, the other with the script; while the code will return "Found" becuase 'contains' reads the entire system_profiler without validating that both variables come from the same device.  Any help would be greatly appreciated. Cheers.  <answer265480> Of course I do not know the total scope of what you're trying to accomplish however because as you presently have it coded, the emscript/em could be running from other then the target USB Drive. So I've written it a bit differently, however it does get the emmount point/em based on the emserial number/em if the target USB Drive is mounted. You can then branch accordingly to the conditions, i.e. whether the script is running from the target USB Drive or not and if the target USB Drive is mounted or not, etc. After getting the emmount point/em in the emcode/em, I've included another block of emcode/em to test against if the target USB Drive is mounted and where the script was run from. This obviously is just one example of testing and you'll have to do as you need. The bottom line here is, how I coded getting the emmount point/em of the target USB Drive based on the emserial number/em and this I guess it what you're really looking for.  Here's my take on the emcode/em and it's output when run from both the Desktop and the target USB Drive:  ul liNote: Before use, change the actual emserial number/em below to the appropriate value./li /ul  hr  AppleScript Code:  precode--    # Get the volume this script is located on.  tell application "Finder"     try         set theVolumeThisScriptIsLocatedOn to text 1 thru -2 of POSIX path of (disk of (path to me) as alias)         log "The volume this script is located on is: " &amp; quoted form of theVolumeThisScriptIsLocatedOn     on error         set theVolumeThisScriptIsLocatedOn to POSIX path of (disk of (path to me) as alias)         log "The volume this script is located on is: " &amp; quoted form of theVolumeThisScriptIsLocatedOn     end try end tell  --    # Set the Serial Number of the target USB Drive.  set usbSerialNumber to "200434112111BA425FA4"  --    # See if the USB Drive matching 'usbSerialNumber' is mounted and if so, get its mount point. --    # The variable 'usbMountPoint' will contain either its mount point, e.g., '/Volumes/...', or '' as in nothing.  set usbMountPoint to (do shell script "system_profiler SPUSBDataType | awk '/" &amp; usbSerialNumber &amp; "/' RS= | awk -F': ' '/Mount Point: /{print $2}'") as text log "The mount point is: " &amp; quoted form of usbMountPoint if usbMountPoint is equal to "" then     log "The target USB Drive is not mounted!" else     log "The target USB Drive is mounted!" end if  --    # See if the script is running from the target USB Drive or elsewhere.  if usbMountPoint is not equal to "" and theVolumeThisScriptIsLocatedOn is equal to usbMountPoint then     log "This script is running from the target USB Drive!" else     log "This script is not running from the target USB Drive!" end if /code/pre  hr  Replies when run from the target USB Drive:  precodetell current application     path to current application         --&gt; alias "16GB-USB:USB Test.scpt" end tell tell application "Finder"     get disk of alias "16GB-USB:USB Test.scpt"         --&gt; alias "16GB-USB:"     (*The volume this script is located on is: '/Volumes/16GB-USB'*) end tell tell current application     do shell script "system_profiler SPUSBDataType | awk '/200434112111BA425FA4/' RS= | awk -F': ' '/Mount Point: /{print $2}'"         --&gt; "/Volumes/16GB-USB"     (*The mount point is: '/Volumes/16GB-USB'*)     (*The target USB Drive is mounted!*)     (*This script is running from the target USB Drive!*) end tell /code/pre  hr  Replies when run from the Desktop strongwith/strong the target USB Drive connected:  precodetell current application     path to current application         --&gt; alias "Macintosh HD:Users:me:Desktop:USB Test.scpt" end tell tell application "Finder"     get disk of alias "Macintosh HD:Users:me:Desktop:USB Test.scpt"         --&gt; alias "Macintosh HD:" end tell tell current application     path to current application         --&gt; alias "Macintosh HD:Users:me:Desktop:USB Test.scpt" end tell tell application "Finder"     get disk of alias "Macintosh HD:Users:me:Desktop:USB Test.scpt"         --&gt; alias "Macintosh HD:"     (*The volume this script is located on is: '/'*) end tell tell current application     do shell script "system_profiler SPUSBDataType | awk '/200434112111BA425FA4/' RS= | awk -F': ' '/Mount Point: /{print $2}'"         --&gt; "/Volumes/16GB-USB"     (*The mount point is: '/Volumes/16GB-USB'*)     (*The target USB Drive is mounted!*)     (*This script is not running from the target USB Drive!*) end tell /code/pre  hr  Replies when run from the Desktop strongwithout/strong the target USB Drive connected:  precodetell application "Finder"     get disk of alias "Macintosh HD:Users:me:Desktop:USB Test.scpt"         --&gt; alias "Macintosh HD:" end tell tell current application     path to current application         --&gt; alias "Macintosh HD:Users:me:Desktop:USB Test.scpt" end tell tell application "Finder"     get disk of alias "Macintosh HD:Users:me:Desktop:USB Test.scpt"         --&gt; alias "Macintosh HD:"     (*The volume this script is located on is: '/'*) end tell tell current application     do shell script "system_profiler SPUSBDataType | awk '/200434112111BA425FA4/' RS= | awk -F': ' '/Mount Point: /{print $2}'"         --&gt; ""     (*The mount point is: ''*)     (*The target USB Drive is not mounted!*)     (*This script is not running from the target USB Drive!*) end tell /code/pre  hr  Understanding what the codeset usbMountPoint to (do shell script "...") as text/code command line is doing to set the emvalue/em of the codeusbMountPoint/code emvariable/em.  ul licodesystem_profiler SPUSBDataType |/code outputs all information related to the USB hardware and then gets piped to the first occurrence of codeawk/code in the command line./li licodeawk '/" &amp; usbSerialNumber &amp; "/' RS= |/code looks for the emserial number/em and outputs everything from the first blank line embefore/em the emserial number/em and the first blank line emafter/em the emserial number/em and its output then gets piped to the second occurrence of codeawk/code in the command line. This ensures the only line containing 'code/Mount Point:/code' in the output is associated with the emserial number/em (if the target USB Drive is mounted)./li licodeawk -F': ' '/Mount Point: /{print $2}'/code finds the line containing code'Mount Point: '/code then uses code': '/code as the field separator and prints the second field which will either be the POSIX pathname of the mount point of the target USB Drive, or code''/code as in nothing (because it wasn't mounted)./li /ul  <comment341157> Did my answer work for you or help in any way?
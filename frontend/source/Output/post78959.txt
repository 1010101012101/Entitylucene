What terminal is the Mountain Lion Terminal app emulating? <body> I recently migrated from 10.6 to 10.8. I use codeTerminal/code to connect to various linux boxes where the TERM variable is observed to be codexterm-color/code.  This seems to be consistent with the 10.6 setting of TERM.  However, since upgrading I've been having issues with my codeTerminal/code sessions if/when I resize them to something wider than 80x24.  What would normally be very long lines of text seem to wrap at 80 columns stronguntil/strong I resize again, at which point it displays properly.  That is, it's like the width is stuck at the last size (wrapping everything at the previous width) until a resize is done after displaying something expecting a greater width.  This sort of feels like either the [n]curses entry for codexterm-color/code got changed (it didn't) or that codeterminal/code is not really emulating an codexterm-color/code device.  The behavior is different (maybe better--I'm still evaluating) if specify a plain codexterm/code.  Is there a better setting for TERM when using Mountain Lion's codeTerminal/code?  <answer79016> As with many terminal emulators, Terminal emulates most of a VT100 plus some features from newer terminals, and some common extensions from xterm and other emulators.  There is no terminfo file that exactly corresponds to Terminal, but the closest match used to be codexterm-color/code, which represents an older offshoot of xterm. However, in recent versions Terminal is more fully compatible with xterm and codexterm-256color/code is the new default value for the codeTERM/code environment variable.  In strongPreferences  Settings  [profile]  Advanced  Emulation/strong there is a popup menu strongDeclare terminal as:/strong that sets the value of codeTERM/code (and that's all it doesâ€”it does not alter which features Terminal supports). If you're using a Mac that you've upgraded from an older OS version, you may want/need to update the setting to match the new recommended default if it is still set to codexterm-color/code. Using codexterm-color/code is not recommended and it is possible for it to cause problems because it isn't as close a match to Terminal's current feature set.  Despite the fact that installations of ncurses should include all terminfo files, some Linux distros do not, and in particular some of them omit codexterm-256color/code. If this is the case you'll see programs complain in various ways about not being able to find it, and the solution is to install the entire set of terminfo files, or at least all the xterm ones.  If codexterm-256color/code isn't available, the next best thing is codexterm-16color/code, followed by codexterm/code. These three are compatible and represent the current xterm version with decreasing numbers of supported colors (codexterm/code only declares the eight basic ANSI colors, though a lot of programs simply ignore that and assume that sixteen are supported, but codexterm-16color/code is the one to choose if you want to explicitly declare support for sixteen colors).  It's difficult to say exactly what could be causing the problem you're seeing, but the first thing to try is to run the codeinfocmp/code command on the remote host to see what it says. That will tell you which terminfo it is expecting and whether it was found.  If it's a generic ncurses or terminfo issue, it's likely to occur with other programs, like vim. You might try running vim or less, for example, to compare behaviors. If you're feeling motivated, you could run vttest http://invisible-island.net/vttest/ on the remote host and check that Terminal responds appropriately to the tests for drawing text attributes, resizing the display, and switching to/from the alternate screen.  When you resize a terminal window, the terminal program notifies the tty device, which sends a codeSIGWINCH/code signal to processes connected to it. Programs are responsible for responding to the signal appropriately. One thing to test is whether the codeLINES/code and codeCOLUMNS/code variables get updated in bash when you resize the terminal window. If that's working, then the signal mechanism is behaving correctly.  Another possibility is that the program isn't switching to/from the alternate screen correctly (which could be caused by having an incompatible terminfo selected). You can check the strongView  Hide/Show Alternate Screen/strong menu item to see which screen is currently active. If it's showing the wrong screen, you might try manually switching it with the menu item and see if that clears up the problem.  <comment91287> It could be a bug in terminal. Have you tried iTerm 2 (http://www.iterm2.com)? It has some nice features that terminal doesn't offer. If it behaves the same as Apple's Terminal.app, then it's probably a setting in one of your login files (.profile, .bashrc, .zshrc, etc... Depending on your current shell). <comment91406> Aha, I didn't notice the default TERM setting had changed-- I have a personalized _Settings_ I've been using for ages and it was still stuck on the old/pre-ML default value.  All better now, thanks! <comment91407> @MarkThalman thanks for the tip; I've been avoiding using anything non-stock so that I don't trip over myself when I go to take care of other folks' machines (the whole "once you fly first class, you'll never again be able to stand flying in coach" thing ;-)
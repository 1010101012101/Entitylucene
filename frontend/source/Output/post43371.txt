Way to limit how much RAM an arbitrary process can take up? <body> Lets say we have a OS X machine running with 4 GB of RAM. Is it possible to set it up so no single process can take up more than say, 3 GB, so no matter how memory hogging a process is, there's always some memory left over to keep the system responsive?  <answer43376> If you are running Lion (or newer OSX) Server on your Mac, you might be able to run OSX inside a VM (VirtualBox, Parallels, or VMWare, et.al.) on that Mac.  Limit the VM to 3GB of physical RAM, and any app or process inside the VM will also be so limited.  The system hosting the VM should stay responsive even if the OS in the VM is backing-swap-disk-limited or crashes.  If you are debugging a potentially runaway process, you might be able to ssh into the VM to run the debugger or a debug nub from the command line, and log stuff up until things lock up.  <answer43432> A similar question to this is noted here How Can I Limit the Amount of RAM a Mac OS Application Can Use?  They recommend using the strongulimit/strong command, but they were unable to successfully limit the amount to what they desired. I think the problem that they ran into was the fact that the option being set -u or -v was not accounting for the memory paging system, eg you can only allocate X amount of space for you process in real RAM, but we can page you out to virtual memory all day long.    Note that this may be Dangerous disabling Virtual Memory, it could result in your Mac just locking up, etc when it runs of of RAM.  Try running ulimit with arguments -l, -m, or -v however as noted in the ulimit man page it up to the OS if it will pay attention to these settings or not as noted.     ulimit: ulimit [-SHacdefilmnpqrstuvx] [limit]      Modify shell resource limits.      Provides control over the resources available to the shell and processes       it creates, on systems that allow such control.   Can't really find any definite source that confirms if OS X ignores ulimit or not, but after the referenced ulimit fail  If you can get ulimit to work for your needs by itself then give it a go, if not a combination of ulimit and or disabling virtual memory may be able to let you set up that 3 GB limit on select processes. FYI here is a good link for more information onCompletely Disable Virtual Memory in Snow Leopard System 10.6   precodesudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.dynamic_pager.plist /code/pre  <comment49272> No. And this would be counterproductive. Micromanaging RAM allocation is not something OSes are designed around. Free RAM is wasted RAM. Too much is made out of OS X's supposed poor RAM management. Closing Activity Monitor and getting on with your life seems to be the best remedy. <comment49273> @cksum There's a massive series of assumptions in your comment, most of which are wrong. I'm not trying to back seat drive OS X's memory management. What I'm *actually* doing is trying to find out if there's a way to retain enough system functionality while testing some code that rather easily turns into a runaway process. Because free RAM isn't wasted RAM if its what allows you to fix errors. <comment49274> Sorry, but if your question relates to programming, (development and testing) of applications, then it is off-topic for this forum. Please have a look at the FAQ for more info on what kind of questions belong here: http://apple.stackexchange.com/faq <comment49275> FFS, this isn't a programming question. It's an OS question. Limiting the memory an arbitrary process can use - Safari, Matlab, Call of Duty, whatever - at the OS level is unambiguously an OS question. <comment49277> Being a site for "Apple enthusiasts and power users" questions that in essence are about virtual memory are clearly in bounds and on topic. Even if development is related, this would be valid for tuning or performance issues. <comment49304> Related: http://stackoverflow.com/questions/3274385/how-to-limit-memory-of-a-os-x-program-ulimit-v-neither-m-are-working <comment49308> @Thilo that's likely the answer. You should post that as an answer to the question. <comment49353> This looks like the likely correct answer - I'll try it out when next I run this. For now, accepting the answer.
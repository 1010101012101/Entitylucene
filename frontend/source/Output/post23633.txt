Source .profile and .bashrc on ssh login without tty <body> strongHow do I make sure ssh sources code.profile/code and code.bashrc/code on login without tty?/strong  I have a Mac (10.6.8) that I'm using for various UNIX-y tasks like hosting git repositories.  I have remote login enabled via the System Preferences "Sharing" pane.  When I codessh/code into the machine, codebash/code sources code~/.profile/code, which I have set up to source my code~/.bashrc/code file and set up my MacPorts path.  The problem is that when I run codessh/code without a codetty/code, like this:  precodessh myhost echo \$PATH /code/pre  Or run a codegit/code command that essentially uses codessh/code in the same way:  precodegit clone ssh://myhost/~/code/myrepo.git /code/pre  My code~/.profile/code file is never sourced, so my code$PATH/code variable is missing code/opt/local/code (where MacPorts has installed codegit/code).  I am aware that:  ul liI can configure codegit/code on my local machine to use code/opt/local/bin/git-*/code on my remote machine/li liI wouldn't have this problem if I was forcing a codetty/code with codessh -t/code/li /ul  But I don't want to do either of those.  emI want my remote machine to source my code~/.profile/code file regardless of whether or not I'm logging in w/ a tty./em  How do I make that dream a reality?  Also: I checked the behavior on a couple Linux machines (Debian and Fedora), and both systems seem to source the code~/.bashrc/code file on login regardless of whether it is a codetty/code.  I was under the impression that BSD and Linux both use the same OpenSSH and bash implementations, so it seems like the difference in behavior might come from differences in code/etc/code config files?  <answer23650> Bash has special provisions in its source code to source code~/.bashrc/code when it's invoked by codershd/code or codesshd/code. It's a compilation option, which given your experience seems not to be turned on under OSX.  If you're logging in with a key, you can (ab)use the codecommand=/code option in the code~/.ssh/authorized_keys/code file. A key with a codecommand/code option is good only for running the specified command; but the command in the codeauthorized_keys/code file runs with the environment variable codeSSH_ORIGINAL_COMMAND/code set to the command the user specified (empty for interactive sessions). So you can use something like this in code~/.ssh/authorized_keys/code (of course, it won't apply if you don't use this key to authenticate):  precodecommand=". ~/.profile;          if [ -n \"$SSH_ORIGINAL_COMMAND\" ]; then            eval \"$SSH_ORIGINAL_COMMAND\";          else exec \"$SHELL\"; fi" ssh-rsa … /code/pre  Note that I put line breaks above for legibility, but this actually needs to be all on one line.  How can I set environment variables for a remote rsync process? may have other helpful suggestions.  <answer31560> this was very annoying. uncomment this line in config-top.h and rebuild:  /* Define this if you want bash to try to check whether it's being run by    sshd and source the .bashrc if so (like the rshd behavior).  This checks    for the presence of SSH_CLIENT or SSH2_CLIENT in the initial environment,    which can be fooled under certain not-uncommon circumstances. */  h1define SSH_SOURCE_BASHRC/h1  according the CHANGES in the source this behavior was changed in bash-2.05a-rc1.  but the current man page still claims the previous behavior:  precode   Bash attempts to determine when it is being run with its standard input    connected  to a a network connection, as if by the remote shell daemon,    usually rshd, or the secure shell daemon sshd.  If bash  determines  it    is  being  run  in  this  fashion,  it reads and executes commands from    ~/.bashrc, if that file exists and is readable.  It will not do this if    invoked as sh.  The --norc option may be used to inhibit this behavior,    and the --rcfile option may be used to force another file to  be  read,    but  rshd  does  not  generally  invoke the shell with those options or    allow them to be specified. /code/pre  <answer76355> Here's a method to have bash source .bashrc on non-interactive sessions so that you don't have to hard code environment variables in multiple places:  ol liSet codePermitUserEnvironment/code to codeyes/code in code/etc/sshd_config/code (man sshd)/li liSet codeBASH_ENV/code to code~/.bashrc/code in code~/.ssh/environment/code (man bash)/li liAdd this line to the top of your code~/.bashrc/code, which sources code/etc/profile/code for non-interactive sessions:/li /ol  This essentially duplicates the interactive login environment for non-interactive logins, without having to hard code environment values (e.g., $PATH) in multiple places.  precodeif [[ ! $- == *i* ]]; then         . /etc/profile fi /code/pre  Step 3. is needed only if you have the Macports path(s) set in code/etc/paths/code like I do. But if you're setting those paths (e.g., code/opt/local/bin/code) in code~/.bashrc/code, then I suppose you wouldn't need Step 3.   For your situation, you should be able to change code~/.bashrc/code to code~/.profile/code.   I have code~/.bash_profile/code source code~/.bashrc/code, and I do not use code~/.profile/code. With this configuration (and the above changes), bash environment variables (e.g., code$PATH/code) should look identical for interactive login, interactive non-login, and non-interactive sessions.  <comment26592> I'm gonna credit you with the answer to this since it was in the question you referenced, but I ended up using ~/.ssh/environment to set the path (hard-coded, unfortunately).  It works b/c I'm the only user who needs this functionality. <comment36206> that's good research, thanks! <comment84278> I tried to add this command line to authorized_keys on the host but found that in this case the key is not recognized anymore and I need to enter a password. Do I need to add it somewhere else? <comment84385> @highsciguy You probably got the syntax of the `authorized_keys` file wrong, or added an extra character on the line or something. In particular, make sure that your editor didn't split the line due to word wrap. <comment88575> @aaronstacy Check out my answer for a way to use ~/.ssh/environment and not hard code the path. <comment88577> If you use `BASH_ENV`, set it to `~/.profile`, and define environment variables there. Reserve `.bashrc` for interactive settings (aliases, completion, …). See [Alternative to .bashrc](http://unix.stackexchange.com/questions/3052/3085#3085) <comment88579> It's personal preference. I prefer to have all environment variables consistent across the different types of sessions, and it's less to maintain when all of those variables are defined in one file (i.e., ~/.bashrc). <comment88918> @ClaytonStanley thanks for the answer! it's been a while since i messed with this, but if i have to return to it and use your technique i may end up changing your answer to the accepted one. cheers!
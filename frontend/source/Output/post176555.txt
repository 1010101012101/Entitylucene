How do I make multiple screen recordings with the exact same portion of the screen <body> I can only select the portion of the screen to record manually. I want them all exactly the same so that when the videos are played sequentially, it all lines up.  img src="https://i.stack.imgur.com/hA0FP.jpg" alt="enter image description here"  I'm using quicktime and would ideally like to just stick with that if possible.  <answer176565> There is an App called Screeny that does this as well as many other things. $14.99 and can be purchased from the App store  <answer176569> Save this script as codecaperture.swift/code:  precode#!/usr/bin/env xcrun swift import Foundation  // Start QuickTime Player using AppleScript func startQT() {     var scriptToPerform: NSAppleScript?     let asCommand = "tell application \"QuickTime Player\" \n" +         " activate \n" +         " new screen recording \n" +         " delay 1 \n" +         " tell application \"System Events\" to key code 49 \n" +         " delay 1\n" +         " end tell"      scriptToPerform = NSAppleScript(source:asCommand)     var errorInfo = AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;()      if let script = scriptToPerform {         script.executeAndReturnError(errorInfo)     } }  // Click and drag the mouse as defined by the supplied commanline arguments func dragMouse() {     let args = NSUserDefaults.standardUserDefaults()      let x  = CGFloat(args.integerForKey("x"))     let y  = CGFloat(args.integerForKey("y"))     let w = CGFloat(args.integerForKey("w"))     let h = CGFloat(args.integerForKey("h"))      let p0 = CGPointMake(x, y)     let p1 = CGPointMake(x + w, y + h)      let mouseDown = CGEventCreateMouseEvent(nil, CGEventType(kCGEventLeftMouseDown), p0, CGMouseButton(kCGMouseButtonLeft)).takeUnretainedValue()     let mouseDrag = CGEventCreateMouseEvent(nil, CGEventType(kCGEventLeftMouseDragged), p1, CGMouseButton(kCGMouseButtonLeft)).takeUnretainedValue()     let mouseUp = CGEventCreateMouseEvent(nil, CGEventType(kCGEventLeftMouseUp), p1, CGMouseButton(kCGMouseButtonLeft)).takeUnretainedValue()      let kDelayUSec : useconds_t = 500_000      CGEventPost(CGEventTapLocation(kCGHIDEventTap), mouseDown) usleep(kDelayUSec)     CGEventPost(CGEventTapLocation(kCGHIDEventTap), mouseDrag) usleep(kDelayUSec)     CGEventPost(CGEventTapLocation(kCGHIDEventTap), mouseUp) }   if (Process.arguments.count != 9) {     println("usage:")     println("    ./caperture.swift -x 100 -y 100 -w 400 -h 300") } else {     startQT()     dragMouse() } /code/pre  Once the codecaperture.swift/code file is saved. You will need to make sure that it can be executed.  In Terminal.app run the command:  precodechmod +x caperture.swift /code/pre  Then you execute it with:  precode./caperture.swift -x 100 -y 100 -w 400 -h 300 /code/pre  This will start up QuickTime player ready to start recording like this:  img src="https://i.stack.imgur.com/1sA5g.jpg" alt="screenshot"  It relies on AppleScript and swift so you'll also need xcode installed.  This was really useful for me so I've put it up on github as caperture in case anyone wants to improve it.  <answer176595> I like @mat-burns answer a lot.  But since we would be running the Applescript from the command line to execute the swift code anyway I wanted to do it all from a single file.  Adding the Applescript to the swift code:  precode#!/usr/bin/env xcrun swift import Foundation  let kDelayUSec : useconds_t = 500_000  func DragMouse(p0: CGPoint, p1: CGPoint) {     let mouseDown = CGEventCreateMouseEvent(nil, CGEventType(kCGEventLeftMouseDown), p0, CGMouseButton(kCGMouseButtonLeft)).takeUnretainedValue()     let mouseDrag = CGEventCreateMouseEvent(nil, CGEventType(kCGEventLeftMouseDragged), p1, CGMouseButton(kCGMouseButtonLeft)).takeUnretainedValue()     let mouseUp = CGEventCreateMouseEvent(nil, CGEventType(kCGEventLeftMouseUp), p1, CGMouseButton(kCGMouseButtonLeft)).takeUnretainedValue()      CGEventPost(CGEventTapLocation(kCGHIDEventTap), mouseDown)     usleep(kDelayUSec)     CGEventPost(CGEventTapLocation(kCGHIDEventTap), mouseDrag)     usleep(kDelayUSec)     CGEventPost(CGEventTapLocation(kCGHIDEventTap), mouseUp) }  func ascript(){       var scriptToPerform: NSAppleScript?     let asCommand = "tell application \"QuickTime Player\" \n activate \n new screen recording \n delay 1 \n tell application \"System Events\" to key code 49 \n delay 1\n end tell"    scriptToPerform = NSAppleScript(source:asCommand)    var errorInfo = AutoreleasingUnsafeMutablePointer&lt;NSDictionary?&gt;()       if let script = scriptToPerform {          script.executeAndReturnError(errorInfo)       }  }  func main() { let p0 = CGPointMake( CGFloat(atoi( C_ARGV[1])), CGFloat(atoi( C_ARGV[2]))) let p1 = CGPointMake( CGFloat(atoi( C_ARGV[3])),  CGFloat(atoi( C_ARGV[4])))  DragMouse(p0, p1) } ascript() main() /code/pre  Once the code is saved and we have run code/bin/chmod +x ~/scripts/clickdrag.swift/code   to make the script executable  Change code~/scripts/clickdrag.swift/code to you actual path to the swift file.  We can now run the code from the command line :  strongUPDATE/strong   Before you would have had to enter the command line like so:  code~/scripts/clickdrag.swift  -x 364 -y 206 -dx 1038 -dy 726/code  But if we use the simple way of working out any bounds you need by  opening up a finder window and shaping it to the area you want to capture.  Then run this Applescript:  precodetell application "Finder" to get bounds of window 1 /code/pre  This will return the bounds in the results pane.  - {364, 206, 1038, 726}  It would be a lot easier to   copy and past code364, 206, 1038, 726/code into  the command as is.  The update above allows you to run the command like so.  code~/scripts/clickdrag.swift  364, 206, 1038, 726/code  <comment208525> You may find this helpful: https://apple.stackexchange.com/questions/63056/can-applescript-be-used-to-automate-a-screen-recording-session-on-os-x <comment208537> Thanks it put me in the right direction... I'll post my solution now... <comment208541> I think this might be our first answer with swift code in it! Stellar! <comment208567> I edited the answer. But I did not edit an error in your code as it may be intentional for some reason. But the line let `p1 = CGPointMake(x + dx, y + dy)` should be `let p1 = CGPointMake(dx, dy)`  there is no need to add the integers and doing so throws the bounds to be incorrect of what is placed in the applescript. Example if I use bounds `{364, 206, 1038, 726}` what I will get is a dragged window `{364, 206, 1402, 932}` <comment209181> Thanks Mark. dx and dy actually represent width and height, not the point in bottom right so I have renamed to reflect that. I also folded in your suggestion of merging into a single file. See https://github.com/mattburns/caperture for current version. Cheers <comment209221> Nice one matt. Love this code as it can be used for many things. Thanks. By the way you should accept your own answer...
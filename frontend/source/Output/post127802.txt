Given its filesystem layout, how does the Oracle Java JDK 8 installation work? <body> This is emnot/em a na&iuml;ve question; please bear with me.  Can someone tell me how an invocation of code/usr/bin/java/code on an Apple MacBook Pro from mid-2010 with both the Apple JDK and the Oracle 1.8.0 JDK installed results in the Oracle 1.8.0 JDK being found and used?  Please note that my version of the Apple-installed JDK 1.6 is recent enough that the Java Preferences application has been removed by them, so that does not factor into the determination of which Java VM to use.  Furthermore please note that code/usr/libexec/java_home/code is not invoked (by me, anyway) in any of my examples below.  OK, here we go.  Oracle's JDK 1.8 gets installed into code/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk//code.  Fine.  code/usr/bin/java/code, which is under Apple control, is a symbolic link pointing to code/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java/code. (code/System/Library/Frameworks/JavaVM.framework/Versions/Current/code is a symbolic link pointing to code/System/Library/Frameworks/JavaVM.framework/Versions/A/code (a directory), so, by extension, code/usr/bin/java/code after symbolic link resolution points to code/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java/code.)  code/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java/code is emnot/em a symbolic link.  It is an executable.  Its last modified timestamp is quite old, probably corresponding to when I installed JDK strong7/strong some time ago.  In any event, it does not correspond to the date on which I installed JDK 8.  code/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/bin/java/code is not equal in size to code/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java/code.  It is not a symbolic link either.  Its last modified timestamp corresponds to when I installed JDK 8.  These two are different programs.  Nevertheless, invoking either of these codejava/code variants with a code-version/code argument yields a version string identifying them as 1.8.  strongHow is the semantic link established between code/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java/code and code/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/bin/java/code/strong, given that neither is a symbolic link to the other?  Secondly, strongwho "owns" code/System/Library/Frameworks/JavaVM.framework/Versions/A/code: Oracle or Apple?/strong  Furthermore, consider the following output, especially the codeargv[0]/code setting identifying code/usr/bin/java/code as the program name, emeven though I never typed that/em (line 13 in the output below):  precodeLaird-Nelsons-MacBook-Pro:repository ljnelson$ env _JAVA_LAUNCHER_DEBUG=true /System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java -version ----_JAVA_LAUNCHER_DEBUG---- Launcher state:     debug:on     javargs:off     program name:java     launcher name:java     javaw:off     fullversion:1.8.0-b132     dotversion:1.8     ergo_policy:DEFAULT_ERGONOMICS_POLICY Command line args: argv[0] = /usr/bin/java argv[1] = -version JRE path is /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre jvm.cfg[0] = -&gt;-server&lt;- jvm.cfg[1] = -&gt;-client&lt;- 69 micro seconds to parse jvm.cfg Default VM: server Does `/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/server/libjvm.dylib' exist ... yes. ----_JAVA_LAUNCHER_DEBUG---- Launcher state:     debug:on     javargs:off     program name:java     launcher name:java     javaw:off     fullversion:1.8.0-b132     dotversion:1.8     ergo_policy:DEFAULT_ERGONOMICS_POLICY Command line args: argv[0] = /usr/bin/java argv[1] = -version JRE path is /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre jvm.cfg[0] = -&gt;-server&lt;- jvm.cfg[1] = -&gt;-client&lt;- 33 micro seconds to parse jvm.cfg Default VM: server Does `/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/server/libjvm.dylib' exist ... yes. JVM path is /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre/lib/server/libjvm.dylib 2242 micro seconds to LoadJavaVM JavaVM args:     version 0x00010002, ignoreUnrecognized is JNI_FALSE, nOptions is 4     option[ 0] = '-Dsun.java.launcher.diag=true'     option[ 1] = '-Dsun.java.launcher.diag=true'     option[ 2] = '-Djava.class.path=.'     option[ 3] = '-Dsun.java.launcher=SUN_STANDARD' Picked up _JAVA_OPTIONS: -Dfile.encoding=UTF-8 java version "1.8.0" Java(TM) SE Runtime Environment (build 1.8.0-b132) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode) /code/pre  <comment149752> JDK 7 is Oracle as well - I suspect they read a configuration set in System Preferences <comment149758> http://stackoverflow.com/questions/15120745/need-help-understanding-oracles-java-on-mac <comment149761> @Mark, thanks; it is; they do not. @Rene, thank you for the cross-link.  I've since found that both `/System/Library/Frameworks/JavaVM.framework/Versions/A/Commands/java` and `/usr/libexec/java_home` end up invoking a private framework called `JavaLaunching`, which is undocumented.  Running `strings` on it suggests that it does a simple stupid scan (!) of `/Library/Java/JavaVirtualMachines` and then uses some (undocumented) heuristic to figure out which is the most recent. Ugly and surprising.
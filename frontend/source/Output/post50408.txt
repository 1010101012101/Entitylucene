Endianness of iPhones? <body> I know iPhones (and iPads) run on ARM processors, which are little-endian by default (and iOS on itself is little-endian according to the Wikipedia page); however, ARM processors supposedly have the ability to switch between little-endian and big-endian. How possible is this and how does it work?  <answer50484> Endianness isn't something that end users have any real interaction with - but here is a 10,000 foot summary of what this means for users of Apple products.  In a nutshell - endianness for an internal processor is the same as the writing direction for a language. When you look at letters of an english text, we all agree to start on the top left and read first right then down. Other languages start on the right and read to the left and some even read down first before moving left or right.  It doesn't really matter to a user if the bits in an internal representation of an address or number gets stored little endian or big endian. In fact OS X on a Mac adheres to a big-endian representation and iOS adheres to little-endian ordering. This fact doesn't in any way mean that the two devices can't work together properly. This works because this representation only happens internally and doesn't get exposed to us as users.  <answer202034> even if you think you do not need to know the endianness someone might do. No need to explain why someone does not need it because you may do not know the context. The question is not "do I need to know endianness" but rather "is it big- or little endian". So concentrate on the subject please!  Having said that probably it is the best practice if we do not re-invent the wheel and just rely on the macros Apple provides for this. The reason is because they have spend quite some time to optimize these macros and made sure that works well with the simulator as well as on Mac, iPhone and all of their OS' and hardware.  If you dig down what is happening when you invoke codeCFSwapInt16BigToHost/code you may can see comments that suggests these macros are producing probably the best machine code you can get with the help of the compiler optimization:   precodeOS_INLINE uint16_t _OSSwapInt16(     uint16_t        data ) {   /* Reduces to 'rev16' with clang */   return (uint16_t)(data &lt;&lt; 8 | data &gt;&gt; 8); }  OS_INLINE uint32_t _OSSwapInt32(     uint32_t        data ) { #if defined(__llvm__)   data = __builtin_bswap32(data); #else   /* This actually generates the best code */   data = (((data ^ (data &gt;&gt; 16 | (data &lt;&lt; 16))) &amp; 0xFF00FFFF) &gt;&gt; 8) ^ (data &gt;&gt; 8 | data &lt;&lt; 24); #endif    return data; } /code/pre  <comment57822> How would the answer to this question be helpful to solve a problem or improve your experience of using an iPhone? If it addresses some real-world concern of a non-developer end user, it doesn't matter how technical it is, but if the question is only of interest to developers, it's off-topic here. <comment57824> Ok, then should I move it to stackoverflow? <comment57828> @myrkos Or http://superuser.com <comment57882> Let's sharpen the question first. We're looking for short questions that invite a long answer. This applies for all sites. SuperUser isn't the place for iOS questions of any sort in general. We're the best place for hardware questions on iOS. If you have a specific programming problem, then asking that question and explaining how iOS hardware endianness is affecting your specific programming question would be the way to go [SO and not here is the forum in that case]. If you want a user perspective on this issue, it's hard to see any site being a better place to house that question than here. <comment57890> "ARM is a little-endian, 32-bit RISC architecture widely used by mobile devices. Gotta make a small note here: ARM is bi-endian (bytesexual, if you will); you can toggle the endianness from the lowest level. It just happens that iOS uses it as little endian. I seem to remember the baseband chip (which is also an ARM core, at least with the original iPhone -- never dealt with the others) being big endian, in fact. Sadly, you can't do this on a per-process level, IIRC, like you can with PowerPC (a huuuuge perk for emulators)." http://news.ycombinator.com/item?id=1527676 <comment170709> OSX on PowerPC is Big Endian, on Intel it is Little Endian.
The "python" CLI executable seems to ignore path hierarchy <body> I have the following strange situation on my (freshly installed El Capitan, otherwise empty) Mac.  I noticed that code/usr/bin/python/code defaults to python 2.7 (still), and the new SIP security system "protects" me from replacing it with a symlink to point to python3 (which I installed in code/usr/local/bin/code). I noticed that code/usr/local/bin/code shows up first on the path:  precode$ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin /code/pre  So I thought great, I'll just add a symlink in code/usr/local/bin/code called codepython/code and point it to python3.   precode$ ls -al /usr/local/bin ... lrwxr-xr-x   ... python -&gt; /usr/local/bin/python3 lrwxr-xr-x   ... python3 -&gt; ../Cellar/python3/3.5.0/bin/python3 /code/pre  And this is reflected by codewhich/code  precode$ which python /usr/local/bin/python /code/pre  But when I actually use it, it goes back to the native python2.7  precode$ python --version Python 2.7.10 /code/pre  What gives? Is OS X tinkering with my code$PATH/code and not telling me? What steps can I take to ensure I know what command is actually going to be run?  <answer213675> Try closing your terminal window, and making a new one. The shell only actually checks where commands are located on launch, and doesn't check again if it thinks it knows where the command is located. It's a performance boost in scripts, so generally a good idea.  <answer220574> If your shell is bash, then you can use the codetype/code and codehash/code builtins to manipulate its cache of executable paths (as shown in How do I clear Bash's cache of paths to executables?):  precode# to clear the whole cache hash -r  # to only remove one cached command hash -d python /code/pre  <comment257947> Is this specific to OS X? it's not like I changed the path or anything... <comment257948> No. Scripts would take much longer to run if it had to check where each command is located every single time a command is used, so it generally creates a list at runtime, then just reuses that list for any commands processed, unless it doesn't find something in the list, then it checks again. I don't believe there's a way to convince the shell that it's wrong, if it thinks it knows where Python is located, without restarting it. <comment266997> The caching is a property of  bash
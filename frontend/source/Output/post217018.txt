How to get user GUI input from BASH scripts? <body> From a BASH script I want to get user input and change system settings, in a loop.  I first tried cocoaDialog but that has a fatal flaw: the dialogs are always on top of other windows.  Ideally, I could throw up a dialog with "set sleep mode" and "set awake mode" (for toggling the "Prevent computer from sleeping automatically when the display is off" setting) buttons and the dialog/window would stay put when buttons are pressed.  In the case of cocoaDialog, I had to put up a new dialog each time a button was pressed.  It would have been fine, but aside from the above problem already mentioned, putting up a new dialog positions it in the middle of the screen and not where the old one was (and cocoaDialog doesn't have positioning arguments for dialogs).  Anyone know of a solution?  I suspect AppleScript would work, but it is so complex and I've not been able to find suitable examples I could copy/modify.  Thanks.  <answer217569> I've found two solutions.  The best one is second.  Solution #1: use Tcl/Tk:  precode#! /usr/bin/env wish8.5 # Adapted from brilliant example here: #   http://stackoverflow.com/questions/166231/tcl-tk-examples  package require Tk  proc main {} { if {[lsearch -exact [font names] TkDefaultFont] == -1} {     # older versions of Tk don't define this font, so pick something     # suitable     font create TkDefaultFont -family Helvetica -size 12 } # in 8.5 we can use {*} but this will work in earlier versions eval font create TkBoldFont [font actual TkDefaultFont] -weight bold  buildUI }  proc buildUI {} { frame .toolbar scrollbar .vsb -command [list .t yview] text .t \     -width 80 -height 10 \     -yscrollcommand [list .vsb set] \     -highlightthickness 0 .t tag configure command -font TkBoldFont .t tag configure error   -font TkDefaultFont -foreground firebrick .t tag configure output  -font TkDefaultFont -foreground black  grid .toolbar -sticky nsew grid .t .vsb  -sticky nsew grid rowconfigure . 1 -weight 1 grid columnconfigure . 0 -weight 1  set i 0 foreach {label command} {     awake     {prevent_computer_sleep}     sleep     {allow_computer_sleep}     status    {pmset -g | grep sleep} } {     button .b$i -text $label -command [list runCommand $command]     pack .b$i -in .toolbar -side left     incr i } }  proc output {type text} { .t configure -state normal .t insert end $text $type "\n" .t see end .t configure -state disabled }  proc runCommand {cmd} { output command $cmd set f [open "| $cmd" r] fconfigure $f -blocking false fileevent $f readable  [list handleFileEvent $f] }  proc closePipe {f} { # turn blocking on so we can catch any errors fconfigure $f -blocking true if {[catch {close $f} err]} {     output error $err } }  proc handleFileEvent {f} { set status [catch { gets $f line } result] if { $status != 0 } {     # unexpected error     output error $result     closePipe $f  } elseif { $result &gt;= 0 } {     # we got some output     output normal $line  } elseif { [eof $f] } {     # End of file     closePipe $f  } elseif { [fblocked $f] } {     # Read blocked, so do nothing } }  main /code/pre  where emprevent_computer_sleep/em just does codesudo pmset sleep 0/code and emallow_computer_sleep/em does codesudo pmset sleep 1/code.  Solution #2: modify KeepingYouAwake to use system sleep and not display sleep: my fork of KeepingYouAwake.  <comment262376> Check this post: http://stackoverflow.com/questions/8354482/dialog-from-bash-script <comment262431> @sdayal that post doesn't help.  I want something Mac friendly. <comment262689> Do you just want to toggle the Mac's sleep settings? I use Caffein by lighthead for that (available on the App Store). Beautiful little menu bar icon and you're all done <comment262981> @agentroadkill: Caffeine doesn't work for me because that just prevents the display from sleeping.
bash completion in terminal - files vs folders <body> I just recently started out with MacOS, but there one some strange completion behaviour with the codebash/code shell (compared to OpenSuse Linux with tcsh where I come from) that is bugging me:  For example, when I am in $HOME and write Pu on the command line, followed by tabbing for completion, I expected that one of the options shown would be my Public/ directory. However, as long as there are executable files, the completion never shows directories that share the same prefix. Only after entering Publ, the tab completion gives me Public/ as there are no more executables with that prefix.  So my question would be, is there an option to have the completion directly show executables and directories with the given prefix?  I already tried upgrading to bash 4 and installing bash-completion via homebrew but that did not help. I suspect that either the MacOS readline behaves differently or that there are some more setting for .inputrc which I do not know about.  I further know that by starting with ./ I only get directories. This is the bandaid that I use at the moment.  <answer199771> as far as I know, it's a feature, not a bug.   you could just change to codetcsh/code, here is a guide (eventually you have to install it via homebrew, then adapt the path)   <answer199785> Try it with  ./Pub[tab]  the ./ makes it the current directory to start the tab-completions from  (I'd like to know know how this isn't usefull, as it works that way on Linux too?)  <answer199851> For most shells with a file expansion function what is expanded in codeargv[0]/code position is an executable found within one of the directories of the PATH variable.  If you want to find directories when entered as 1st argument within codebash/code or codezsh/code, simply modify codePATH/code as follows:  precodePATH=${PATH}:. /code/pre  and test it with:  codePub/codekbdtab/kbd  For codetcsh/code the equivalent modification of PATH is obtained with:  precodesetenv PATH ${PATH}:. /code/pre  h2Warning/h2  To include code./code into the codePATH/code variable is a security risk. Since this modification any file in the directory where you are will be found as a standard command. This might lead you to execute files you would never had tried to execute otherwise: executables which will cause a core dump in a development directory, or binaries which will make you execute commands to get priviledged access to your system.  This risk is the same for any Unix like OS.  <comment240598> I guess it is because I already mentioned this option in my question. But it is a valid point and I should probably state this more clearly in my initial question. <comment240601> Thank you for the answer. I did not know that it was considered to be a feature - or at least one that cannot be disabled.  I might give `tcsh` another try, but I actually wanted to switch to something that is more widely used. <comment240602> Oh.. OK but you may try to set bash options (`shopt` shell options) to get that working.... <comment240654> Did you try pressing the `Tab` button twice? That will show a list of completions as far as I am aware. <comment240655> Yes, I did. I will add this to the initial question to clarify. <comment240678> On my Mac running Mavericks, `zsh` is behaving as you describe, but `bash` find directly directories and executables at first. Could you add within your question: which shell you are using, and the output of `ls -ld Pu*`? <comment240687> Thank you. I just checked on my old PC at University and there the default `PATH` actually contained the `.` - so that was the reason why the completion worked different there. But regarding your warning, I won't add it back and get used to using `./` if I want paths in my completion. Thank you. <comment240688> I specified that I used `bash` in the question. The output of the ls is just the `Public/` folder. The executables starting with `Pu` are in some directories of the `PATH`. You actually explained the behaviour nicely in your answer and I could verify it. <comment240689> Wise and secure move :).
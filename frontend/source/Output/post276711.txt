How to change volume of "say" in AppleScript? <body> Here is a line from my AppleScript that speaks the selected text:  precodeset this_say_Pid to do shell script "LANG=en_US.UTF-8 pbpaste -Prefer txt | say &gt; /dev/null 2&gt;&amp;1 &amp; echo $!" /code/pre  I would like the speaking volume to be much lower. I would prefer not to accomplish this by decreasing my overall system volume.  I can successfully decrease the volume of codesay/code in Terminal with the following code:  precodesay "[[volm 0.35]] This is a sentence" /code/pre  But, when I insert code[[volm 0.35]]/code in my codedo shell script/code string, the volume does not change.  <answer276712> Simply move the first double quote: code... "say [[volm 0.35]] This is a sentence"/code  In Terminal.app the quotes aren't required at all and codesay [[volm 0.35]] This is a sentence/code simply works.  hr  In your code line you would have to prepend code[[volm 0.35]]/code to the copied text.  In Terminal the following line would work:   precodecat &lt;(echo [[volm 0.35]] ) &lt;(LANG=en_US.UTF-8 pbpaste -Prefer txt) | say  /code/pre  but I don't get this to work in your AppleScript line properly - probably I have to escape one or several items.   <answer276715> Since you are empiping/em the output of the codepbpaste/code emcommand/em directly to codesay/code emcommand/em, then e.g. code[[volm 0.35]]/code would need to be a part of what's on the clipboard as e.g. code[[volm 0.35]]/code must precede the content of what was actually going to be said.  I'd try using the following in place of what you are using:  precodeset howLoudAndWhatToSay to "[[volm 0.35]] \"" &amp; (get the clipboard as string) &amp; "\""  set this_say_Pid to do shell script "say " &amp; howLoudAndWhatToSay &amp; " &gt; /dev/null 2&gt;&amp;1 &amp; echo $!" /code/pre  hr  strongUpdate:/strong If you want to stick with using codepbpaste/code, then this example command should work:  precodeset this_say_Pid to (do shell script "echo \"[[volm 0.35]] $(LANG=en_US.UTF-8 pbpaste -Prefer txt)\" | say &gt; /dev/null 2&gt;&amp;1 &amp; echo $!") /code/pre  Note the primary differences between the emcommand/em within the codedo shell script "..."/code emcommand/em in your question and my answer.  ul licodeecho \"[[volm 0.35]]/code is added in front of codeLANG=.../code and note the space after code]]/code./li liThe codeLANG=en_US.UTF-8 pbpaste -Prefer txt/code is now enclosed in code$(...)/code which is using Command Substitution to, in essence, concatenate what gets echoed to the empipe/em ahead of the codesay/code emcommand/em./li liAs well as a matching closing literal double-quote code\"/code, before the empipe/em to codesay/code,  to go with the one in codeecho \"[[volm 0.35]]/code.  It did work in limited testing without the use of the opening and closing double-quotes however it's probably better to encase it in the double-quotes to account for something the emshell/em might try to unnecessarily expand./li /ul  That said, on my system using code0.35/code for the value in code[[volm 0.35]]/code didn't work well in that is was difficult to perceive the difference in volume from my normal setting. However using code0.3/code in code[[volm 0.3]]/code the difference was notable. (This is one of the reasons why I used "e.g. code[[volm 0.35]]/code" in my opening sentence.)  <answer288234> simple answer:   precodesay "[[volm 0.04]] This is a sentence" /code/pre  Seems to me that from 0.01 to 0.04 is the smaller volume output.   When I tried 0.25 or 0.35 the volume did not change.   <comment348315> Sorry, I wasn't clear. I am trying to accomplish the volume change with AppleScript, not in Terminal directly. I don't know where `[[volm 0.35]]` belongs in the line of code that I provided. <comment348331> Some thoughts & observations... While `cat (echo [[volm 0.35]] ) (LANG=en_US.UTF-8 pbpaste -Prefer txt) | say`, as is, works okay in a `bash` _shell_, it doesn't work in a `sh` _shell_, which is what AppleScript uses. So I do not believe it has to do with escaping any part of that particular _command_. If you open Terminal, assuming it is the default _shell_, `bash`, and typed `sh` and press _enter_, then execute that same _command_, it errors out with `sh: syntax error near unexpected token \`('`, the same as in AppleScript. It looks like the `sh` _shell_ doesn't like Process Substitution. <comment348332> While one could preface that _command_ with `bash -c `, e.g. `set this_say_Pid to (do shell script "bash -c \"cat (echo [[volm 0.35]] ) (LANG=en_US.UTF-8 pbpaste -Prefer txt) | say  /dev/null 2&1 & echo $!\"")`, to actually run it in a `bash` _shell_, the `say` _command_ will then work properly but you will not get the `pid` of the `say` _command_, which of course then defeats the purpose. Hopefully rubik's sphere can use what I've suggested in my answer if there isn't another way to do it along the lines of your suggestion. <comment348358> Okay, I figured out a way around the issue the `sh` _shell_ was having with Process Substitution `(...)` and to offer a solution using `pbpaste` by using Command Substitution `$(...)` instead, as shown in my updated answer, which still includes my original answer as that shows another way to accomplish the same thing, albeit two lines of _code_ instead of one. :)
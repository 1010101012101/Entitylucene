Folder Action for automatic file name cleanup <body> I want to build a folder action that cleans up the filenames of my downloaded files.  For example bYoutube_MyVideofile_(1080p_30fps_H264-128kbit_AAC).mp4/b should be stripped by b"Youtube" "30fps" "128kbit" "AAC" "(" ")"/b and b"_"/b should be replaced to a "space". So the result would be bMyVideofile 1080p H264.mp4/b  I know I could do this with Automator but then I have to set up a "search/replace" element for every word. I'd rather use a single list of words which would be easier to maintain, because I have a lot of different sources where I get files from on regular bases, so the actual list of words to be removed will be very long and may be updated from time to time.  I found this Automator or AppleScript to Remove Multiple Strings from File Names? which is similar, but it only worked with selected folders. Instead I want to set it up so it works automatically as a folder action.  I guess therefore I also need a whitelist of file extensions that the script wont touch, such as ".download" for safari-downloads that are still in progress.  <answer292998> Using strongAutomator/strong, in macOS Sierra 10.12.5, I created a strongFolder Action/strong with a single strongRun AppleScript/strong emaction/em, using the strongAppleScript/strong emcode/em below, and set it to run on my strongDownloads/strong folder. (It has also been tested and works on OS X 10.8.5 and OSX 10.11.6.)  ol liOpen strongAutomator/strong and select strongFile/strong  strongNew/strong, then strongFolder Action/strong./li liAdd a strongRun AppleScript/strong emaction/em, replacing the default emcode/em with the emcode/em below./li liModify the codeset theBlackWhiteList to POSIX path of .../code line of emcode/em, accordingly as necessary./li liSet the strongFolder Action receives files and folders added to Choose folder/strong emlist box/em to your strongDownloads/strong folder./li liBefore saving the strongFolder Action/strong, create the emplain text data file/em that will be used by this strongFolder Action/strong.  ul liIt's not absolutely necessary to do it before, however, if you are going to save it in strongDownloads/strong, I would create the file first./li /ul/li liSave the strongAutomator Folder Action/strong emworkflow/em./li /ol  Read the emcomments/em, included with the emcode/em, for what's necessary to use this emcode/em in the strongFolder Action/strong.  To test the strongFolder Action/strong, open strongTerminal/strong and codecd Downloads/code, then create  the test file with,br codetouch 'Youtube_MyVideofile_(1080p_30fps_H264-128kbit_AAC).mp4'/code, which will create a zero length file that will be processed by the strongFolder Action/strong and be renamed to codeMyVideofile 1080p H264.mp4/code as shown in strongDownloads/strong in strongFinder/strong or strongTerminal/strong with: codels -l My*.mp4/code  AppleScript emcode/em:  precode--  #    --  #   The AppleScript code of this Folder Action requires a data file, which is laid out as follows: --  #    --  #   Lines 1 and 3 state what are on lines 2 and 4 respectively. (These lines are just reminders.) --  #    --  #   Line 2 must start with a single space character ' ', followed by the comma delimiter ','! --  #   Line 2 must also not contain an underscore character '_' as it's used as a 'text item delimiter', --  #   and all of them will be removed and replaced with a single space, as appropriate, in the last --  #   part of the processing to form the final filename. --  #    --  #       This is used as part of the overall logic applied to creating the finished filename, so as to --  #       only have a single space character between words of the filename, while ensuring the finished --  #       filename does not start with nor have directly before the filename extension, a space character.  --  #    --  #   Line 2 is a list of strings that will be removed from the filename. (The Black List.) --  #   Line 4 is a list of filename extensions of the file types that will be processed. (The White List.) --  #    --  #   Modify lines 2 and 4 as appropriate, while leaving the single space character at the start of line 2, --  #   and do not include an underscore character in Line 2. --  #    --  #   Example contents of the plain text data file: --  #     --  #   # Do Not Remove This Line!: The next line contains a comma-delimited list of strings to be removed: --  #    ,Youtube,30fps,128kbit,-,AAC,(,) --  #   # Do Not Remove This Line!: The next line contains a comma-delimited list of file extensions to process: --  #   mp4,mkv,avi,flv,flac  --  #   For the purposes of testing this script, the name of the data file used is  --  #   "FileNameExtensionBlackWhiteCleanupList.txt", and is in the User's Downloads folder. --  #   Obviously you can name it whatever you want and place it where appropriate access exists. --  #   Modify the 'set theBlackWhiteList to POSIX path of ...' line of code, accordingly as necessary.   on run {input, parameters}     try         set theBlackWhiteList to POSIX path of (path to downloads folder) &amp; "FileNameExtensionBlackWhiteCleanupList.txt"          --  #   Make sure the data file exists and set its contents to the target variables.          tell application "System Events"             if (exists file theBlackWhiteList) then                 tell current application                     set theBlackWhiteList to (read theBlackWhiteList)                     set AppleScript's text item delimiters to {","}                     set theStringsToRemoveList to text items of paragraph 2 of theBlackWhiteList as list                     set theFileExtensionsList to text items of paragraph 4 of theBlackWhiteList as list                     set AppleScript's text item delimiters to {}                 end tell             else                 tell current application                     activate                     display dialog "The required file, " &amp; quoted form of theBlackWhiteList &amp; ", is missing!" &amp; ¬                         linefeed &amp; linefeed &amp; "Replace the missing file from backup." buttons {"OK"} ¬                         default button 1 with title "File Not Found" with icon 0 -- (icon stop)                     return                 end tell             end if         end tell          --  # Process the target file(s) added to the target folder, that have the target filename extensions.           tell application "Finder"             set theFileList to input             repeat with thisFile in theFileList                 set theFileName to name of thisFile                 set theOriginalFileName to theFileName                 --  #   Get the filename extension of thisfile.                 set AppleScript's text item delimiters to {"."}                 set thisFileExtension to last text item of theFileName as string                 --  #   Only process if thisFileExtension is in theFileExtensionsList.                  if theFileExtensionsList contains thisFileExtension then                     repeat with i from 1 to count of theStringsToRemoveList                         set AppleScript's text item delimiters to item i of theStringsToRemoveList                         set theTextItems to text items of theFileName                         set AppleScript's text item delimiters to {"_"}                         set theFileName to theTextItems as string                         set AppleScript's text item delimiters to {}                     end repeat                     --  #                                            --  #   Using the example filename in the OP, 'Youtube_MyVideofile_(1080p_30fps_H264-128kbit_AAC).mp4',                     --  #   at this point in the processing it would be, '__MyVideofile__1080p___H264_____.mp4', and while one                      --  #   probably could continue to use AppleScript 'text items' and 'text item delimiters', nonetheless I can do                     --  #   it easier using 'sed' to finish getting the final filename. This is also part of the reason I started the                     --  #   'theStringsToRemoveList' with a single space character and do not allow an underscore character in Line 2.                     --  #                                            tell current application                         set theFileName to (do shell script "printf " &amp; quoted form of theFileName &amp; " | sed -E -e 's/[_]{2,}/_/g' -e 's/^_//' -e 's/_\\./\\./g' -e 's/_/ /g'")                     end tell                     --  #   Only change the filename if it has actually changed by the processing above.                     --  #   There's no sense in telling Finder to name a file the same name it already is.                      if theFileName is not equal to theOriginalFileName then                         try                             set the name of thisFile to theFileName                         end try                     end if                     --  #   At this point the final filename, using the example filename, would be 'MyVideofile 1080p H264.mp4'.                     --  #   This assumes this filename didn't already exist and why the 'do shell script' command is within a 'try'                     --  #   statement. Additional coding and logic could be applied to increment the filename if it already existed.                 end if             end repeat             set AppleScript's text item delimiters to {}         end tell      on error eStr number eNum         set AppleScript's text item delimiters to {}         display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with icon caution         return     end try end run /code/pre  Example contents of the emplain text data file/em used by the strongFolder Action/strong:  precode# Do Not Remove This Line!: The next line contains a comma-delimited list of strings to be removed:  ,Youtube,30fps,128kbit,-,AAC,(,) # Do Not Remove This Line!: The next line contains a comma-delimited list of file extensions to process: mp4,mkv,avi,flv,flac /code/pre  The emlogic/em behind the renaming process:  Using the emvariable/em codetheStringsToRemoveList/code, which starts with a single emspace/em character followed by the comma-delimiter, in conjunction with the emunderscore/em character as the codetext item delimiter/code, turns all spaces along with all other strings to be removed, into underscores during the AppleScript's codetext items/code and codetext items delimiters/code portion  of the emcode/em.   This is done so codesed/code can be used to replace all concurrent underscore characters with a single underscore character, then remove the leading  underscore, if it exists, followed by an underscore preceding the dot before the filename extension, if it exists, and finally all remaining single underscore characters are replaced with a single space character.  precodeset theFileName to (do shell script "printf " &amp; quoted form of theFileName &amp; " | sed -E -e 's/[_]{2,}/_/g' -e 's/^_//' -e 's/_\\./\\./g' -e 's/_/ /g'") /code/pre  ul licodeset theFileName to/code - The emvariable/em codetheFileName/code will contain the output of the codedo shell script/code emcommand/em./li licodedo shell script "_command_"/code - Runs the emcommand/em in a codeshell/code./li licodeprintf " &amp; quoted form of theFileName &amp; " |/code - Prints the emvalue/em of the emvariable/em codetheFileName/code, and pipes code|/code it to the codesed/code emcommand/em./li licodesed -E -e 's/[_]{2,}/_/g' -e 's/^_//' -e 's/_\\./\\./g' -e 's/_/ /g'/code/li licodesed/code - Stream EDitor./li licode-E/code - Interpret regular expressions as extended (modern) regular expressions rather than basic regular expressions (BRE’s). The re_format(7) manual page fully describes both formats./li licode-e command/code - Append the editing commands specified by the emcommand/em argument to the list of commands. /li licodes/[_]{2,}/_/g/code  ul licodes/code - Substitute pattern flag./li licode[_]{2,}/code - Match a single character present in the list, matches the character code_/code literally (case sensitive)./li licode{2,}/code - Quantifier — Matches between 2 and unlimited times, as many times as possible, giving back as needed (greedy)./li licode/_//code - Replaces matched pattern with a single character code_/code literally (case sensitive)./li licodeg/code - Global pattern flag codeg/code modifier, matches all occurrences of the pattern, (doesn't return after first match)./li /ul/li licodes/^_///code  ul licode^/code - Asserts position at start of the string./li licode_/code - Matches the character code_/code literally (case sensitive)./li licode///code - Replaces the matched pattern with literally nothing./li /ul/li licodes/_\\./\\./g/code  ul licode_/code - Matches the character code_/code literally (case sensitive)./li licode\\./code - Matches the character code./code literally (case sensitive)./li licode/\\.//code - Replaces the matched pattern with the character code./code literally (case sensitive).  ul liNote: The double back-slash code\\/code is necessary when use in a codedo shell script/code emcommand/em, however, from the command line a single back-slash code\/code would be used to make the character that follows a literal code./code character, in this case./li /ul/li /ul/li licodes/_/ /g/code  ul liReplaces the character code_/code literally, with a character code/code literally (case sensitive)./li /ul/li /ul  Note that the info above is abbreviated in places, however, it should provide a bit of an understanding of what's happening.  On a added note, if you want to also ensure capitalization of each word in the filename, then replace the existing codedo shell script/code emcommand/em with the codedo shell script/code emcommand/em below, which has an added codeawk/code emcommand/em that receives the output from codesed/code to preform the capitalization. Note that I found this codeawk/code emcommand/em on the Internet and tested it that it works, however, will not be adding an explanation of how it functions for lack of time.   precodeset theFileName to (do shell script "printf " &amp; quoted form of theFileName &amp; " | sed -E -e 's/[_]{2,}/_/g' -e 's/^_//' -e 's/_\\./\\./g' -e 's/_/ /g' | awk '{for(i=1;i&lt;=NF;i++){ $i=toupper(substr($i,1,1)) substr($i,2) }}1'") /code/pre  hr  h1Update to address code./code's in the filename, per the comments./h1  In the plain text data file, on Line 2, add a code.,/code after the leading space and its comma-delimiter. In other words, the first item in the list on Line 2 is a blank space followed by a comma-delimiter followed by code./code followed by a comma-delimiter and so on.  Add the following lines of emcode/em after the coderepeat/code emloop/em that directly before the comment starting with code--  #   Using the example filename in the OP. .../code which is above the codetell current application/code ... codedo shell script/code block of emcode/em.  precode            set AppleScript's text item delimiters to {"_" &amp; thisFileExtension}             set theTextItems to text items of theFileName             set AppleScript's text item delimiters to {"_"}             set theFileName to (theTextItems as string) &amp; "." &amp; thisFileExtension             set AppleScript's text item delimiters to {}     /code/pre  By adding the code.,/code to line 2 in the plain text data file, all code./code in the filename are replaced with code_/code in the original emcode/em. Then with the extra lines of emcode/em above, it replaces e.g. code_mp4/code with code.mp4/code, or code./code and whatever the actual filename extension is.  Now when it gets to the codedo shell script/code emcommand/em there is only the code./code for the filename extension and all the underscores are process out of the name as they should.  Obviously the way the original emcode/em is coded, underscores cannot be a part of the final filename, and this modification to the original emcode/em doesn't change that.  <comment368152> Please provide and actual sampling of real filenames of both the before and after of what you want, and edit it into the question. <comment369613> What version of OS X/macOS are you running? <comment369747> I'm on the latest version of El Capitan. <comment369748> Wow. Huge thanks for your effort! I'll try it later! <comment369750> Okay, I just tested it under OS X 10.11.6 and works as expected. <comment370364> I tested it and your script works absolutely flawless! Also I'm absolutely blown away by your explanation. this is perfect for me to alter the script even further for my needs, as they might change. There is only one thing that would make it perfect:If it would also work with subfolders. Can you help one more time? huge thanks!!! <comment370365> using your description I tried to replace "." with spaces by altering your code to `tell current application       set theFileName to (do shell script "printf " & quoted form of theFileName & " | sed -E -e 's/[_]{2,}/_/g' -e 's/^_//' -e 's/_\\./\\./g' -e 's/_/ /g' -e 's/\\./ /g'")      end tell`  but it also affects the file extention and removes the "." from it and therefore the file wont be recognised properly. anyway to protect the extention from the renaming process? <comment370377> @Maximilian Becker, This new scenario is exactly why I asked in the first comment to your question "**Please provide and actual sampling of real filenames of both the before and after of what you want**" and you only gave one pseudo filename example! Had I known there were going to be more `.`'s then for the filename extension, I would have coded this differently. I'll add a section at the very end of the original answer to handle the `.`'s in the filename. Do not modify the `sed` _command_, I'll add code to handle this before the `do shell script` _command_. <comment370379> @Maximilian Becker, I've added an update to address `.`'s in filenames.
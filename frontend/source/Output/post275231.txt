Using regex in Mac OS X: why I have to add \ in {3, 5} ==> \{3, 5\} ...? <body> I am trying to find all files with no-extension in a particular folder, and after many attempts I finally came up with this regex statement:     codels | grep "\.[A-Za-z]\{3,5\}$"/code   Why I have to start the occurrences around the {} with \, like escaping the sequence? Is there a way to use standard regex like this?     codels | grep "\.[A-Za-z]{3,5}$"/code   I want, ultimately to get the opposite list of files with no-extension, but this non standard regex is making it hard for me to negate the result from the grep.  <answer275234> If I understand your question correctly, you do not need to emescape/em the emcurly-braces/em with a embackslash/em if you emform/em the emcommand/em properly.  In other words, when using a emRegRx/em with codegrep/code, let it know the emsearch pattern/em is a emRegEx/em by using the code-E/code emoption/em.  If you want an eminverse match/em then use the code-v/code emoption/em as well.  Example:  precodels | grep -E -v '\.[A-Za-z]{0,5}$' /code/pre  ul liNote I used code{0,5}$/code instead of code{3,5}$/code to account for any extension up to 5 characters. If you want to include files that might have a 1 or 2 character extensions, then use code{3,5}$/code instead./li /ul  You can also use the following example:  precodels | grep -E -v '\.[[:alpha:]]{0,5}$' /code/pre  Sometimes a file extension can have numbers in them, so to account for that, use as an example:  precodels | grep -E -v '\.[A-Za-z0-9]{0,5}$' /code/pre  Or:  precodels | grep -E -v '\.[[:alnum:]]{0,5}$' /code/pre  strongNote:/strong Some commands require the emoptions/em to be passed individually, while others can be combined. In this case, codegrep/code does allow emoptions/em to be concatenated. So in the example emcommands/em, code-E -v/code can be expressed as code-Ev/code or code-vE/code, if you wish.  <answer275253> If your shell is ksh then you could list files in the current directory without an extension like this:  precodeprintf '%s\n' !(*.*) /code/pre  Bash supports ksh extended globs when you enable them:  precodeshopt -s extglob printf '%s\n' !(*.*) /code/pre  <comment346282> **Thanks! it works** <comment346283> **Thanks for this trick**
How to replace a folder that's name is a date i.e. YYYYMMDD with folder hierarchy of year, month, date? <body> I have a list of folders which have dates for names. The dates are in the format YYYYMMDD (e.g. 20150129). Within these folders are text documents which are related to that specific date.  I would like to restructure them in a folder hierarchy going from year to month to date, and to move the text documents into the corresponding 'date' folder lower down in the hierarchy.  In other words I would like the 'root' folder to be named after the year like 2015, and then create sub-folders named with months like 01, and then create further sub-folders named with dates like 29 which hold the corresponding text documents.  So the path would look like code2015/01/29/file.txt/code or code2015&gt;01&gt;29&gt;file.txt/code.  I have taken a look at Automator and it seems that something like this is not possible although I could be wrong, so I would like to know...  ol liIs there some easy solution to this problem that any layman can understand, for example an Automator workflow, or does this require some understanding of terminal commands and regular expressions?/li liHow would one solve this problem provided there is in fact a solution?/li /ol  <answer282276> You can use the following in Terminal. codecd/code to the containing folder, then run the following:  precodefind . -type f -exec bash -c \   'F=$(sed -E "s#^\./([0-9]{4})([0-9]{2})([0-9]{2})#\1/\2/\3#" &lt;&lt;&lt; $1);\   mkdir -p -- $(dirname "$F");\   mv -- "$1" "$F"' - {} \; /code/pre  codefind . -type f/code obtains every file in the current directory recursively.br code-exec bash -c/code opens a shell to run the following commands.br codeF=$(…)/code opens a subshell and uses sed on the file path to manipulate the path into the folders.br code^\./([0-9]{4})([0-9]{2})([0-9]{2})/code is a regex with three capture groups, as follows: img src="https://i.stack.imgur.com/huN92.png" alt=""br code\1/\2/\3/code is replacement, where each capture group (code\1/code, etc) are separated by code//code.br codemkdir -p -- $(dirname "$F")/code creates the directories to move the files into.br codemv -- "$1" "$F"/code moves each file into its corresponding folder.  This takes the hierarchy on the left and converts it to the hierarchy on the right:  img src="https://i.stack.imgur.com/PP6hg.png" width="192" img src="https://i.stack.imgur.com/mUHka.png" width="192"  precode├── 20170201               └── 2017 │   └── abcdefghij             ├── 02 └── 20170302                   │   └── 01     └── abcdefghij 2           │       └── abcdefghij                                └── 03                                    └── 02                                        └── abcdefghij 2 /code/pre  If there are other files in the containing folder with a date as a name, they will be moved as if they are a folder. To prevent this, replace the second line with:  precode  'F=$(sed -E "s#^\./([0-9]{4})([0-9]{2})([0-9]{2})(?:/.+)#\1/\2/\3#" &lt;&lt;&lt; $1);\ /code/pre  The code(?:/.+)/code ensures that the path has a subsequent component, therefore ignoring anything without a child in the parent directory which are files.  <answer282282> Assuming all these YYYYMMDD folders are part of the same parent directory you could run  precodecd PARENT_DIRECTORY for d in */; do     [[ $d =~ [0-9]{8}/ ]] || continue     mkdir -p -- "${d:0:4}/${d:4:2}"     mv -- "$d" "${d:0:4}/${d:4:2}/${d:6:2}" done /code/pre  ul liThe codefor d in */; do/code loop reads all directory entries, the trailing code//code ensures that only directory names actually match/li licode[[ $d =~ [0-9]{8}/ ]]/code tests whether the current entry consists of 8 digits, and continues with the next entry if not/li licode${d:0:4}/${d:4:2}/${d:6:2}/code uses parameter expansion within codebash/code to create a string containing the new path/li liThe code--/code in both codemkdir/code and codemv/code prevents problem in case the directory or file name starts with a code-/code. This can't happen here but it's probably good practice anyway./li /ul  hr  Thanks to @terdon and @user3439894 for ideas on how to improve the original script.  <comment355436> To whomever voted to close this question as "too broad", why? I'm curious as to what's "too broad" about this question? <comment355440> Are these YYYYMMDD folders all directly inside one master folder or are they spread out across a broader hierarchy? <comment355552> @patrix In my case they are all in the same directory or master folder <comment355600> Thanks for the answer, this works perfectly! I feel this solution is better than the one provided by @grgarside because it's far quicker, especially when dealing with a massive corpus including thousands of text documents. <comment355601> Thanks for the answer, this solution worked perfectly! <comment355604> @klanomath [regex101.com](https://regex101.com) <comment355605> @grgarside Thanx
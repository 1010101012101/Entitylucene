piping find to head <body> I have a script to read the first line of any text file with a certain extension within a certain folder, recursively, but it doesn't work. The head command is non-functional.  precode#!/bin/bash while true; do (find ~/SpaceMonkey/MATLAB/Luo-Rudy -name '*.m') | head â€“n 1 &gt; /dev/null sleep 300 done /code/pre  What am I doing wrong here?  <answer122321> There's a few problems with your script.  First, you're sending the final output from codehead/code to code/dev/null/code, so you won't see anything from head at all.  Second, you're not actually opening the files, you're just passing the emlist of files/em found by codefind/code into codehead/code, so even if you remove the code&gt; /dev/null/code you'll just see the name of the first file. If codehead/code reads from stdin, it treats stdin as the 'file', not as a list of files to process.  Instead, you'll want to do something more like this:  precode#!/bin/sh DIR="$HOME/SpaceMonkey/MATLAB/Luo-Rudy" while true do     for filename in $(find $DIR -name '*.m')     do         head -n 1 $filename         # or if you want the filename listed too:         #echo "$filename $(head -n 1 $filename)"     done     sleep 300 done /code/pre  Note also that if you used the codezsh/code shell, you could achieve this more simply:  precodehead -n 1 $DIR/**/*.m /code/pre  The codezsh/code shell (and some others) allows recursive file globbing, to let you pass all code.m/code files (recursively) to codehead/code as command line arguments in one go.  <answer122324> The easiest way to do what you intend is to use codefind/code to run codehead/code for you.  Replace your existing find line with :  precodefind ~/SpaceMonkey/MATLAB/Luo-Rudy -name '*.m' -exec head -n 1 '{}' \; /code/pre  This will run codehead/code to get the first line on every matching file. You can redirect the output by simply adding code&gt; destination/code to the end of the command.  <comment142738> What is the purpose of the string with brackets and the escaped line end? Just curious, since it works. <comment142739> Thanks for the explanation and the zsh one-liner. I have zsh on all my machines, but I tend to use bash for scripting. I know bash is a less sane scripting language, but everyone has it. Both solutions are good, but the bash one-liner in the other answer is more immediately applicable, so I'm selecting that. The zsh feature is really cool though. <comment142741> The brackets are replaced with the name of the matched file and the semi-colon tells exec where the command ends. The quotes and backslash are to "protect" them from the shell.A 'man find' from the command line reveals much - particularly the EXAMPLES section. <comment142744> Excellent. I figured that was the case for the escaped semicolon, but was stumped about the brackets. I found the answer in the ACTIONS section of the man file after you told me, but that man file is a beast. find seems like a pretty powerful command.
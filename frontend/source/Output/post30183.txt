Is there any way for me to use the original Mac Plus or Mac 128k mouse with a modern Macbook Pro? <body> I gather the original Macs used a serial port for the mouse with a RS-422 DE-9 connector. Totally nonstandard today. But surely, at some point some company (Apple?) must have made an adapter to use the early mice with USB-based Macs?  Thanks for any info...  <answer30199> Normally it's an issue of drivers over converters. A quick search will present a plethora serial-to-USB converters for purchase. I simply wouldn't hold my breath on the system recognizing the input device.  <answer30203> As far as I know, the old mac mice used a DE-9 connector, but this isn't RS-232-compatible. If it was, you could have used an adaptor from RS-232 to PS/2 and then a standard ps/2-usb-converter (both must be active converters).  If you get an ADB-mouse you will be able to use them as there are adaptors for these.  If you're into electronics and programming, you could build your own converter eg. using a teensy-board for few bucks. It shouldn't be too hard as the old apple mouse just sends quadrature signals which should easily be translated into pointer movements.  <answer30220> Yes.  You will need a micro controller chip with both 5 digital I/O pins and a USB interface that can masquerade as an USB HID device.  The Mac 128k mouse DE-9 connector has output pins for 2 XY quadrature encoders and the mouse button.  Some micro-controller programming may be required.  <answer276441> Ancient thread - but I was searching for the same thought  It's possible to use an arduino/teensy with HID capability to covert the quadrature to be used on a USB device.  The DE9 pinout (with arduino pins for code below) is:  precodeDB9     Pro Micro     1       GND     2       VCC     3       GND     4       D0      (pin 3)     5       D1      (pin 2)     6       -       (not connected)     7       B3      (pin 14)     8       D3      (pin TXO)     9       D2      (pin RXI) /code/pre  And some sample code originally from GuilleAcoustic and modified by Johan Berglund:  precode/* ================================================================================    Author  : GuilleAcoustic    Date    : 2015-05-22    Revision: V1.0    Purpose : Opto-mechanical trackball firmware    --------------------------------------------------------------------------------    Wiring informations: Sparkfun Pro micro (Atmega32u4)    --------------------------------------------------------------------------------      - Red    : Gnd                          |   Pin: Gnd      - Orange : Vcc (+5V)                    |   Pin: Vcc      - Yellow : X axis encoder / channel A   |   Pin: PD3 - (INT0)      - Green  : X axis encoder / channel B   |   Pin: PD2 - (INT1)      - Blue   : Y axis encoder / channel A   |   Pin: PD0 - (INT2)      - Violet : Y axis encoder / channel B   |   Pin: PD1 - (INT3)      - Grey   : Switch 1                     |   Pin: PB3      - White  : Switch 2                     |   Pin: PB2      - Black  : Switch 3                     |   Pin: PB1     --------------------------------------------------------------------------------    Modified for use with Apple M0100 mouse    By Johan Berglund, 2015-08-10     Changes in code:    - Internal pullup set for pin 14 (B3)    - State check for right and middle buttons commented out     Connection to DB9:     DB9     Pro Micro     1       GND     2       VCC     3       GND     4       D0      (pin 3)     5       D1      (pin 2)     6       -       (not connected)     7       B3      (pin 14)     8       D3      (pin TXO)     9       D2      (pin RXI)     ================================================================================ */  // ================================================================================= // Type definition // ================================================================================= typedef struct {   int8_t  coordinate = 0;   uint8_t index      = 0; } ENCODER_;  // ================================================================================= // Constant definition // ================================================================================= const int8_t lookupTable[] = {0, 1, -1, 0, -1, 0, 0, 1, 1, 0, 0, -1, 0, -1,  1,  0};  // ================================================================================= // Volatile variables // ================================================================================= volatile ENCODER_ xAxis; volatile ENCODER_ yAxis;  // ================================================================================= // Setup function // ================================================================================= void setup() {    // Set pull-up for mouse switch on M0100   pinMode(14, INPUT_PULLUP);    // Attach interruption to encoders channels   attachInterrupt(0, ISR_HANDLER_X, CHANGE);   attachInterrupt(1, ISR_HANDLER_X, CHANGE);   attachInterrupt(2, ISR_HANDLER_Y, CHANGE);   attachInterrupt(3, ISR_HANDLER_Y, CHANGE);    // Start the mouse function   Mouse.begin(); }  // ================================================================================= // Main program loop // ================================================================================= void loop() {   // Update mouse coordinates   if (xAxis.coordinate != 0 || yAxis.coordinate != 0)   {     Mouse.move(xAxis.coordinate, yAxis.coordinate);     xAxis.coordinate = 0;     yAxis.coordinate = 0;   }    // Update buttons state   !(PINB &amp; 0b1000) ? Mouse.press(MOUSE_LEFT)   : Mouse.release(MOUSE_LEFT);   // !(PINB &amp; 0b0100) ? Mouse.press(MOUSE_RIGHT)  : Mouse.release(MOUSE_RIGHT);   // !(PINB &amp; 0b0010) ? Mouse.press(MOUSE_MIDDLE) : Mouse.release(MOUSE_MIDDLE);     // Wait a little before next update   delay(10); }  // ================================================================================= // Interrupt handlers // ================================================================================= void ISR_HANDLER_X() {   // Build the LUT index from previous and new data   xAxis.index       = (xAxis.index &lt;&lt; 2) | ((PIND &amp; 0b0011) &gt;&gt; 0);   xAxis.coordinate += lookupTable[xAxis.index &amp; 0b1111]; }  void ISR_HANDLER_Y() {   // Build the LUT index from previous and new data   yAxis.index       = (yAxis.index &lt;&lt; 2) | ((PIND &amp; 0b1100) &gt;&gt; 2);   yAxis.coordinate += lookupTable[yAxis.index &amp; 0b1111]; } /code/pre  Original from: https://geekhack.org/index.php?topic=74340.0  <comment34642> Old apple mice use DE-9 connectors but not RS-232-protocol. <comment34685> You could probably use the guts of a cheap USB ball (non-optical) mouse as a converter - just feed the quadrature signals from the Apple mouse to its decoders, tap its 5V power to run the Apple mouse, and you're set.  Only problem I see is that the Apple mouse has TTL logic level outputs, and the USB mouse electronics might not cope with that. <comment347938> Welcome to Ask Different and thank you for your answer - it's a good find! :) Unfortunately, short answers such as this don't really provide enough detail or context to help many users. And, just providing a link isn't very helpful as it may no longer work in future. Instead, could you please edit your answer (there's an _edit_ link below it) to include a summary of the content you're linking to? This will help preserve your answer for other users who may benefit in future.
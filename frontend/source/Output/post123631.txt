Why Does a Shell Script Trapping SIGTERM Work When Run Manually, But Not When Run via launchd? <body> Okay, quite simply I have a shell script that needs to wait for something to happen, but it has a lock-file and some child-processes that I need to ensure are tidied up if the script is interrupted.  I've achieved this without issue by using the codetrap/code command to set some appropriate actions, and have come up with a script that looks a bit like this:  precode#!/bin/sh LOG="$0.log"  # Create a lock-file to prevent simultaneous access lockfile -l 86400 "$LOG.lock" || $(echo 'Locking failed' &gt;&amp;2 &amp;&amp; exit 3)  # Create trap for interrupt and cleanup on_complete() {     echo $(date +%R)' Ended.' &gt;&gt; "$LOG"     kill $(jobs -p)     rm -f "$LOG.lock"     exit } trap 'on_complete 2&gt; /dev/null' SIGTERM SIGINT SIGHUP EXIT  # Do nothing echo $(date +%R)' Running…' &gt;&gt; "$LOG" sleep 86400 &amp; while wait; do sleep 86400 &amp;; done /code/pre  This can be run just fine in a terminal via codesh Example.sh/code, and terminating it with codeCtrl + C/code, causing it to remove its lock-file without any fuss.  I then tried creating a codelaunchd/code job for this script like so:  precode&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt;     &lt;key&gt;Label&lt;/key&gt;     &lt;string&gt;org.example&lt;/string&gt;     &lt;key&gt;ProgramArguments&lt;/key&gt;     &lt;array&gt;         &lt;string&gt;sh&lt;/string&gt;         &lt;string&gt;~/Downloads/Example.sh&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;RunAtLoad&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;EnableGlobbing&lt;/key&gt;     &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; /code/pre  Creating Example.sh and Example.plist from the above in the code~/Downloads/code folder allows me to run the codelaunchd/code job via codelaunchd load ~/Downloads/Example.plist/code and end it via codelaunchd unload ~/Downloads/Example.plist/code. However, ending the job doesn't cause a codeSIGTERM/code to reach the script, which is instead codeSIGKILL/code'd after the 20 second timeout.  So what I'd like to know is; why isn't my script receiving codeSIGTERM/code, and how I can ensure it does?  <answer126066> The ultimate problem here is that Bash does not normally kill its non-builtin children.  precodeIf bash is waiting for a command to complete and receives a signal for which a trap has been set, the trap will not be executed until the command completes. When bash is waiting for an asynchronous command  via  the  wait  builtin, the reception of a signal for which a trap has been set will cause the wait builtin to return immediately with an exit status greater than 128, immediately after which  the trap is executed. /code/pre  When you hit code&lt;CTRL&gt;+&lt;C&gt;/code you're killing the shell script, which behaves normally -- but the sleep lives on. Use codeps/code to see.  When try to stop things externally, via codekill/code, then Bash as above. After some time-out period (I'm guessing 20 seconds) codelaunchd/code then issues a codekill -9/code which the script cannot trap.  The solution is to issue a wait after the sleep, to indicate to Bash that it can interrupt itself:  precodesleep 86400 &amp; wait /code/pre  This will allow the script to be interrupted, but the sleep will still survive. I'm sure there's a way to kill the children, but I didn't bother looking it up...  <answer126309> Realizing you've just shared with us a essentially a code fragment and it's not clear what more you're daemon is looking to actually achieve other than to perform some action every so many seconds. So I'm going to make some assumptions just based on what you've written.   ol liIt seems like you're using the lockfile to prevent duplicate launch./li liIt then seems that you need the trap to clean up the lock file used to implement your test to assure singularity. /li liAdditionally it appears that your deamon is doing a sleep loop to wake periodically and perform some action. (Just sleep more, in your example.)/li /ol  These are all issues that launchd is meant to resolve in better ways under Darwin (and hence OS X).  As for the question(s) with the unload and SIGTERM, specifically, when you codeunload/code your launchdeamon is sent a SIGKILL instead of a SIGTERM. If you just wanted to stop the job or send it a SIGTERM then use codestop/code instead of codeunload/code.   If you want a SIGTERM sent on codeunload/code you may need to set codeEnableTransactions/code. Likewise if you have cleanup tasks and you want your deamon to received signals for cleanup and SIGTERM then you should set codeEnableTransactions/code as part of the launchd plist for your script. code&lt;key&gt;EnableTransactions&lt;/key&gt;&lt;true/&gt;/code. This is described in the docs at https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man5/launchd.plist.5.html  But the three mechanisms above are unnecessary given launchd...  Under Darwin / OS X using launchdaemons the appropriate method for implementing a sleep loop daemon is to use  codeStartInterval/code to run on an interval or codeStartCalendarInterval/code to run based at specific times. Using codeStartCalendarInterval/code additionally gives the advantage that when the system is asleep it will execute a missed interval time instead of having to wait for the next interval, and is generally what you want in these situations. If you have a job you just want to stay invoked, also consider using codeKeepAlive/code as part of the plist.   So it looks like -- from the code sample you've provided -- you just want to execute something every 86400 seconds. If this is the case then launchd has a mechanism for doing this that you should be using instead and obviates the need for your lock file and trap altogether as launchd is designed to handle all this for you automagically. That mechanism is codeStartInterval/code and when defined it will launch your deamon every N seconds. Launchd also makes sure it hasn't launched multiple copies of your daemon.    This mechanism is described in the launchd docs at https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man5/launchd.plist.5.html where it states:  precodeStartInterval &lt;integer&gt; This optional key causes the job to be started every N seconds.  If the system is asleep, the job will be started the next time the computer wakes up.  If multiple intervals transpire before the computer is woken, those events will be coalesced  into one event upon wake from sleep. /code/pre  So your Darwin-ized script code~/Downloads/Example.sh/code would look something very simply now like this:  precode#!/bin/sh echo $(date +%R)' Running…' # or whatever it is you wanted to do on the interval /code/pre  And your plist would look something like this:  precode&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt;     &lt;key&gt;Label&lt;/key&gt;     &lt;string&gt;org.example&lt;/string&gt;     &lt;key&gt;ProgramArguments&lt;/key&gt;     &lt;array&gt;         &lt;string&gt;sh&lt;/string&gt;         &lt;string&gt;~/Downloads/Example.sh&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;EnableGlobbing&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;StartInterval&lt;/key&gt;     &lt;integer&gt;86400&lt;/integer&gt;     &lt;key&gt;StandardOutPath&lt;/key&gt;     &lt;string&gt;/mypathtolog/myjob.log&lt;/string&gt;     &lt;key&gt;StandardErrorPath&lt;/key&gt;     &lt;string&gt;/mypathtolog/myjob.log&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt; /code/pre  Note I've also adjusted this to set the logging files here in a Darwin/launchd like manner rather than in the script itself. (You could of course remove them and handle them in your script but it's not necessary given launchd.)  I'd note that you could also implement this using codeProgram/code like so:  precode&lt;key&gt;Program&lt;/key&gt; &lt;string&gt;sh&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt;     &lt;string&gt;~/Downloads/Example.sh&lt;/string&gt; &lt;/array&gt; /code/pre  You may also find http://launchd.info a useful reference as well along with the Apple docs for how launchd operates at https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html  Information about daemons run periodically can be found at  https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/ScheduledJobs.html#//apple_ref/doc/uid/10000172i-CH1-SW2  <comment147586> Does this behaviour continue if you remove 'sh' and call the script directly? I am assuming the script has its executable flag set. <comment147649> Rather than 'launchd unload', have you tried 'launchctl stop ~/Downloads/Example.plist'? <comment147705> Thanks for the explanation, but use of `wait` doesn't help (it's what I'm doing in the actual script I'm trying to debug, I've tweaked the example to match a bit more closely), so I'm not sure what's going on. <comment148001> Sorry, I should have said that actually my script is waiting for logout/shutdown, which is when `launchd` will send `SIGINT` to all running agents (or rather, should). `EnableTransactions` true won't work as shell scripts can't call the vproc commands, and set to false is supposed to be the default. I've tried including it as false to be sure but it doesn't seem to help. <comment148111> OK, that's a completely different situation than what your script was apparently trying to do, and one in which the solution you've crafted is a complex solution to a trivial non-problem. There's a completely better way to await for logout and shutdown in OS X.   Also ``EnableTransactions`` works for signals accordingly regardless if the process is actually using vproc or not, that documentation commentary is basically for actual applications, but it's functionally the same regardless. <comment148112> Sorry, that saved before I was finished. <comment148113> You can create a LaunchAgent await for logout or use a logouthook (``sudo defaults write com.apple.loginwindow LogoutHook /Users/Shared/logoutHook.sh``). <comment148459> Does the logout hook require sudo or can it be done per-user? Correct way to watch for logout or not, I'm still at a loss as to why I'm not getting `SIGINT` in my script as-is; were you able to reproduce the issue by running the example code I've provided? Neither setting for `EnableTransactions` seems to make a difference for me. <comment149975> Also, the Apple developer documentation actually discourages the use of login/logout hooks. So as far as I can tell using a sleeping script is in fact the "correct" way to do this for a launch agent, plus there are other cases such as long running jobs where capturing `SIGINT` is still important. <comment178259> Turn out that as of Yosemite this is now the correct answer; a launch agent or launch daemon that is sleeping (asynchronously) with a suitable trap (must be `SIGINT`, not `INT`) will receive the signal prior to being unloaded. Of course this is no good for Mavericks, Mountain Lion etc., but it's great that this finally works as it should, so I'm marking this is the correct answer, but it might be worth editing in that it only works correctly under 10.10.
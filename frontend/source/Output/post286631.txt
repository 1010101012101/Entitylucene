Mac OS UI Slow Response <body> I am new to Mac so forgive the naive question. I have used Windows &amp; Linux for a long time in the past and no matter how slow the system becomes (this actually applies almost only to Windows), the UI is usually snappy if the system is not busy executing multiple background tasks. For example, if I click on a Window or hit Alt-Tab, the switch is almost immediate (unless of course, the application executes some tasks when its window is activated). However, this is not the case with my Mac and a simple click on even the Finder window takes between 500ms to 1000ms to take effect. This is always the case no matter how busy or free my Mac is. Even though it is relatively old (Early 2015), the hardware is quite powerful:  precodeMacBook Pro (Retina, 13-inch) Processor 3.1 GHz Intel Core i7 Memory 16 GB 1867 DDR3 Graphics Intel Iris Graphics 6100 1536 MB /code/pre  In comparison, my Ubuntu laptop (System 76) is about 3-4 years old, but it is much faster and I rarely feel I have to wait for a second or so before it switches application!  Has this always been the case with Mac, or there is something to configure on my machine?  <answer286633> The best way (in my opinion) is to launch an application called codeActivity Monitor/code. You can do so by using spotlight (the magnifying class in the upper right hand corner), or by pressing codeCommand+Space/code at the same time. Just type "Activity Monitor" and an option should pop up. This lets you see the CPU usage by process, as well at RAM being utilized, and a lot of other good metrics. This should help you get a good idea of what might be slowing down your machine.  <answer286635> Yep, certainly not normal. In my experience Macs are emalmost always/em more responsive than Windows PCs under nearly any load as long as memory (RAM) isn't full.  Macs also don't go on "disk rampages" like PCs tend to, which always hits the PC with a load of latency every time it goes into a fit of disk access, so overall responsiveness should be much superior.  <comment361701> Did you buy it new or used? I have a similar model, and don't have any such issues. It's possible there's a hardware problem which Apple will help you with, assuming it's under warranty. <comment361702> One thing I've noticed on my MBP which I put to sleep all the time is the power daemon often smashes the CPU after waking up. I don't know why, but sometimes it'll just hold the CPU at around 50%. Killing it doesn't have any ill effects and gets my machine responding properly again. <comment361706> This is nonsense. Both are as responsive under similar loads and both will thrash when RAM gets full. <comment361719> The behavior isn't *exactly* the same, @isanae. Windows has a very different virtual memory subsystem than macOS does, and there is naturally a difference in how they perform under conditions of high memory stress. To be fair, though, comparing "Macs" to "PCs" is certainly nonsense. Even if you take "PC" to mean "Intel x86-based machine that doesn't run macOS", which itself is dubious, macOS is fundamentally based on BSD, and there's no reason why a BSD-based PC would show markedly different behavior. <comment361720> @CodyGray I didn't say they were _exactly_ the same, nor did I imply that NT, macOS or BSD were similar in architecture. I'm not sure why you're replying to me. <comment361880> @MattLacey huh, that's interesting. I've never heard of that happening before. Have you tried anything like doing a fresh install? <comment362034> It is a new actually, I opened it myself. But it is a work laptop, so I cannot just take it to Apple myself. <comment362035> What I would like to say, though, is that after restarting my Mac, it is now faster. But I hope this doesn't' mean I have to restart my machine every now and then :-S <comment362036> I actually restarted my machine and it is better now, but I doubt it is about CPU/RAM consumption because my Mac was quite with not many applications running. <comment362316> @Rafid yes, sometimes though a process goes rogue even if applications aren't running. It's a good way to catch a program that is being buggy.
How to use the flag -p of BSD split? <body> Manual  precode-p pattern          The file is split whenever an input line matches pattern,          which is interpreted as an extended regular expression.  The          matching line will be the first line of the next output file.          This option is incompatible with the -b and -l options. /code/pre  Code  precodeseq -w 1 1 10 | gsed ':a;N;$!ba;s/\n//g' | split -p '060' /code/pre  which makes a sequence from 1 to 10, removes empty lines to have a megastring and then splits at code060/code into two files unsuccessfully giving codesplit: invalid option -- 'p'/code.   Command codeseq -w 1 1 10 | awk -F'060' '{print "field1: "$1 "\nfield2: 060"$2}'/code in comment gives      field1: 01 field2: 060 field1: 02 field2: 060 field1: 03 field2: 060 field1: 04 field2: 060 field1: 05 field2: 060 field1: 06 field2: 060 field1: 07 field2: 060 field1: 08 field2: 060 field1: 09 field2: 060 field1: 10 field2: 060   which is not what I want.  I want to split the file at the mark code060/code to two files. You can include code060/code to either file.   How can you use the flag -p in BSD Split in OSX?  <answer194656> The issue is caused by BSD split being later in your path than the GNU split (which doesn't support the code-p/code option). If you do an codeecho $PATH/code you should see this - code/usr/local/opt/coreutils/libexec/gnubin/code will be before code/usr/bin/code in the output.  To call BSD split directly, use the full path - pipe to code/usr/bin/split/code instead of codesplit/code.  Your original command will then become:  pre seq -w 1 1 10 | gsed ':a;N;$!ba;s/\n//g' | split -p '060' /pre  <answer196362> codesplit/code operates on multiple line files not on a single line file or string. In the example below I'm using codejot/code because codeseq/code in not on my system. Also I'm using BSD codesed/code with an addition that changes the marker code060/code to a colon. This produces the string code0102030405:7080910/code. We add the code060/code back into the second file.  precode    jot -w "%02d" 10 1                                     |     sed -e ':a' -e 'N' -e '$!ba' -e 's/\n//g' -e 's/060/:/'|     IFS=: read -r one two     echo "$one" &gt; file1     echo "060${two}" &gt; file2 /code/pre  <comment232253> The fact that you're getting 'invalid option' suggests that you might not be calling the correct `split`. What does `which split` return? <comment232254> @mjturner I added the output of your command. Yes, it seems that something wrong in my system. My manual of `man split` is about BSD, while my actual `split` is about GNU. <comment232258> How can set PATH and MANPATH consistent such that the command `man split` is about `split` command? <comment232261> If you'd like the GNU commands installed with a prefix, you'll need to reinstall them. Once that's done, amend your PATH and MANPATH in your shell configuration files accordingly. How did you install the GNU commands? I have a feeling by compiling by hand - if so, rather use a package manager like pkgsrc, MacPorts or Homebrew. Much better than compiling from source. <comment232263> What is your output of `seq -w 1 1 10 | gsed ':a;N;$!ba;s/\n//g' | /usr/bin/split -p '060'`? I get only the original string. Nothing splitted at all. <comment232266> @Masi That's by design. `split` splits a multiple line file into multiple files, using the `-p` pattern. As you're only using a single line of input, that's what's output. `split` doesn't split a matching line, it uses it as the start of the next file. Hopefully that makes sense! <comment232267> Yes, it makes sense. I have data in one megaline. What is the option to split on line? I need this split on line because some content can be one two lines where a matching is not working on multiple lines. <comment232272> @Masi You'll need to give us a proper example, but with the data provided you can do the following instead of piping to `split`: `| awk -F'060' '{print "field1: "$1 "\nfield2: "$2}'` <comment232280> @mjturner, Your proposed `awk` command splits the string, so to speak, however its output discards "060" (as it's set as the field separator) from the string and I believe Masi doesn't want data discarded.  Would the following be appropriate? `awk -F'060' '{print "field1: "$1 "\nfield2: 060"$2}'` <comment232282> @user3439894 The output is `field1: 01 field2: 060 field1: 02 field2: 060 field1: 03 field2: 060 field1: 04 field2: 060 field1: 05 field2: 060 field1: 06 field2: 060 field1: 07 field2: 060 field1: 08 field2: 060 field1: 09 field2: 060 field1: 10 field2: 060` which is not what I want. I want to split the file at the mark `060` to two files. You can include `060` to either file. <comment232286> @Masi, I don't know how you're getting all those fields however the following commands output is two lines, one is `field1: 0102030405` and the other is `field2: 0607080910`. The command is: `seq -w 1 1 10 | gsed ':a;N;$!ba;s/\n//g' | awk -F'060' '{print "field1: "$1 "\nfield2: 060"$2}'` <comment232300> Why are you not using both the `seq` and `gsed` commands while substituting `awk` for `split`? The following commands output is two lines, one is `field1: 0102030405` and the other is `field2: 0607080910`. The command is: `seq -w 1 1 10 | gsed ':a;N;$!ba;s/\n//g' | awk -F'060' '{print "field1: "$1 "\nfield2: 060"$2}'` <comment234540> This `jot -w "%02d" 10 1 | sed -e ':a' -e 'N' -e '$!ba' -e 's/\n//g' -e 's/060/:/' | IFS=: read -r one two` gives me nothing as an output. What is your output at that stage? The problem is with IFS=... My currently in Debian 8.1 here `read` is some Linux variant. <comment234543> The first two commands give me correctly `0102030405:7080910`. I try to get OSX soon in my fingers. What is this flag `-r` doing? I try to do it with this Debian 8.1. <comment234561> I'm assuming that you are using `bash`. Just type `help read` for an explanation. <comment234563> Thank you! I did not know that `help`. I get `-r  do not allow backslashes to escape any characters`.
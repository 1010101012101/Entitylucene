Mac OSX : How to password protect an .app or other folder from deleting/moving by user/admin/root <body> I'm working on a security agent. Wherein I do not want to allow any user/admin/root to delete my security agent application normally.  If user/admin/root try to delete the .app file then OS should show password dialog. If user knows the password then only it should be deleted.  Any pointer on this would be helpful.  <answer177193> strongDisclaimer/strong  This answer is not intended as security advice for regular users. Setting your Mac's securelevel to 1 could potentially cause certain software or hardware drivers to malfunction, so I advise doing your own due diligence and independent research and testing to determine whether there could be any undesirable consequences to performing these steps.  Section 5.4.2 of the below-linked article about BSD's features related to security restrictions on the super-user is a good place to start. http://docstore.mik.ua/orelly/other/puis3rd/0596003234_puis3-chp-5-sect-4.html  In case that link breaks in the future, the most important section of the article lists the effects of setting codekern.securelevel=1/code:     Write access to the raw disk partitions is prohibited. (This forces   all changes to the disk to go through the filesystem.)      Raw access to the SCSI bus controller is prohibited.      Files that have the immutable flag set cannot be changed. Files that   have the append-only bit set can only be appended to, and not   otherwise modified or deleted.      The contents of IP packets cannot be logged.      Raw I/O to the system console is prohibited.      Raw writes to system memory or I/O device controllers from user   programs are prohibited.      Some access is denied to the Linux /proc filesystem.      Additional kernel modules cannot be loaded.      The system clock cannot be set backwards. In addition, it cannot be   set forward more than a maximum of one second, and it can be set   forward only once per second (effectively, the clock can be pushed at   most to double time).      This list is not comprehensive.   TLDR: setting codekern.securelevel=1/code could have more consequences than what's described in the below steps. Be careful.  That said, I have tested out these steps on a regular iMac with OS X 10.10.2 and did not notice any problems as a result. In the past, codesecurelevel 1/code was the default setting for OS X, and manpages in OS X 10.10 still indirectly indicate that code1/code is the default setting (they say you must reboot in single user mode to remove schg, which requires codesecurelevel 0/code).  However, in reality, codesecurelevel 0/code has been the default setting since OS X 10.5. When the online community learned that Apple quietly changed the default to 0, some sysadmins on Apple Discussions threads called it "unconscionable" of Apple to do this. I've also found some security guides online that say setting codekern.securelevel=1/code is an important step to take for securing your Mac. YMMV.  strongAnswer Summary/strong  As long as you set a firmware password on a Mac, you can make any file on that Mac unable to be deleted by anyone, just by using this simple Terminal command:  precodesudo chflags schg /path/to/file /code/pre  Next make sure your Mac will always boot to securelevel 1 by doing:  precodesudo vi /etc/sysctl.conf /code/pre  Once in vi editor, type codei/code to enter insert mode, then type codekern.securelevel=1/code. Next hit enter, then colon, then type codewq/code and hit enter.  Lastly in Terminal type:  precodesudo chflags schg /etc/sysctl.conf sudo sysctl kern.securelevel=1 /code/pre  Now that securelevel is 1 and the codeschg/code flag is set, the file cannot be deleted unless the system is rebooted into single user mode.  If a firmware password has been set, you need that password to get into single user mode. Further you need it to get into target disk mode or change the startup disk.   With the schg flag set, even root cannot delete the file. Nobody can modify it from the Finder or Terminal. It will appear locked in the Finder, but the locked checkbox will always remain grayed out, no matter what, even with an admin password. In the Terminal, codesudo rm /path/to/file/code will now fail, saying "Operation not permitted". Also, codesudo SetFile -a l /path/to/file/code will fail with, "ERROR: Unexpected error. (-5000)". :D  To delete this file, someone will need to use the firmware password to reboot into single user mode, then unset the schg flag using this command:  precodesudo chflags noschg /path/to/file /code/pre  After that it can be deleted.  strongUPDATE: Critical Extra Steps Necessary for Answer to Work/strong  Update added Wed. 18 Mar. 2015 ~1:20 PM PDT: it came to my attention in the comments to this answer that someone with sudo access on the system could delete the protected file by renaming the /private/etc directory, then copying all its contents except the sysctl.conf file into a new /private/etc directory, and restarting. This would cause secure level to revert to zero.  To prevent this, after performing the above steps, you should also perform the following commands:  precodesudo chflags schg /private sudo chflags -h schg /etc /code/pre  The first command makes the /private directory and its subdirectories unable to be renamed. The second command makes the root-level symbolic link to /private/etc impossible to rename or delete. (The code-h/code argument makes chflags act upon the symbolic link itself, instead of acting on the target of the symbolic link.)   strongMain Caveats/strong  ol liIf you're on a Hackintosh or Mac Pro with an unofficial PC graphics card that has not been flashed with official Apple firmware or something functionally identical to that, this trick won't work. I am not sure if they can boot to single user mode, so if you establish the sysctl.conf file, and set it to schg, it may be like that forever. Which means any files set to schg can never be deleted./li liThere may be some physical ways to reset the firmware password by removing RAM or delete the file by removing the SSD/HDD and attaching to another computer./li /ol  strongExplanation of Answer/strong  To set a firmware password for your Mac using the steps shown when you google, "how to set a firmware password on a mac". Briefly the steps are:  ul liReboot in recovery mode/li liSelect Firmware Password Utility from the Utilities menu and set the password/li li.../li liPROFIT!/li /ul  strongExplanation of Caveats/strong  Note that on Macs with removable RAM, a hacker may be able to reset your firmware password by changing the amount of RAM, then clearing your PRAM a bunch of times. So on Macs like that, take appropriate physical security measures to prevent manual access to the computer's internal components.    Suffice it to say you must get to securelevel 0 for codechflags noschg/code to work, and normally the only way to get back to securelevel 0 is to reboot in single user mode. Again this might be impossible if your Mac lacks Apple firmware. If you're paranoid/unsure, can see your current securelevel by typing codesysctl kern.securelevel/code in Terminal; it should always be 1 after the steps have been followed unless you're in single user mode!  strongFurther notes/strong  As far as I know, and correct me if I'm wrong, but the only way around a firmware password (other than resetting it through the RAM removal trick) is to remove the primary hard disk or SSD from the computer in question, and access it from another computer using a SATA to USB adapter, or something similar. (Government agencies and/or Apple might have a secret, classified backdoor... but if they're after you, then you probably want to delete files, not prevent their deletion :D.)  So, technically speaking, setting schg only really solves your problem with 100% infallibility if you're on one if the newer Macs without replaceable RAM and without a replaceable hard drive (i.e. a Retina MacBook Pro, MacBook Air, etc.) and you set your EFI password, because those are the only Macs without removable RAM or a removeable SSD. (Of course if someone takes out your drive just to delete a file, again, you probably have worse problems, like, dude where's my hard drive?)  The 21.5" iMac's lack of "user-replaceable" RAM makes it a lot harder to circumvent the EFI password and steal RAM, which is probably why Apple made it that way, as it's intended heavily for use in schools where kids can and will circumvent any security measures :D (I know because in my day we used to hack right past AtEase on System 7 to play Marathon...)  On non-21.5" iMacs you can prevent the RAM-removal/firmware-password-reset trick by investing $40-50 in a Maclocks-brand lock for iMac. It goes into the security port and has a metal plate that covers up the power socket where the release for the RAM hatch is. With that physical lock in place, someone would need a diamond saw or similar to delete your schg-protected file... and if people are taking diamond saws to your computers then you have a lot worse problems to worry about than a file getting deleted, like, dude, where's my computer?  <comment209377> You can't stop root from doing anything (or sudo rm) as for users look at Unix file permissions <comment209417> sudo would ask for a password. <comment209490> With all due respect, Mark is incorrect; see my answer below. The sudo password will be known to admin users, so Unix file permissions are not an answer to op's question. <comment209493> `sudo chflags noschg /path/to/file; sudo rm /path/to/file` works for me even without resorting to single user mode. <comment209499> What kind of Mac are you using? If it's a Mac Pro or Hackintosh, what kind of GPU does it have? What version of OS X are you on? What is the result of running `sysctl kern.securelevel` in the Terminal? <comment209501> System is a late 2012 Mac mini running 10.10.2, `kern.securelevel` is 0. See http://pastebin.com/b2LNg7S1 for the transcript. <comment209506> Did you set your EFI firmware password? <comment209507> No, plan vanilla installation, and just run the commands in the pastebin transcript. <comment209513> OK let me check into it, there is going to be another step necessary to set securelevel to 1. <comment209518> OK I've updated the answer, it will work for you now. I was wrong about the EFI firmware setting the securelevel; you must do it with a file called /etc/sysctl.conf. The extra steps necessary involve creating that file then protecting it with chflags schg, and then setting the securelevel. I think that older OS X versions may have defaulted to securelevel 0. I don't know if setting it to 1 could impair any functionality of the system, since it does more than just prevent noschg. See http://docstore.mik.ua/orelly/other/puis3rd/0596003234_puis3-chp-5-sect-4.html <comment209525> What can you do if you boot off a recovery partition - or off an arcade USB drive? <comment209526> I can think of a couple ways to bypass this. First, while the file may be locked, it'd still be possible to rename the directory it's in and replace it with a near-duplicate (just missing the "locked" file). To prevent this, you'd need to lock at least every other directory on its path... and locking / or any of the top-level folders under it would likely cause trouble. Second, I'd think a kernel extension would be able to bypass the part of the filesystem that enforces the schg flag, and root can load extensions. <comment209530> @Gordon - I'm also thinking on the same line. Creating a kernel extension. But I've not written it before so don't know how to start with it. How exactly it will work?   Can you post any url to refer for this? <comment209543> @Mark Regarding a USB stick, I don't know if the system will allow you to change your startup disk after EFI firmware password is set. As for Recovery Partition, not sure either, please test and let us know? <comment209544> @Gordon: you can rename the directory it's in, but you can't replace the directory. And after all, who cares if you rename the directory it's in? Just use a fileReferenceURL or Finder alias, they don't care if a path changes. As for a kernel extension bypassing the securelevel, there are ways to prevent people from sneaking kernel extensions onto your system. <comment209554> @Omkar I've never written a kernel extension, so I can't offer much advice, except to say that if you aren't particularly familiar with the kernel, your extension has a good chance of *creating* security problems. <comment209555> @CommaToast it depends on exactly how it's loaded. If it's via an item in /Library/LaunchDaemons it'd be by path not a fileReferenceURL or alias. Also, your opponent could replace /Library/LaunchDaemons and disable it that way, or replace /private/etc and hence remove the securelevel setting on next reboot. <comment209556> @Gordon Good points. But all you have to do is set /private to schg. The neither it nor its direct children can be modified, but its grandchildren (except sysctl.conf) still can. The contents of /private never change so, no big deal, right? As for how kernel extensions work, I'm not sure why we're even talking about them. Not clear what Okmar is trying to accomplish. <comment209731> Based on the flaw @GordonDavisson pointed out, I've updated the main answer with extra steps to prevent the renaming of /private/etc or the /etc symlink, which could be used to bypass the sysctl.conf file and set `securelevel 0` without needing the firmware password. I also added a disclaimer so that random folks who happen upon this won't cause themselves problems. <comment209756> @CommaToast Wow, I had no idea securelevel=1 had such far-reaching effects (and I wonder how much of that applies to OS X -- I may have to do some testing). Locking /private and /etc should take care of my worry about replacing /private/etc, but I don't see a reasonable similar way to lock e.g. an item in /Library/LaunchDaemons. Locking a system against an attacker with root access is *really really hard*, and I think at some point you have to just call it good enough. BTW, Apple does have a backdoor to reset firmware PWs, they just require proof of ownership before unlocking. <comment209807> @GordonDavisson Once you lock up /private and the /etc symlink, and follow the other steps in the answer, then you can schg-lock other things in a way that they can't be unlocked or deleted without the EFI password. So if you have a LaunchDaemon you want to lock, then you just lock it that way, and put it in /System/Library/LaunchDaemons, then lock /System/Library. You could also put it /Library/LaunchDaemons and lock /Library, but that could cause problems if you try to install any software that wants to put things into /Library. But if you're worried about security, that's probably good.
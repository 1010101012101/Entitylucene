Is there an easy way on a Mac to split an audio file at defined intervals? <body> I have a 45 minute long audio (.m4a) file.  I would like to split this audio file into a separate audio file every 2 minutes.  So, that:     AudioFile1.m4a is created from [00:00] to [02:00] of   originalAudioFile.m4a.      AudioFile2.m4a is created from [02:00] to [04:00] of   originalAudioFile.m4a.      AudioFile3.m4a is created from [04:00] to [06:00] of   originalAudioFile.m4a.      ...   and this is continued until      AudioFile23.m4a is created from [44:00] to [45:00] of   originalAudioFile.m4a.   Here are additional details:  ul liI am not particular about the filenames of the resulting files./li liI am not particular about the file types of the resulting files (e.g., whether they become .mp3 files or stay .m4a files)./li liThis is not a situation where the resulting audio files will be mastered to a CD or something. I'm just looking for a quick and handy way to split an audio file based on a specific interval. A minor loss in audio quality is not a big deal (but this would obviously not be preferred)./li liI do not want the originalAudioFile.m4a to be altered in the process./li /ul  The most important condition is that the method requires minimal time and effort from the user.  There are various methods to accomplish what I want in Microsoft Windows, but can this be done on a Mac?  <answer275913> Use ffmpeg.  It's available via Homebrew and MacPorts, but I just prefer to use the prebuilt binaries  Just off the top of my head, you could do something simple like:  precode$ ffmpeg -i source_audio_file.mp3 -ss 0 -t 120 segment_1.mp3 $ ffmpeg -i source_audio_file.mp3 -ss 120 -t 240 segment_2.mp3 $ ffmpeg -i source_audio_file.mp3 -ss 240 -t 360 segment_3.mp3 . . . /code/pre  To put this into a script wouldn't be too hard  <answer276044> I've written an AppleScript that will accomplish exactly what I described in my original post. It makes use of codeffmpeg/code, as suggested in a previous answer by user emAllan/em.  hr  Note: If you do not have codeffmpeg/code currently installed on your computer, my script is worthless.  I installed codeffmpeg/code via Homebrew. Homebrew is very easy to install; directions can be found at the top of this page (the official Homebrew website).  After installing Homebrew, run these lines individually in Terminal to install codeffmpeg/code on your system:  precodebrew install ffmpeg brew link ffmpeg /code/pre  Now, you will be able to make use of my script.  hr  Notes about my code:  ul liEven though this was not totally necessary for my purposes, codeffmpeg/code also provides the user with total control over filenames, file types, bit rate, the output directory, etc., which is gravy./li liCertain aspects of my script are tailored to my personal preferences (e.g., including the current date in the name of the output directory), so obviously modify the code as you see fit./li liI've done my best to include some error handling to catch certain potential errors, but this is obviously far from all-inclusive./li liI don't envision myself needing to do this audio splitting task that often, so a simple .scpt file created in Script Editor is fine by me.  ul liIf you prefer to convert this script to a launchable, standalone application, you can easily do so in Automator (by inserting a em"Run AppleScript"/em action into your workflow and pasting the full code).  ul liIn that case, you might want to adjust the app so that the user can simply drag the source audio file onto the app icon to initiate the app (instead of having to provide the file path of this file in a dialog)./li /ul/li /ul/li liIt is entirely possible, if laborious, to program a VBR (variable bit rate) encoding option for the resulting files into the script. I chose not to do so because, for my purposes, this ability is not particularly needed. It would be somewhat complicated to write, since not all audio formats can be encoded in VBR (only Opus, Vorbis, MP3, WMA, and AAC audio files can)./li liFinally, I am 100% certain that the code contains at least some shortcomings, blind spots, and/or bugs, so I apologize in advance./li /ul  hr  I am not able to paste the entire script directly in this answer. The length of the code exceeds the maximum character limit for Stack Exchange answers.  strongYou can view and download the full code on this Pastebin page./strong  Using the linked script, the user can intuitively split up any audio file into numerous files based on a defined interval, while requiring minimal time and effort from the user.  Note that when the user does not choose the source bit rate as the bit rate for the resulting files, the script can take a while. This is because codeffmpeg/code is slow at re-encoding. But, fortunately, the user can simply set it, and direct their attention to something else as it completes.  hr  h3Note that the format of two lines that Allan provided in their answer is incorrect./h3  After several hours of troubleshooting my AppleScript file, I realized that my AppleScript file was not the issue.  strongcode-t/code reflects the duration of the resulting audio file, not the ending time stamp./strong  Allan's sample code should read:  precode$ ffmpeg -i source_audio_file.mp3 -ss 0 -t 120 segment_1.mp3 $ ffmpeg -i source_audio_file.mp3 -ss 120 -t 120 segment_2.mp3 $ ffmpeg -i source_audio_file.mp3 -ss 240 -t 120 segment_3.mp3 /code/pre  Here is the relevant passage from the codeffmpeg/code documentation:     strong-t emduration (input/output)/em/strong      When used as an output option (before an output url), stop writing the output after its duration reaches emduration/em.  
Terminal: Adding logic to 'find' directories containing either [criteria A] or [criteria B] <body> I have inherited a vast media archive without a unifying organizational scheme. Its contents date back at least 10 years. I have been asked to find a needle in this hay stack, and I have some guesses as to that needle's name. But I don't know its name for certain. I want to use a single codefind/code command in the Terminal to search for alternate names. And I want to include a second set: possible file extensions. In pseudocode, here's what I mean: codefind [in a given directory] [files and folders whose name matches (*guess1* OR *guess2*) AND whose name matches (*.extension1 OR *.extension2)]/code. How should I express this in the Terminal?  <answer129322> You can do this using ls and grep with regular expressions  precodels | grep -E "(guess1|guess2)(\.extension1|\.extension2)" /code/pre  Or if you need to recursively look into folders:  precodels -R | grep -E "(guess1|guess2)(\.extension1|\.extension2)" /code/pre  <answer129355> codefind/code is slow. codegrep/code and other text search tools are much faster. Unless you think you're going to find the needle in the haystack with the first shot, you're probably better off doing a codefind/code into a temporary file, e.g. codefind . -print &gt; /tmp/find.out/code, and then searching in that file for file names that meet your search criteria.  <answer129360> Use the command  precodefind /dir/to/search \( -iname '*guess1*' -o -iname '*guess2*' \) \                     \( -iname '*.extension1' -o -iname '*.extension2' \) /code/pre  codefind/code works recursively.  Use code-maxdepth 1/code to make it non-recursive.  code-iname/code does a case-insensitive filename match.  Arguments are implicitly joined by AND, but you can use code-o/code to make it OR.  Parentheses have to be escaped with a backslash to protect them from the shell.  (It could be written all on one line; here I've broken the lines using kbd\/kbdkbdreturn/kbd for readability.)  <answer129363> If the volume is indexed by Spotlight, then use codemdfind/code for fastest results.  precodemdfind -onlyin /dir/to/search '(kMDItemFSName==*guess1* || kMDItemFSName==*guess2*)' \                      '&amp;&amp; (kMDItemFSName=*.extension1 || kMDItemFSName=*.extension2)' /code/pre  <comment151367> Obligatory note: there are [downsides to parsing ls](http://mywiki.wooledge.org/ParsingLs). <comment151414> I second the admonition from @grgarside that parsing the output of `ls` is a poor approach to choose in general, even though it may happen to do the job for you.
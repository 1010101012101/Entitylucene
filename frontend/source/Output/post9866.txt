Programmatically/Script-atically changing the default Open-With setting <body> Is there a way to change what app opens a file type programmatically/with a script?  Basically, sometimes I'm working on a web site, and I want to set all web files to open with a text editor (*.php, *.html, *.htm, etc...).  However, other times, I want to just view the files, so I want them to open with a browser.  Right now, I'm dragging items onto dock icons, which works, but is slow, particularly when I'm going through a large number of files with the keyboard only.   Basically, what I want is a small applescript/whatever that changes all the open-with settings.br That way, I can have one script for each open-with program, and change back and forth.  Thanks.  <answer9867> It doesn't really answer your question, but might be a solution.  The strongInspector/strong in Finder presents information for the emcurrently selected/em file, or files:  kbd⌘/kbd+kbd⌥/kbd+kbdI/kbd   The strongSummary Info/strong window of Finder is useful when emmultiple files/em are selected:   kbd^/kbd+kbd⌘/kbd+kbdI/kbd  If you select multiple files of the same type, then either method above will allow you to easily switch the emOpen with:/em property for those files.  <answer9883> This is doable, but probably isn't as straightforward as you might think.  You'll need to get very familiar with Uniform Type Identifiers.  Look at Wikipedia's Uniform Type Identifier page.  OS X stores information on preferred file associations in a preference file with the name codecom.apple.LaunchServices.plist/code.  Before you go try to find and modify that file, I suggest you familiarize yourself with OS X's domain hierarchy for defaults (a.k.a. "settings").  A decent article on this can be found here. (Disclaimer: they seem to be selling something on that site. I don't know what it is and have no association with them, the explanation is just a good one.)  Now that you know all about defaults and UTIs (er, not the medical kind), now we can talk about setting file associations from a script/command line.  First, you'll need to know the proper way to identify the files for which you want to make an association.    Remember how I said UTIs were important?  There are multiple ways to identify a file.  It depends on if the type has been formally declared on your system or not.  For example, decent text editors like TextMate or TextWrangler will add quite a few type declarations to the type hierarchy when you use them on your system.  If, however, you don't have those applications, you may not have those types declared.  OK, enough talk.  Examples:  Get the UTI for a file:  precode$ mdls myFile.xml ... kMDItemContentType             = "public.xml" kMDItemContentTypeTree         = (     "public.xml",     "public.text",     "public.data",     "public.item",     "public.content" ) ... /code/pre  Ok, cool.  An explicit content type we can use.  Write that down somewhere.  precode$ mdls myFile.myExtn ... kMDItemContentType             = "dyn.ah62d4rv4ge8048pftb4g6" kMDItemContentTypeTree         = (     "public.data",     "public.item" ) ... /code/pre  Oops.  OS X doesn't know about ".myExtn" files.  So, it created a dynamic UTI that we can't use for anything.  And the parent types are too generic to be useful.  Now that we know what our files are, lets look at the LaunchServices.plist file and see what we can do:  precode$defaults read com.apple.LaunchServices {     ...     LSHandlers =     (                 {             LSHandlerContentType = "public.html";             LSHandlerRoleAll = "com.apple.safari";             LSHandlerRoleViewer = "com.google.chrome";         },     ...                 {             LSHandlerContentTag = myExtn;             LSHandlerContentTagClass = "public.filename-extension";             LSHandlerRoleAll = "com.macromates.textmate";         },     ...     );     ... } /code/pre  So, when you have a "good" content type to use, the first construct is better.  Otherwise the other construct.  Note, there are other constructs in that file, but they aren't relevant to what you asked.  Just know they are there when you look through the output.  As you can see, you'll need to find the UTI for the application you want to use.  The UTIs for Safar and TextMate are in my example above, but to generically find the UTI for an application:  precode$ cd /Applications/MyApp.app/Contents $ less Info.plist ...         &lt;key&gt;CFBundleIdentifier&lt;/key&gt;         &lt;string&gt;com.apple.Safari&lt;/string&gt; ... /code/pre  NOTE: I have emno/em idea what constitutes the difference between LSHandlerRollAll and LSHandlerRollViewer.  I can't find documentation on that anywhere.  What I emdo/em see is that 99% of the time LSHandlerRollAll is the only one set (i.e. there is no LSHandlerRollViewer at all) and that it is set to the UTI for the application that you desire to associate the type with.  Having brought you this far, I'm going to leave HOW to set the values you want as an exercise for the reader.  Messing with these things can be somewhat dangerous.  It is entirely possible for you to screw up a file and not have ANY of your file associations work.  Then you have to throw away the file and start over.  Some hints:  ul liRead up on codedefaults write/code and its syntax/li liTake a look at codePlistBuddy/code.  codeman PlistBuddy/code and code/usr/libexec/PlistBuddy -h/code/li liSkip all this nonsense altogether and use RCDefaultApp/li /ul  <answer9954> One option is to edit code~/Library/Preferences/.GlobalPreferences.plist/code:  codedefaults write com.apple.LaunchServices LSHandlers -array-add '{LSHandlerContentType=com.adobe.pdf;LSHandlerRoleAll=net.sourceforge.skim-app.skim;}'/code  You can use PlistBuddy to check if entries already exist, but I haven't found any way to apply changes without restarting or rebuilding the Launch Services database.  Using duti, you could run codeduti ~/.duti/code after saving this as code~/.duti/code:  precodenet.sourceforge.skim-app.skim .pdf all /code/pre  <answer281779> Not an answer to your exact question, but another possible solution. You can open a document with a specific application from the command line with the -a argument to open.   For example, open all the html files in the current directory.  precode&gt; open -a 'Google Chrome' *.html /code/pre  Open index.html and the javascript controller files in the Atom text editor:  precode&gt; open -a 'atom' index.html js/controllers/*.js /code/pre  Depending on your needs, you could modify this to be an Automator service which could be assigned a shortcut key, taking in the selected file paths as an argument.  Here's an example Automator AppleScript that receives files as input and opens the selected files in Chrome:  precodeon run {input, parameters} set openFiles to "open -a 'Google Chrome' " --note the trailing space set filePaths to {}  --covert the filePaths to posix style repeat with i from 1 to count of input     set aFile to input's item i as alias     set aFile to quoted form of POSIX path of aFile     set filePaths's end to aFile end repeat  --convert filePaths list to a string delimited by spaces set tid to text item delimiters set text item delimiters to " " set filePaths to filePaths as text set text item delimiters to tid  --Open files via commandline do shell script openFiles &amp; filePaths return input /code/pre  end run  Obviously, you could change the app name "Sublime" text editor, save it as another service, and assign them both shortcut keys.   <comment10374> Is RCDefault scriptable? I looked over their site, and it doesn't look like it. <comment10394> Nevermind, I have type declarations for all the file types I am interested in.
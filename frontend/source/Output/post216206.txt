Terminal command to return network class <body> I'm trying to construct myself a primitive network scanner, and I understand that there are multiple network classes and it has become necessary for my program to determine exactly what class of network the workstation is currently connected to.  I have trialled a few options which i consider to be needlessly complicated, such as truncating various commands such as codeifconfig/code, however these methods are arduous and messy.  Is there a single Terminal command which can return simple output such as code10.0.0.0/code, thereby identifying the network class?   <answer216213> Please reconsider and reformulate your question.  You are mixing emprivate IPv4 address spaces/em and emclassful networks/em (which are deprecated or at least "old-fashioned" since 1993) and you don't consider emclassless networks/em.  In the old-fashioned concept of emclassful networks/em the leading bits 0 (Class A), 10 (Class B), 110 (Class C), 1110 (Class D) or 1111 (Class E) you get by issueing a proper codeifconfig/code or codeipconfig/code command strongcompletely/strong determine the class.  So all IP-addresses starting with   ul li    0 - 127 belong to Class A/li li128 - 191 belong to Class B/li li192 - 223 belong to Class C/li li224 - 239 belong to Class D/li li240 - 255 belong to Class E/li /ul  hr  I can't add this as a comment because it's to long.  <answer216216> You can try something like this:  precode#!/bin/bash                                                                                                                                     IPS=$(ifconfig -a | perl -nle'/(\d+\.\d+\.\d+\.\d+)/ &amp;&amp; print $1' | sed 's/127.0.0.1//')  FIRST=$(echo "${IPS%%.*}")  case 1 in $(($FIRST &lt;= 127))) echo Class A ;; $(($FIRST &lt;= 191))) echo Class B ;; $(($FIRST &lt;= 223))) echo Class C ;; $(($FIRST &lt;= 239))) echo Class D ;; $(($FIRST &lt;= 255))) echo Class E ;; *) echo Something wrong! ;; esac /code/pre  If You want only the IP, echo the code$IPS/code variable.  <answer216241> With CIDR (Classless Inter Domain Routing) the old class concept is gone. Instead you create your networks by setting the proper subnetmask and your routing. So much for history. :-) br /  As my Yosemite outputs netmasks in ifconfig in hex, I wrote a shell script that analyses all ifconfig output and calculates the network from it. Maybe you could modify that to your needs. A sample output would be:  precodeIP adress:      127.0.0.1 Netmask:      255.0.0.0 Network:      127.0.0.0 IP adress:   172.20.41.52 Netmask:  255.255.255.0 Network:    172.20.41.0 IP adress:    172.16.47.1 Netmask:  255.255.255.0 Network:    172.16.47.0 IP adress:   192.168.97.1 Netmask:  255.255.255.0 Network:   192.168.97.0 /code/pre  br /  Here is the script; it omits inet6 adresses from ifconfig and relates only to IPv4:  precode#!/bin/sh  IP="`ifconfig -a | fgrep 'inet ' | sed -e 's/^.*netmask:\(.*\)$/\1/g' -e 's/^.*inet\ \([^\ ]*\)\ .*$/\1/'`"  convert_hex_netmask_to_dec () {     nh=$1     nd=$(($nh % 0x100))     for i in 1 2 3     do         ((nh = nh / 0x100))         nd="$((nh % 0x100)).$nd"     done     echo $nd     # See more at: http://compgroups.net/comp.unix.shell/convert-hex-to-decimal/497395#sthash.ShzT161v.dpuf     }  for ipadress in ${IP} do     netmaskhex="`ifconfig -a | fgrep 'inet ' | grep ${ipadress} | awk '{print $4}'`"     netmaskdec="`convert_hex_netmask_to_dec ${netmaskhex}`"     IFS=. read -r i1 i2 i3 i4 &lt;&lt;&lt; "${ipadress}"     IFS=. read -r m1 m2 m3 m4 &lt;&lt;&lt; "${netmaskdec}"     NET="`printf \"%d.%d.%d.%d\n\" \"$((i1 &amp; m1))\" \"$(($i2 &amp; m2))\" \"$((i3 &amp; m3))\" \"$((i4 &amp; m4))\"`"      printf "IP adress:%15s Netmask:%15s Network:%15s\n" ${ipadress} ${netmaskdec} ${NET} done /code/pre  br / If you want only the first octet from the network, just disable the final printf and replace it with  precodeprintf "%d\n" "$((i1 &amp; m1))" /code/pre 
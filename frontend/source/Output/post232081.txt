Command line equivalent of Disk Utility, which is not diskutil, to obtain UUID <body> Following on from the answer to Can you make OSX mount just certain partitions when you connect an external HDD?, all of the sites that I have checked (CNET, OSXDaily, Apple Support community threads) say that you have to use Disk Utility (or the command line codediskutil info /dev/disk&lt;X&gt;s&lt;Y&gt;/code) to find the UUID.   Is there a command line equivalent that will give me this information, which is not codediskutil/code? In particular, one that will work in single user mode?  h3Why diskutil does not work/h3  In emsingle user mode/em (at least on Mountain Lion) after running:   precode/sbin/fsck -fy /sbin/mount -uw / /code/pre  running:   precodediskutil info disk0s5 /code/pre  gives the following error  precodeUnable to run because unable to use the DiskManagement framework. Common reasons include, but are not limited to, the DiskArbitration framework being unavailable due to being booted in single user mode. /code/pre  h3Background/h3  My issue is that I have a dying partition on my internal disk, which only holds an out of date Snow Leopard OS, but is slowing down my Mac (unbearably), as the console is (repeatedly) reporting:  precodekernel: disk0s5: I/O error. /code/pre  I no longer boot into Snow Leopard as I boot Mountain Lion which is on an external FireWire disk, so I would like to leave the Snow Leopard partition unmounted, using the line  precodeUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX none hfs rw,noauto /code/pre  in code/etc/fstab/code.   However, to obtain the UUID of the faulty partition, I have to open up Disk Utility and have the faulty partition mounted, which is a torturously slow process (it takes Disk Utility about twenty minutes to open).  hr  strongTL;DR/strong - Can I obtain the UUID of the internal partition, when booting into single user mode of an OS stored on a partition which is on an external FW disk?  <answer232086> Update:  codeIOReg/code gives the partition UUID, not the volume UUID, as it operates below the HFS layer. I had incorrectly assumed that the device UUID was required rather than the volume UUID because it was substituting for a device node. To get the volume UUID, use codehfs.util/code. For example:  precode/System/Library/Filesystems/hfs.fs/Contents/Resources/hfs.util -k disk0s3 /code/pre  Replace "disk0s3" with whatever the "device identifier" of your volume. This is different to the "device node" (which is "/dev/disk0s3" in this case").  Original IOReg details:  You can run codeioreg -c IOMedia -r/code to show the device tree for the disk devices in your system. This should give a manageable amount of output (as compared to codeioreg -l/code, which shows everything).  If you want to just extract UUIDs, you can codeioreg -c IOMedia -r | grep UUID/code, but the downside is that you lose context.  The codediskutil/code information is interesting; it obviously depends on daemons that do not run in single user mode.  <answer232720> Install GPT Fdisk. After booting to Single User Mode enter:  precode/sbin/fsck -fy /sbin/mount -uw / /usr/local/bin/gdisk /code/pre  In interactive mode first enter the device node (e.g. disk0):  precode/dev/disk0 /code/pre  then codei/code to show detailed information on a partition.br Finally enter the partition number e.g. code5/code to get the Partition unique GUID:  precodePartition GUID code: 53746F72-6167-11AA-AA11-00306543ECAC (Apple Core Storage) Partition unique GUID: 7AA0FD56-01BC-4EA1-8CE2-7972E63A2A6D First sector: 409640 (at 200.0 MiB) Last sector: 133955543 (at 63.9 GiB) Partition size: 133545904 sectors (63.7 GiB) Attribute flags: 0000000000000000 Partition name: '' /code/pre  <answer233036> As an aside, I have just discovered that there is no actual need to do any of this, because, en lieu of using the UUID, you can use the emvolume label/em instead, in code/etc/fstab/code, like so:  precodeLABEL=Archive none hfs rw,noauto 0 0 /code/pre  This method has the benefit of:  ol liBeing much simpler to implement, and strongmore importantly/strong;/li liThe volume label does not change, whereas the UUIDs change as you plug in other FW or USB disks. So, if you are using UUIDs  in code/etc/fstab/code then you need to update those UUIDs for the unmounted disks, in code/etc/fstab/code, each time you change the disk configuration./li /ol  Note: The use of the codeLABEL/code in code/etc/fstab/code, may not always work (i.e. if the disk is very corrupted and the label can not be read). In such cases, you will be obliged to use UUID.    <comment283517> Yes, `diskutil` should work in that situation. I have booted from an installation USB key, started terminal and used `diskutil` to configure disks, examine disks, etc. It doesn't have a requirement for the disk to be mounted. If you did try it, and it failed, post the error. <comment284406> @Greenonline No, I haven't tried it from single user mode, and yes, I understand they're different. You say you tried it; did you get an error message? If so, what was it? <comment284408> @Greenonline I qualified the `diskutil` part of response more; I haven't tried it in single user mode and I don't know whether it depends on a daemon. I do know that it works on a disk that isn't mounted. Very curious to know what error message you received. <comment284430> Unfortunately, I can not install anything as the corrupted partition on the internal disk renders the Mac inoperable. I can, currently, only boot into single user mode. I need a built-in command. However, `ioreg -l | grep UUID;ioreg -l | grep disk` seems to do the trick. <comment284588> Why not install OS X onto a USB drive and then have a faster, non-hobbled by hardware errors OS to do whatever data recovery and data transfer the existing drive allows? <comment284591> @bmike - Sorry, I think my question may be somewhat unclear. I am attempting to do as you suggest - However, I have Mountain Lion on an external FW disk (en lieu of USB), which works perfectly well, but the internal drive partition needs to be unmounted first using the `/etc/fstab` technique`... hence the requirement for the UUID to be obtained in single user mode. Unless I open up the Mac and physically remove the drive, which I am not willing to do just yet. <comment284592> Aah - so where you can't easily get at the drive? If you didn't have a second Mac to run target disk mode or have [Disk Arbitrator](https://github.com/aburgh/Disk-Arbitrator) on the external to block the mounting of the faulty drive this makes more sense. <comment284594> @bmike - No, unfortunately I am in Thailand, and all my other Macs are in the UK. It is the Thai heat which has killed the disk. <comment284595> `ioreg -c IOMedia -r` unfortunately still scrolls too much data too quickly, in the same way that as `ioreg -l` on its own just scrolls streams of unreadable data up the screen, and using it in conjunction with `|more` just causes illegible binary data to be displayed, for some reason. `ioreg -c IOMedia -r | grep UUID` followed by `ioreg -c IOMedia -r | grep disk` fits on screen and one can correlate the two results, thereby linking the disks and the UUIDs. However, strangely, `ioreg -l | grep UUID` followed by `ioreg -l | grep disk` has better formatting and is actually _easier_ to read. <comment284596> @bmike - I like the sound of Disk Arbitrator though, in somewhat less unfortunate circumstances, I will certainly give that a try. <comment284601> You have excellent reasons for the single user mode requirement. Normally that's just the first thing someone tries here. In your case - it's the last/only resort as far as I can tell... Best of luck. <comment284626> @Greenonline you'll love `ioreg -c IOMedia -r | grep 'disk\|UUID'` <comment284806> @Olathe - That is brilliant! Even though it is just a `grep`y variation on janm's answer, do you want to make that comment into an answer, so that it doesn't get lost, as comments can be somewhat ephemeral? <comment284845> I would like to point out that I have just discovered that the UUID obtained from `ioreg` is not the same as the Volume UUID that is reported by diskutil, so that makes the whole exercise pointless as the ioreg UUIDs, when entered in `/etc/fstab/` do not prevent the volume from being mounted. <comment284961> @Greenonline Indeed -- fstab seems to need a volume UUID rather than a device UUID. Answer updated. <comment286360> Thanks :) the disk has seized up completely now, BTW. I managed to save some data. I will be more diligent with my backups from now on.
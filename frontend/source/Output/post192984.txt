Is there an OSX app/way to batch rename files via a purely text interface? <body> Many years ago - when I was a Windows user - I had an application which made renaming files an amazingly simple experience. You would select the files you wish to work with, and their filenames would appear within what was essentially a huge textarea. Imagine a text editor (such as TextEdit, Sublime Text, etc.) open to a document that simply lists all filenames, with each filename on a new line.  With the files in this interface, you had your "standard" find/replace tools (CMD+F), as well as the ability to use REGEX. You could use the keyboard's arrows to move around the filenames without extra clicks or bulky interfaces. Modified filenames were highlighted with a different background and applying changes to all files was a simple CMD+S.   Does something like this exist for OSX?  // edit - to clarify: I'm aware of OSX's built-in bulk file renaming options in Finder, and software along the likes of NameChanger, Renamer, Automator, ABetterFinderRename, etc. I'm emspecifically/em looking for software with the kind of UI I described.  // edit 2 - the original Windows software is called Oscar's Renamer: http://www.mediachance.com/free/renamer.htm  <answer192987> It's been a while since I have used it. But FileBuddy is designed to manipulate file names and a bunch of other stuff. Might be worth a look see.  <answer192992> If you're on OS X Yosemite (v10.10.x), Finder has a built-in way to batch rename files. Highlight all the files you want in Finder, hold down Control and click on one of them to bring up a right-click menu, and then click on "Rename x Files...". You'll get a nice find-and-replace interface, no third-party software necessary!  <answer193083> Follow these steps:  ol liInstall DiffMerge and codegem install batch_rename/code (see README.md for details)./li liIn Terminal.app, codecd/code to the directory which contains the files you wish to rename.br (For convenience, I suggest to ⌘-drag the folder from the Finder into the Terminal window.)/li liType codebatch-rename/code and press Enter. This opens an interactive editor.br The script will wait for you to close the editor. Then it will rename the files./li /ol  (Disclosure: I’m the author of the codebatch-rename/code tool.)  hr  strongEdit:/strong I liked OP’s problem so much that I’ve made my answer into a command-line tool for everyone’s convenience. To take advantage of the simplification, I have also rewritten my answer above.  I have uploaded the source to GitHub and published it as an installable gem on RubyGems.br Both are under a ISC license so feel free to send me issues and pull requests.  You can find my original answer below for reference.  hr  s1. Install DiffMerge./s  s2. codecd/code to the proper working directory./s  s3. Run the following Ruby script:/s  s(codebatch_rename.rb/code)/s  s  precode#!/usr/bin/env ruby # encoding: utf-8  require 'shellwords' require 'tmpdir'  Catalog = Struct.new(:time, :title, :file_name, :escaped_file_name) do   def lines     File.open(file_name).each.map(&amp;:chop)   end end  CAPTION = "Batch rename - #{ Dir.pwd }" DIFF_TMP_DIR = Dir.mktmpdir('batch-rename-') DIFFMERGE = '/usr/local/bin/diffmerge'  catalogs = [:before, :after].map do |t|   title = "#{ t.capitalize } renaming"   file_name = "#{ DIFF_TMP_DIR }/#{ title }.utf8"   escaped_file_name = Shellwords.escape(file_name)   Catalog.new(t, title, file_name, escaped_file_name) end  `ls -A | tee #{ catalogs.map(&amp;:escaped_file_name).join(' &gt;') }`  args = catalogs.map.with_index do |c, i|   ["-t#{ i+1 }=#{ c.title }", c.file_name] end  system(DIFFMERGE, "-c=\"#{ CAPTION }\"", *(args.flatten))  puts catalogs   .map(&amp;:lines)   .reduce(&amp;:zip)   .select { |a| a.reduce(&amp;:!=) }   .map { |pair| pair.map(&amp;Shellwords.method(:escape)) }   .map { |a, b| "mv #{a} #{b}" }   .join("\n") /code/pre  /s  <answer193349> Emacs can do this.    ol liOpen Emacs/li licodeC-x C-f/code and open the directory. It will open in codedired-mode/code./li licodeM-x wdired-change-to-wdired-mode RET/code/li /ol  You can now edit the filenames just as you asked.  Pressing codeC-c C-c/code will end wdired-mode and perform the modifications.       wdired-change-to-wdired-mode is an interactive autoloaded Lisp   function in `wdired.el'.      It is bound to   .      (wdired-change-to-wdired-mode)      Put a Dired buffer in Writable Dired (WDired) mode.      In WDired mode, you can edit the names of the files in the buffer, the   target of the links, and the permission bits of the files.  After   typing C-c C-c, Emacs modifies the files and directories to reflect   your edits.      See `wdired-mode'.   <answer193360> There is already a very good "service" tool called "A Better Finder Rename" now at V9 and working perfectly in Yosemite. http://www.publicspace.net/ABetterFinderRename/ I test/use it already since Leopard.  <answer193642> In terminal, you have:  ul liperl/li lipython/li lizsh/bash/sh/li liawk/sed/find/mdfind/xargs/li /ul  All have manual pages and volumes of text written on the internet in tutorials. I'd say, if you are into regex, the amount of time you'd need to adopt one of the unix tools to leverage text only renaming would be low and the return on investment high since you could then start automating even more challenging things than just file renaming.  If you really need a GUI - you could leverage any of the launchers such as LaubchBar or Alfred to kick things off and run your shell scripts.  <answer193649> Here's YACLBFR(*) in perl based upon Larry Wall's simpler version of emmany/em years ago...  precode#!/usr/bin/perl # # rename - originally from Larry Wall: # Examples: #   rename 's/\.orig$//' *.orig #   rename 'y/A-Z/a-z/ unless /^Make/' * #   rename '$_ .= ".bad"' *.f #   rename 'print "$_: "; s/foo/bar/ if &lt;stdin&gt; =~ /^y/i' * # # Author: Eric Engstrom &lt;eric (dot) engstrom (AT) g m a i l (dot) c o m&gt; ##  use Getopt::Long qw(:config bundling); use Pod::Usage; use File::Basename;  GetOptions('h|help'     =&gt; \$HELP,            'n|dryrun'   =&gt; \$DRYRUN,            'v|verbose'  =&gt; \$VERBOSE,            'f|force'    =&gt; \$FORCE            )   or pod2usage(2); pod2usage(1) if $HELP; ($expr = shift) || pod2usage(2);  if (!@ARGV) {   @ARGV = &lt;STDIN&gt;;   chop(@ARGV); } for (@ARGV) {   $was = $_;   eval $expr;   die $@ if $@;   mkdirs($_);   printf("%s%s &gt;&gt;&gt; %s\n", $was, (length($was.$_) &lt; 80 ? "" : "\n"), $_)     if (($VERBOSE || $DRYRUN) &amp;&amp; ! ($was eq $_));   warn "$_ already exists - not renaming $was\n"     if ( ! $DRYRUN &amp;&amp; ! $FORCE &amp;&amp; -e $_ );   rename($was,$_)     unless ($DRYRUN || $was eq $_ || (! $FORCE &amp;&amp; -e $_)); }  sub mkdirs($) {   my $dir = dirname(@_);   if (! -d $dir) {     mkdirs($dir);     print "making directory: $dir\n"       if $VERBOSE;     mkdir $dir       unless $DRYRUN;   } }   ##  __END__  =head1 NAME  rename \- renames multiple files using perl expressions  =head1 SYNOPSIS  rename [options...] perlexpr [file...]  =head1 DESCRIPTION  B&lt;Rename&gt; renames the filenames supplied according to the rule specified as the first argument.  The argument is a Perl expression which is expected to modify the $_ string in Perl for at least some of the filenames specified.  If a given filename is not modified by the expression, it will not be renamed.  If no filenames are given on the command line, filenames will be read via standard input.  For example, to rename all files matching *.bak to strip the extension, you might say      rename 's/\e.bak$//' *.bak  To translate uppercase names to lower, you'd use      rename 'y/A-Z/a-z/' *  =head1 OPTIONS      -h --help      brief help message     -n --dryrun    show what would be renamed, but does not rename anything     -v --verbose   be verbose during operation  =head1 AUTHOR  Eric Engstrom - email him as specified in the comments of this script Seriously adapted from a previous incarnation by Father (Larry) Wall.  =head1 SEE ALSO  mv(1), perl(1), perlre(1) /code/pre  (*) Yet Another Command Line Batch File Renamer...  <answer255266> For Sublime Text user, there is a package called SublimeFileBrowser that basically is dired in Sublime Text plus the all keyboard cursor movements trick of Sublime Text. You can pair with Text-Pastry or any other package that could help you manipulate the text easily.  <comment229854> I'm aware of that feature, and it's absolutely not what I'm looking for. <comment229855> Thanks, but as with the other answer, totally not the interface I'm looking for. <comment229864> Could you please give us the name of the Windows app? It's possible that there are already pages online full of people asking about a Mac version of that app by name. <comment229873> So when the program initially opened there was a new line separated list of the file names, and then after you modified them the program knew which line the original file was on and renamed it to whatever the corresponding line now reads? <comment229898> Do you have a screenshot of the Windows application, so people understand what to look for? <comment230020> I've been trying to dig up the Windows version, but have so far come up blank. It has been a good 6-7 years. <comment230021> @forquare, that's generally correct, except you browsed to the folder containing the files to be renamed after opening the program, although (for me) it doesn't matter how/when the program discovers the files. The renaming interface (of a big textarea) is the key. <comment230024> Wait, I just found the original Windows version! $google_fu++; It's called Oscar's Renamer: http://www.mediachance.com/free/renamer.htm . No OSX version as far as I can tell. <comment230407> OS X comes with emacs for the terminal - GUI versions are also easily installed
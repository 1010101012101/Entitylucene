Unable to create a working .app executable using Platypus <body> I'm new to OS X and I'm trying to create an application wrapper for a shell script that starts a media server(Red5)  I'm trying to wrap the Red5 server starter script (codered5.sh/code) into an code.app/code executable using Platypus.  The Platypus Documentation says that     You can add a list of files to be copied into the Resources folder of   your application bundle. These files can then be used by your script.   The default current working directory of your script will be this   folder, so you should be able to access them directly from your   script's CWD.   When executed normally from the terminal (is using code./red5.sh/code) the server starts up fine, but when I create the code.app/code file (after having set the script's CWD in the "Files to be bundled" field of Platypus, the resulting code.app/code file doesn't run when double clicked upon.  It gives the following error  codeError: Could not find or load main class/code  I'm not sure what I'm doing wrong, but I think it's something to do with the bundling the right directory.  <answer121809> I had a similar problem trying to run a Java-based web application server.  For me, the problem turned out to be that my environment variables (in particular, codeJAVA_HOME/code) weren't being set, which is because the instance of Bash (or whichever shell you have it use) doesn't start as a login shell OR an interactive shell, so your profile script (e.g. code~/.profile/code, code~/.bashrc/code, etc.) doesn't run automatically.  For me, the solution was to add the following to my script:  precodesource ~/.profile /code/pre  The codesource/code command causes the commands in code~/.profile/code to be executed in the current shell; this way the environment variables being set by that script will be available to the instance of Bash that platypus starts.  Note that it's important that you don't just execute the profile file as a shell script itself; that will cause it to run in its own shell, which will exit immediately afterward; any variables it sets will cease to exist as soon as it exits. This is why we have to use the source command.  As an alternative, you can just set the necessary environment variables directly in your script.  Hope this helps! 
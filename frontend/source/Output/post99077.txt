How to set gcc 4.8 as default gcc compiler <body> I recently installed codegcc 4.8/code using codebrew/code on codeOSX 10.7.5 (Lion)/code. I can now compile using codegcc 4.8/code by using  precodeg++-4.8 some_file.c /code/pre  or using the default codegcc 4.2/code by using  precodeg++ some_file.c /code/pre  I want to use codegcc 4.8/code as the default compiler for codeXcode/code and if I type codegcc/code at the terminal. I suppose I must alter codegcc-related/code links within codedirname $(which gcc)/code.  When I do  precodels -al $(dirname $(which gcc)) | grep 'gcc\|g++\|c++' /code/pre  I get the following:  precodelrwxr-xr-x     1 root   wheel         7 Jul 31 12:17 c++ -&gt; clang++ -rwxr-xr-x     1 root   wheel    909360 Nov 18  2011 c++filt lrwxr-xr-x     1 root   wheel         5 Jul 31 12:17 clang++ -&gt; clang lrwxr-xr-x     1 root   wheel        12 Jul 31 12:17 g++ -&gt; llvm-g++-4.2 lrwxr-xr-x     1 root   wheel        12 Jul 31 12:17 gcc -&gt; llvm-gcc-4.2 lrwxr-xr-x     1 root   wheel        28 Jul 31 12:17 gcov-4.2 -&gt; ../llvm-gcc-4.2/bin/gcov-4.2 lrwxr-xr-x     1 root   wheel        52 Jul 31 12:17 i686-apple-darwin11-llvm-g++-4.2 -&gt; ../llvm-gcc-4.2/bin/i686-apple-darwin11-llvm-g++-4.2 lrwxr-xr-x     1 root   wheel        52 Jul 31 12:17 i686-apple-darwin11-llvm-gcc-4.2 -&gt; ../llvm-gcc-4.2/bin/i686-apple-darwin11-llvm-gcc-4.2 lrwxr-xr-x     1 root   wheel        32 Jul 31 12:17 llvm-cpp-4.2 -&gt; ../llvm-gcc-4.2/bin/llvm-cpp-4.2 lrwxr-xr-x     1 root   wheel        32 Jul 31 12:17 llvm-g++ -&gt; ../llvm-gcc-4.2/bin/llvm-g++-4.2 lrwxr-xr-x     1 root   wheel        32 Jul 31 12:17 llvm-g++-4.2 -&gt; ../llvm-gcc-4.2/bin/llvm-g++-4.2 lrwxr-xr-x     1 root   wheel        32 Jul 31 12:17 llvm-gcc -&gt; ../llvm-gcc-4.2/bin/llvm-gcc-4.2 lrwxr-xr-x     1 root   wheel        32 Jul 31 12:17 llvm-gcc-4.2 -&gt; ../llvm-gcc-4.2/bin/llvm-gcc-4.2 /code/pre  When I run: codewhich gcc-4.8/code I get code/usr/local/bin/gcc-4.8/code.  Steps to get this done would be very helpful.  Please and thank you.  <answer99078> Assuming you're using bash (it's the default), then you can add /usr/local/bin as your top priority in PATH like this:  precodeecho "PATH=\"/usr/local/bin:$PATH\"" &gt;&gt; ~/.bash_profile /code/pre  This will ensure that /usr/local/bin is checked before all other areas of your path. Then just start a new terminal session to load the new variable.   Another way to do this:   precode  cd /usr/bin   rm cc gcc c++ g++   ln -s /usr/local/bin/gcc-4.8 cc   ln -s /usr/local/bin/gcc-4.8 gcc   ln -s /usr/local/bin/c++-4.8 c++   ln -s /usr/local/bin/g++-4.8 g++ /code/pre  <answer99088> Let's assume your actual shell initialization is done through code~/.profile/code, then you will have to modify it so as to put code/usr/local/bin/code ahead of any other PATH component where codegcc/code and all its associated binary are.  Here is the way to perform this clean modification:  pre cd  _shell_init=`egrep '(^| )PATH' .profile 2/dev/null`  if [ "${_shell_init}" = "" ] ; then     # PATH isn't defined in .profile     # install there the first relative definition of PATH     echo 'PATH=/usr/local/bin:${PATH} export PATH' .profile     . .profile     exec ${SHELL} else     # remove all occurences of /usr/local/bin wherever they might be     # set into PATH, and insert it ahead of all other components     sed -E -e '/(^| )PATH=/s,:/usr/local/bin,,' \         -e '/(^| )PATH=/s,/usr/local/bin:,,' \         -e '/(^| )PATH=/s,,&/usr/local/bin:,' .profile .profile.new     mv .profile.new .profile     . .profile     exec ${SHELL} fi /pre  Beware: if your code~/.profile/code is already structured, this shell script will have to be manually tuned to fit correct PATH definition in the right place.  <answer99157> Thanks to you all for your help. I ended up just creating aliases within code~/.bash_profile/code as follows:  precodealias gcc='gcc-4.8' alias cc='gcc-4.8' alias g++='g++-4.8' alias c++='c++-4.8' /code/pre  This is basically what Lyken suggested but easier  to undo if necessary.   strongEDIT/strong  If codePATH/code is set such that code/usr/local/bin/code (where brew puts the link to codegcc 4.8/code) appears before appears code/usr/bin/code (where codegcc/code is linked by default), then creating links as Lyken suggested within code/usr/local/bin/code should theoretically work but doesn't for some reason -- failing with a linker error.  strongI'm not sure of etiquette here so should I just edit Lyken's answer since it's basically a variant of this? Someone please comment./strong  <answer120715> I use to gcc-4.8:  precodeexport CC=/usr/local/bin/gcc  export CXX=/usr/local/bin/g++  export CPP=/usr/local/bin/cpp  export LD=/usr/local/bin/gcc  alias c++=/usr/local/bin/c++  alias g++=/usr/local/bin/g++  alias gcc=/usr/local/bin/gcc  alias cpp=/usr/local/bin/cpp  alias ld=/usr/local/bin/gcc  alias cc=/usr/local/bin/gcc /code/pre  and back to apple gcc:  precodeexport CC=/usr/bin/gcc  export CXX=/usr/bin/g++  export CPP=/usr/bin/cpp  export LD=/usr/bin/ld  alias c++=/usr/bin/c++  alias g++=/usr/bin/g++  alias gcc=/usr/bin/gcc  alias cpp=/usr/bin/cpp  alias cc=/usr/bin/gcc  alias ld=/usr/bin/ld /code/pre  or put it in file and then: codesource &lt;file&gt;/code  <answer166907> It is assumed the making alias or linking to different gcc binaries will make them use their own include before the default system include folder.  <comment116447> My think path already contains  `usr/local/bin`. `echo $PATH` reveals:      /opt/local/bin:/opt/local/sbin:/opt/local/include:/usr/local/mysql/bin:/usr/bin/bjam:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin:/usr/local/go/bin:/usr/texbin <comment116448> Added another option <comment116449> Any reason not to use the superior llvm clang? <comment116450> Yes it contains it but it is after /usr/bin so it doesn't get read first. PATH is sequential. <comment116459> Not specifically. What's the benefit of llvm clang compared to vanilla gcc ? <comment116464> → quine: I think that `/opt/local/include` is an error. This kind of directory shouldn't be included within your PATH. <comment116474> While being faster it also offers meaningful warnings, a really precious feature gcc lacks entirely. <comment116537> @danielAzuelos I think you're right. It seems `MacPorts` added it when I installed `MacPorts`. That directory doesn't even exist! <comment116540> I see. Is `clang 3.3` the equivalent to `gcc 4.8`? I believe I can `brew install` it as well. <comment116555> Both options seem to not work for me. I moved `/usr/local/bin` to appear 1st in `PATH` -- which had no effect -- calling `gcc` still looks at `gcc 4.2`.I then manually created the symlinks, but when I open a new terminal window and `g++` or (`cc|c++|gcc`) all are not found. Strange. Thanks for your help <comment116565> First question to ask is re clang why can't you use the clang supplied with Xcode rather than gcc-4.8 - then we could answer of clang3.3 would work <comment116569> → quine: for the PATH modification to be effective, you have to read your .bash_profile within your actual shell: `. ~/.bash_profile`. <comment116572> I wouldn't advise to play within `/usr/bin` of any Unix (which MacOS X is)… unless you're a specialist working on sources of a new version of the next Unix version ☺. <comment116573> You might have to change this for any new binary you will install within `/usr/local/bin`. You may also have other binaries installed and hidden because of the bad positionning of `/usr/local/bin` within your PATH. Please consider once more my answer,it is attacking your real problem once, correctly and forever. <comment116590> This is certainly **perfect** for modifying `PATH` so that `/usr/local/bin` is seen first. This will likely save me headaches in the future. I wish I could +1 you.   My issue though is that `gcc` is still linked to `gcc 4.2` and not `gcc 4.8` because there is no symlink for `gcc - gcc-4.8` in `/usr/local/bin`. I would still need to either alias `gcc` as `gcc-4.8` within `~/.profile` or symlink (`ln -s gcc-4.8 gcc`) in `/usr/local/bin` after updating `PATH` with your script. Ye? <comment116591> Right. I did mention earlier to Lyken that I altered `PATH` and put `/usr/local/bin` before all. I concede that your statement is correct & that I needed to alter `PATH`, but (in my case -- i.e default `brew` install of `gcc 4.8`) I still will not call `gcc 4.8` by default when I call `gcc` because there is no symlink between the two by default. I had to manually create it as I did above. <comment116601> I'd say its different enough to be its own answer, I would mark your answer as solved though. <comment116604> Ok -- thanks Lyken. I will as soon as the system allows me to do so. <comment116706> → quine: so as to give suited answers with your real compiling environment, could you include the following details within your original question? `type gcc` `type g++` `echo ${PATH}`. Even if you already exchanged them within comments, collect all the data of your problem within your original question. This is the best place to read or verify them. <comment116707> I'm surprised `brew` didn't add the right symbolic links. Did you read this answer on the same subject: http://apple.stackexchange.com/a/38247/22003 ? <comment294081> I'm trying to do this and i am having permission issues inspite of me using sudo. Someone please help?
Source a script from a URL in bash <body> I gather this should work in bash:  precodesource &lt;(curl -s https://example.com/script.sh) /code/pre  or  precodebash &lt;(curl -s https://example.com/script.sh) /code/pre  or  precodecurl -s https://example.com/script.sh | source /dev/stdin /code/pre  But it's not working for me. Downloading to a file, sourcing the file and then removing the file emdoes/em work. I'm curious as to why none of the one liners are working though.  <answer80035> I don´t know what you like to do but if you like to download a script (or whatever) use.  precodecurl -s -L https://example.com/script.sh -o script.sh /code/pre  for more details see   precodeman curl  /code/pre  in terminal. -s silent,  -L location of target including redirect to a new target,  -o output file, if you don´t use it then curl uses the filename on the target (-o is often very useful).  To run the script use  precode./script.sh /code/pre  <answer80199> You are correct that your two first on-liners emshould/em be working according to bash process substitution semantics. In my testing (codebash/code 3.2 on OS X 10.8.2), the second one does, while the first one does not.   In the case of your first one-liner, it looks like you may be running into one of the limitations of process substitution. Quoting the Wikipedia page on process substitution:     Process substitution has some limitations: the “files” created are not seekable, which means the process reading or writing to the file cannot perform random access; it must read or write once from start to finish. Programs that explicitly check the type of a file before opening it may refuse to work with process substitution, because the “file” resulting from process substitution is not a regular file.   – if codesource/code is a command that has difficulties with this (at least in codebash/code 3.2), that would explain its failure to work with process substitution.  The second one-liner possibly just looks like it fails because it executes the code in a subshell rather than sourcing it. If you are expecting it to set aliases and functions, this won’t work, as these do not carry over to the parent shell when defined in a subshell.  The third one-liner doesn’t work because codesource/code does not process codestdin/code – only files (see bash man page).  <comment92310> What do you mean, it doesn't work? Are you trying to execute this in a bash script or..? <comment92322> I'm trying to source a downloaded script into my bash environment. <comment92329> As long, as you don´t answer what you had done and what you like to do noone can answer this. Have you downloaded it ? Have you got an error from curl ? If you downloaded the script as described above, make it executable using      `chmode +x FILENAME`  and copy it somewhere in your PATH      `sudo mv FILENAME /usr/local/bin`  then you can run it in terminal.  Or whatelse you mean ??? <comment92333> Do you get an error message of some kind? <comment92334> @nawi-at-mac The beauty of the `()` construct is that you don't need to create a temporary file manually, so I understand why the asker wants to use it. But without additional information about the specific error/failure it will be difficult to answer the question. <comment92339> There is no error. It doesn't have to be executable to source it, nor does it have to be in the PATH. <comment92340> I want to put it in my ~/.bashrc, I've tried running it at a bash prompt too. No error message. Just the aliases within it aren't available, the bash completion of SSH hostnames it sets up doesn't work, etc. <comment92401> Of course there is no error message, as the `-s` switch puts `curl` into silent mode. Try running it with the `-sS` switch instead and see what failure message you get. <comment92403> There's nothing wrong with the curl. As in the original post, a three line separate download, source and then removal of the temporary file works. <comment92404> Yeah, my bad, sorry for not reading the post carefully enough. Actually, the issue seems to be the fact `source` only reads from *files*, not from stdin – according to the bash man page, that is. <comment92439> The () construct uses a special file; /dev/fd/63. <comment92442> That is not an ordinary file, that is a file descriptor, like stdin, stderr and stdout. You can’t use it directly in stead of a file because you are *piping* its contents into `source`, not passing it as a file. Try using a temp file created with `mktemp` (which is available on OS X and will mitigate security issues when executing code from a file not under your control; also, you can and should leave cleaning it to the OS’ flushing of `/tmp`). <comment92448> Surely that first line _is_ passing it as a file, not piping it? <comment92458> Hmm, reading up on process substitution, yeah, looks like that is what should happen – seems I’m mistaken. The only thing I can think of is that you are running into an asynchronous delay issue, as process substitution puts its job into the background. <comment92459> In my defence, [even the TLDP is confused when it comes to the semantics of process substitution](http://tldp.org/LDP/abs/html/process-sub.html). After scouring Stack Overflow, it almost looks like I could be accidentally half right: [some programs apparently do not handle the fact well that the “file” they get passed is a file descriptor or named pipe](http://stackoverflow.com/questions/4274171/do-some-programs-not-accept-process-substitution-for-input-files) (underlying implementation is OS dependent). `source` might be one of them. <comment92518> This answer is missing the point of OP’s question, which stated clearly that a download and source sequence works, but is asking why sourcing the code *via process substitution* does not work. Also note OP intends to *source* the code (run it in the current shell context), not execute it as a script (which happens in a subshell). <comment92524> Well, it works ok for me (at least the second one) so I suspect something else being amiss for the asker. <comment92526> @patrix Yeah, that is difficult to diagnose without knowing what the sourced file is meant to do. Judging from the comment threads, it is meant to setup aliases and completion functions, which won’t carry over from a subshell, of course. Amended my wording to reflect that. <comment92595> I doubt it's that process substitution doesn't work given the accepted answer here: http://superuser.com/questions/255260/bash-source-from-url <comment92600> I strongly doubt that accepted answer has actually been tested. On my OS X box, `cat (curl http://url.tld/file.sh)` outputs file contents, `cp (curl http://url.tld/file.sh) /new/dest` copies the  file, and `source (curl http://url.tld/file.sh)` fails. <comment92602> … or maybe different `bash` versions’ `source` builtin react differently to being passed a file descriptor through process substitution (AFAIK Ubuntu has been using `bash` 4 since 2010). Rephrased my answer to narrow down the specifics. <comment92603> … and for completeness’ sake, I’ll add that the issue is demonstrably in the source from process substitution part. Using the (admittedly contrived) `source (echo 'TESTVAR="test value"')` fails too, while `cat`ing the same process substitution works, as does sourcing the output of that `cat` call (see what I did there?).
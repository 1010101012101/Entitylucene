How to use the programming calculator in OS X? <body> I'm trying to make the best out of the programming calculator in OS X, but I don't know these functions:  ul libyte flip/li liword flip/li liX&lt; liXY/li liRoL/RoR (are these just sll/srl?)/li /ul  Also is it possible to perform a two's complement on a narrower range i.e. 16 bits instead of 64 bits?  <answer162984> ul licodebyte flip/code / codeword flip/code - not sure about these/li licodeX&lt;&lt;Y/code / codeX&gt;&gt;Y/code - bitshift X to the left/right Y times/li licodeRoL/code / codeRoR/code - Rotate left/right, similar to bitshifing, except the bits wrap around in a circular fashion/li /ul  <answer163001> strongFlipping/strong  Byte flip and word flip will swap bytes or words. Technically it works like this:  Let's say we have a two byte value (hexadecimal): 0x3344  The number consists of two bytes, the lower one is 0x44, and the higher one is 0x33, so let's put them into two imaginary cells of one byte size:  precode[33][44] /code/pre  Now, flip the cells:  precode[44][33] /code/pre  Therefore byte flipped value will be 0x4433  Same way with words, considering word consists of two bytes. Let's assume we have a two-word value: 0x12345678  Split them into two imaginary cells, now containing one word (2 bytes) each:  precode[1234][5678] /code/pre  Now, flip the cells:  precode[5678][1234] /code/pre  Therefore word flipped value will be 0x56781234  strongShifting/strong  Shifting shifts values bitwise. What does it mean?  Let's take a very simple decimal number: 5 Then, let's convert it to its binary representation: 101 Then, let's shift it left by 1:  precode[101] &lt;&lt; [1010] /code/pre  We basically moved the whole binary sequence left one position and filled the empty space with zero.  Now do the same, but with shifting right:  precode[101] &gt;&gt; [010] /code/pre  our number is 10 now. The lower 1 is lost by shifting right. The zero on the left is just for display and has no value.  // Technically there's a CPU flag which indicates that the bit was lost, but it is not relevant to the calculator.  strongRotating/strong  Rotating works absolutely same as shifting with one exception: bits are never lost. So, we take the same decimal value 5 and its binary representation 101. Then we rotate it right within a byte:  precode[00000101] ROR [10000010] /code/pre  As you can see, the [1] which was lost on the shifting right was carried on the beginning of our byte.  Same with shifting left, let's perform series of rotations by 1 bit left until we carry one bit:  precode[00000101] ROL [00001010] [00001010] ROL [00010100] [00010100] ROL [00101000] [00101000] ROL [01010000] [01010000] ROL [10100000] [10100000] ROL [01000001] /code/pre  <comment190735> You can hover over the calculator keys to see a short description of what they do. Also, watch the binary values to see a bit better what's actually going on. <comment302752> This doesn't answer the question wrt to how to accomplish this with the Calculator app itself. Nor does it address the 2's compliment question. The question still begs an answer like 'press x button then y button, etc.' Either the question is not formulated correctly or this, the currently accepted answer, doesn't address the question directly. <comment311062> Word flipping is another way of saying endian swapping btw. <comment311064> In order to limit the range of 2's or 1's compliment, simply AND it with FFFF for 16 bits, FF for 8, etc. MAKE SURE you keep it in hex format while doing those operations though, otherwise it messes it up. <comment311415> @MarcusJ or rather the opposite. Flipping is a broad, generic term, endian swapping is narrowed down to the particular application.
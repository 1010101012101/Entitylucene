Terminal - how to restart session after inadvertently exiting? <body> Sometimes I inadvertently exit from a Terminal session (usually because I think I'm connected to a remote system, when I'm not), so I get to this point:  img src="https://i.stack.imgur.com/5BZXP.png" alt="enter image description here"  How I can I restart the session at this point ? I don't want to close the window or tab because I have a bunch of tabs all set up for my normal workflow, so I just want to get the session in the current tab going again (i.e. get back to a bash prompt).  The only solution I've found so far is to quit Terminal completely and open it again, but that is far from ideal as it obviously interrupts anything else I'm doing in other Terminal windows/tabs.  <answer219997> At this point, there's no way to get the tab back. The terminal session is closed, and it no longer has a TTY. There's just no way to reference the tab in order to do anything clever. I'd suggest adding this function to your .bashrc or .profile so that you won't have the issue in the future:  precodeexit() {     read -t5 -n1 -p "Do you really wish to exit? [yN] " should_exit || should_exit=y     case $should_exit in         [Yy] ) builtin exit $1 ;;         * ) printf "\n" ;;     esac } /code/pre  or, for those of us who use the Z Shell (add it to your .zshrc):  precodeexit() {     if read -t5 -q should_exit\?"Do you really wish to exit? [yN] "; then         builtin exit $1     fi } /code/pre  It's a nice little barrier between you and that annoying exit command! Lord knows I've done the same thing many times in the past.  <comment266143> Thanks - that's a good suggestion. I wonder if it's possible to go one step further and add a time-out, so that the logout still happens after, say, 5 seconds, if the user doesn't respond?... <comment266144> You got it! Now, after 5 seconds (the `-t 5` option), the read command will fail, which triggers the exit command following it. <comment266145> Excellent - thanks - I wish I could give you two up-votes! ;-) <comment266203> Linux (KDE/Gnome) terminal emulators let you re-order tabs.  So if you start a new tab, you can move it over to replace the one you closed.  Doesn't OS X's terminal have that?  (I'm not a mac person, I just saw this in "hot network questions".)  I also like to use GNU screen to multiplex a lot of shell sessions, rather than tabs in a terminal window.  I have another tab with a screen session on another computer.  I sometimes open another terminal if I want to see two things at once, but normally I like having my shells numbered, the way screen does, rather than just there <comment266204> Anyway, I'd suggest screen (or tmux if you don't already know screen) for keeping multiple shells on the same host in one GUI tab.  This two-level hierarchy of tabs / screen-windows allows having lots of stuff open, without losing track of what's where.  Also, like I said, having numbers for the different shells makes it easy to remember which number to swap to (`^t 8` for example) for a given context, instead of visually counting which tab to click or (or how many ctrl-pgup to hit). <comment266205> Yes, I just tried that and it seems you can slide the tabs around - I guess I like to keep the original tabs though, as they have large scrollback buffers which get preserved across launches/reboots, which can sometimes be a life-saver. I generally have two windows, one for remote sessions and one for local sessions, with around three tabs in each, and I rely on "muscle memory" to know the purpose of each tab. <comment266209> screen and tmux both have configurable scrollback inside each screen-window.  I don't remember seeing anything about keeping scrollback on disk for persistence across reboots, though!  That's neat.  Three tabs is easy enough to keep track of mentally.  I usually have something like 10 on my home desktop, since I do nearly everything from the command line, not a GUI file browser.  (playing videos / audiobooks, etc.)  I usually have about three shells `cd`ed to source code when I'm working on code, though, so that matches up with your usage. <comment266211> Anyway, dragging tabs around should make it easy to recover from accidentally closing a tab, since you can put it right back where it goes. <comment266213> Thanks for the ideas - I may have to play with screen/tmux at some point - I know they are popular on Linux, and although OS X is my preferred environment I do have to spend about 10% of my working life on Linux, so cross-platform solutions are good. <comment266216> I don't think a lot of people use them locally, for local shell sessions inside a single terminal emulator tab.  IDK, maybe other old-school command-line junkies do it, too.  The main use-case is after `ssh`ing somewhere.  I just got used to using screen, and use it locally as well as on remote sessions.  As I understand it, if you don't already have `screen` in your muscle-memory, learn tmux because screen is old and crufty.  I could probably switch to `tmux` and config it to use all the same keybinds as I use for `screen`, but screen still works fine for me. <comment266234> @PaulR: You don't need to alias `exit` if you're using Bash. You can put your script in [`~/.bash_logout`](http://www.gnu.org/software/bash/manual/bash.html#Bash-Startup-Files). <comment266272> @DennisWilliamson: interesting idea, but I'm not sure how you'd cancel the logout from within `.bash_logout` ? <comment266377> @PaulR: Oops. I failed to consider that! For completeness, you should also alias `logout` and set `IGNOREEOF` greater than 1 (or rebind ^D). <comment338461> @WilliamTFroggard I applied this on my machine and it clashed with the command `source activate myenv` for instance. At line 46, the `activate` script calls `exit 1` and the error "unexpected token `1'" is thrown, since alias don't accept arguments. Beside this, it seems a very nice solution, but there may be other unexpected side effects... <comment338551> Scripts should be using "builtin exit" to prevent this sort of thing anyway. Which reminds me... <comment338556> It's now a function, so your script should work fine.
Disk image of OS + Recovery partition? <body> I'm working with multiple OS X versions frequently and I'd like to have an image which contains a particular OS version's system partition and its recovery partition. Is this possible? (the disk where these partitions are, contains several other partitions which I don't want, so full-disk image is not an option)  I'm guessing this cannot be done as a single-step process, so I've already created an appropriately-sized sparsebundle image with GPT layout:  codehdiutil create -size 35g -layout GPTSPUD -type SPARSEBUNDLE /path/to/new_image.dmg/code  The next step would be to copy the relevant partition onto this image, but I don't know how to do this. My Linux experience tells me the partitioning utility should be the place to look for this, but I don't see anything in codediskutil/code's manual which looks like it does what I want.  Hints/ideas?  <answer230783> h1Starting from a working setup/h1  A working setup is disk, or full-disk image with multiple partitions (emFDI/em hereafter), where the OS and its recovery partition is known to be correct, most likely because it was created by the OS Installer. As mentioned in the comment, codeasr/code is enough to handle copying both partitions in this case.  Assuming the source OS and recovery partitions are codedisk3s11/code and codedisk3s12/code, respectively, I recommend the following procedure:  ol liShrink the OS partition to its minimum size. This isn't necessary, but I suggest doing it when you can never be sure if the user's target partition will be as big as the one you're using.  precode$ diskutil resizeVolume disk3s11 limits  ... (minimum size will be mentioned here) ...  $ diskutil resizeVolume disk3s11 24GB /code/pre/li liCreate appropriately-sized temporary FDI as a sparsebundle. strongRemember, the Recovery takes extra 650 MB over the system partition, and EFI takes emanother/em 210 MB./strong So I'll add an extra GB to the size used in step 1 just to be safe. The catch here is, codehdiudil/code support strongonly binary/strong prefixes (1024 for codek/code, etc.). In this example, 25 GB = 23.29 GiB.  precode$ hdiutil create -layout GPTSPUD -type SPARSEBUNDLE -size 23.29g /tmp/temp_FDI  created: /tmp/temp_FDI.sparsebundle /code/pre/li liAttach the image without mounting it (it would fail, since the partition was not formatted). Take note of the code/dev//code entry for the Apple_HFS partition.  precode$ hdiutil attach /tmp/temp_FDI.sparsebundle -nomount  /dev/disk5              GUID_partition_scheme            /dev/disk5s1            EFI                              /dev/disk5s2            Apple_HFS /code/pre/li liRun codeasr/code with the image's empty partition as the target. You'll have to enter full path to code/dev/.../code entries. Also, since the source is a physical disk, elevated privileges are necessary. You should see the tool finish with strong2 rows/strong of emRestoring.../em progress.  precode$ sudo asr restore --source /dev/disk3s11 --target /dev/disk5s2 --erase  --noverify      Validating target...done     Validating source...done     Erase contents of /dev/disk5s2 ()? [ny]: y     Validating sizes...done     Restoring  ....10....20....30....40....50....60....70....80....90....100     Restoring  ....10....20....30....40....50....60....70....80....90....100 /code/pre/li liFinally, create a compressed read-only image from the sparsebundle. Use the sparsebundle's "whole disk" code/dev//code entry (code/dev/disk5/code).  precode$ hdiutil create -format ULFO -srcdevice /dev/disk5 -o /tmp/OS_X_10.11-combined_FDI2.dmg  ... Elapsed Time:  2m 33.743s File size: 8000565446 bytes, Checksum: CRC32 $5D496986 Sectors processed: 48842670, 38032196 compressed Speed: 120.8Mbytes/sec Savings: 68.0% created: /tmp/OS_X_10.11-combined_FDI2.dmg  /code/pre  You may wish to use codeUDZO/code format if you need your image to be compatible with older versions of OS X and their respective Recovery environments (ULFO was only introduced in 10.11)./li /ol  hr  h1Working from the ground up/h1  It is possible to assemble a "working setup" from single-partition images (images which don't have partition table, and therefore no hint for codeasr/code that a particular partition is a Recovery; emSPI/em hereafter). The procedure is not for the faint of heart.  I'm going to assume that I have a compressed, read-only SPIs of both the system partition, and the recovery partition. Shrinking the partitions to minimum size is a whole another can of worms, where using a full-blown codeUDRW/code image seems unavoidable. Feel free to suggest a simpler solution.  ol liWith that in mind, do a pre-shrink of the system partition image. Readonly image can only be shrunk with a shadow.  precode$ hdiutil resize -sectors min  OS_X_10.11-system.dmg -shadow /tmp/pre-shrink.shadow /code/pre/li liCheck the image size, then attach it  precode$ hdiutil imageinfo OS_X_10.11-system.dmg -shadow /tmp/pre-shrink.shadow  ...     Total Bytes: 27648868352  $ hdiutil attach OS_X_10.11-system.dmg -shadow /tmp/pre-shrink.shadow -nomount  ... /dev/disk7 /code/pre/li /ol  The size is about 27.65 GB.  ol liCreate a sparse image big enough to hold the system and recovery partitions in full size - AFAICT, SPIs cannot be resized and that must be done inside an FDI. With extra space needed for EFI and recovery, we'll need 28.6 GB = 26.64 GiB.  precode$ hdiutil create -layout GPTSPUD -type SPARSEBUNDLE -size 26.64g /tmp/temp_FDI $ hdiutil attach /tmp/temp_FDI.sparsebundle -nomount /dev/disk5              GUID_partition_scheme            /dev/disk5s1            EFI                              /dev/disk5s2            Apple_HFS    /code/pre/li liDo an codeasr/code restore from the system SPI's code/dev//code node into the sparsebundle's data partition.  precode$ asr restore --source /dev/disk7 --target /dev/disk5s2 --erase --noverify /code/pre/li liNow, check the minimum size of the partition using codediskutil/code. Then use coderesizeVolume/code to shrink the partition emand/em create the recovery partition in a single step.  precode$ diskutil mount disk5s2 $ diskutil resizeVolume disk5s2 limits  ... (minimum size will be mentioned here) ...  $ diskutil resizeVolume disk5s2 24GB JHFS+ Recovery %recovery% Free\ Space dummy 1m /code/pre/li liRestore the recovery SPI into the new  partition on the FDI. It will probably get mounted, so unmount it. You can work with the image directly.  precode$ asr restoreexact --source /path/to/OS_X_10.11-recovery.dmg --target /dev/disk5s3 --erase --noverify  ... $ diskutil umount disk5s3 /code/pre/li liHere's the tricky bit - dump the partition table using the codegpt/code utility, taking note of the recovery partition's emstart/em and emsize/em values. Delete the record for the recovery partition, and re-add it with modified type GUID. You will know which record is for the recovery partition by the index ("disk5sstrong3/strong"), and by its size (shown here in 512 B sectors).  precode$ gpt show disk5 ...    47546784    1269536      3  GPT part - "Recovery" ... $ gpt remove -i 3 disk5 $ gpt add -b 47546784 -s 1269536 -t 426F6F74-0000-11AA-AA11-00306543ECAC disk5 /code/pre/li liOptional: I also recommend changing the partition name (set to "disk image" by default) to match the system partition's volume name.  precode$ gpt label -i 2 -l "OS X 10.11" disk5 /code/pre/li liNow, since codehdiutil resize/code doesn't work with sparsebundles the way we'd need, you can either:  ul liLeave it at that. It's not like the free space consumes anything. Continue with step 5 in the emWorking setup/em scenario./li liConvert the temp_FDI.sparsebundle image to UDRW, and try to properly shrink that. I haven't tested that and the need to write out the entire size image for this step makes the whole exercise pointless./li liTreat the sparsebundle existing at this point as a disk with optimally-shrunk system, and perform the first scenario on it, skipping step 1. Ie. create emanother/em sparsebundle image, and run codeasr/code, which will this time copy both partitions into the new image, and convert emthat/em to ULFO image./li /ul/li /ol  <comment281741> After going through [Apple's KB](https://support.apple.com/en-us/HT202841) and [this post](http://www.dmitry-dulepov.com/2011/09/how-to-create-mac-os-x-lion-recovery.html), these are my observations:     - The extra partitions are added in a separate step by using `diskutil`'s `resizeVolume` command, which can add partitions in the free space after the partition being worked on.     - The Recovery partition differs only in its GUID type in the GPT table. Using the `gpt` command, removing the partition and re-adding it with proper GUID achieves the desired state. <comment281744> Also interesting, `asr`, at least the version in OS X 10.11, will restore both the system partition _and_ the recovery immediately following. If one is starting with a disk which already has both OS and partition, then `asr` should be enough to do everything.   So really, the real issue is that the GUI Disk Utility creates images of partitions and single-filesystem images which don't hold the accompanying recovery partition.
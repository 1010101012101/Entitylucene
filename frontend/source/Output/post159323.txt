When Screen Sharing, why does the remote screen continually go black? <body> As an ongoing issue (for at least the past three major OS X versions), I find that when trying to remote to another machine using Screen Sharing, the remote screen gets painted completely black. Moving the mouse will result in the area immediately under the pointer being redrawn correctly, and dragging a window (in the remote session) off screen then back on will redraw that window. Sometimes other areas of the screen will redraw themselves (usually when there is an actual change), but most the screen simply remains black, sometimes even repainting back to full black again.  Network connectivity doesn't seem to be a factor; this happens both on a fast LAN and across the Internet with 400-500ms latency. Hardware doesn't seem a factor either; using a range of Mac Minis and Macbooks. Screen sharing sometimes initiated via Remote Desktop, sometimes just clicking on Share Screen in the Finder. While I can work around this glitch (I tend to just SSH in for maintenance), I thought I'd see if anyone out there has any suggestions!  <answer159488> I have had similar issues with screen sharing, ARD, and Windows RD. I have noticed this happening on all systems(Win, OSX, Linux) whenever the RAM on the Desktop you are accessing gets close to be full. The only solution I have found is to close the connection and reconnect.   <answer225354> Does this happen when you have been emsome/em time without using the remote computer? I mean, could it be the remote system putting the monitor to sleep?   It surely happens to me all the time. I have a 15 minutes sleep interval setup and I tend to forget I have the connection active. After this period of time the shared screen goes black.  <answer251435> I'd second the idea that it may be a RAM issue -- I'm noticing that it happens particularly when:  ul liI've got huge uptime on the remote system (so... memory leaks, cruft, have accumulated)/li liI switch apps on the remote system (loading things in and out of RAM)/li /ul  From practical standpoint, I've found that greping for the the screen sharing daemon and killing it forces the remote machine to respawn a new one that emisn't/em blacked out... but that doesn't last for long:  codeps aux | grep screensharingd/code  and then codesudo kill XXXX/code once I know what what procid I'm targeting. But that's a really short term solution (buys another 15-90 seconds, usually).  The finger the I would strongalso/strong point is at codemdutil/code, the spotlight indexer, which just gets out of control, especially on a system with a lot of large drives with a lot of small files. I've had best success clamping down on Spotlight (which, imho, isn't very useful) and restricting it by either marking most of my drives and directories "private".  emIf/em the remote system is tight on RAM, it emmay/em be because Spotlight is being a pig. 
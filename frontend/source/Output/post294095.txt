Does just 'rm -rf' delete any files? <body> I recently ran coderm -rf/code, not coderm  -rf //code, but nothing happened. I just get a result like this:  img src="https://i.stack.imgur.com/XnnzS.png" alt="Terminal"  I was scared because I am worried that it could've deleted some files, but it didn't. Just be sure, could this have deleted any files from my directory?  <answer294097> No, coderm -rf/code will not delete any files because you did not supply an argument to the command.  <answer294098> From the manual page:     rm removes each specified file.   This means you can use it to remove a list of files at once, e.g. with  precoderm -rf test1.txt test2.txt /code/pre  Fortunately, all you did was pass an emempty/em list of files, so it deleted nothing. Also, what @SolarMike says: if you don't know what a command does, strongdon't run it/strong. macOS is designed to 'hide' all dangerous (but potentially powerful) Unix operations from the end user.  <answer294141> No but if you want to delete Here's an example:  After you launch Terminal (in your /Applications/Utilities folder) type cd ~/Desktop to navigate to the Desktop directory. If you had a file here named MyFile.rtf that you never, ever wanted to see again, you could run this command:  precoderm MyFile.rtf /code/pre  When you press Return, the file will go poof! It will be gone, toast, history. You canâ€™t get it back.  <answer294148> For the layman/Linux/Unix newbie:   coderm/code alone doesn't do anything because you haven't told it what to get rid of.  codeman rm/code can explain most of this, if you understand it.  code-r/code means recursive, as in "include everything in subfolders"  code-f/code means force, "don't ask me to confirm" mode  coderm -rf/codestrong(DON'T DO THIS)/strongcode//code would say delete everything under code//code (the root folder) without checking (on recent macOS versions SIP will prevent you from removing macOS itself by this, but a lot of other stuff will get deleted)  coderm [some file name]/code would just delete that file.  coderm -rf /home/myuser/books/code would delete everything in codemyuser/code's codebooks/code folder, as well as the folder.  <comment371158> If you are not sure (certain 100%) then don't run a command. <comment371197> ya, running unknown terminal commands is a great way to see how you can destroy your environment. <comment371209> FYI the `-r` flag is unnecessary unless you are deleting directories recursively. If it's just files, `rm` is sufficient -- the `-f` is for force do it doesn't ask you "are you sure" for every file. <comment371214> Never type commands you do not understand.  All you needed was a . or a / and you're gonna be deleting a LOT of stuff. <comment371215> If you want to experiment with potentially dangerous commands, consider installing a virtual machine. <comment371217> Also, the -f leads to the usage message not being displayed when you use it wrongly. This is why there was no output at all when the OP ran `rm -rf`. Had they run 'rm -r' without specified files/directories, they would have gotten this usage message:  `JanNash ~ $ usage: rm [-f | -i] [-dPRrvW] file ...        unlink file` <comment371218> @Nelson `rm` doesn't work on `.` (if I read the specs correctly - can't try it right now). The rest is correct, but I edited out the swear word if you don't mind. <comment371236> Experiment all you want (as long as your data is safely backed up). It's only software and you can always reinstall it if anything goes wrong. Don't let anyone train you to be afraid of the computer. <comment371245> Absolutely do run a command if you're not certain 100%. There are only so many ways to learn, and actually running them is one of them. Caveat emptor and do have backups, obviously, and do use VMs and all that. But not running anything out of fear will do little to help you grow. It should be obvious when to be extra careful (i.e., `rm`), but for many/most other commands, e.g. all pipe-based text manipulation commands, just trying them often is the easiest/simplest you can do. Together with studying the man page, obviously. <comment371338> Nowadays you need to do `rm -rf / --no-preserve-root` to shoot your leg correctly. <comment371349> Interestingly, `rm -rf / xyz*` won't remove anything if there's no file matching "xyz*", because the shell will yield the error `/bin/rm: No match.` preventing `rm` from running at all. <comment371383> @Gallifreyan Is there ever a way to shoot your leg correctly? <comment371384> This one is said to work well. I know no other :) <comment371411> @barrycarter That is entirely not true - it will still attempt to delete `/`, it will just skip the nonexistent file `xyz*` (which will simply not expand because of the lack of a match). <comment371417> @fluffy When I do `touch a b; rm -f a b c*; ls` (in a new directory), I get `/bin/rm: No match.` followed by `a b`, showing the files aren't deleted. Try it yourself (in a safe environment) to confirm. This isn't a bug per se, but a case of the shell not even running a command. <comment371422> @barrycarter That behavior depends on your shell's globbing configuration. At least in bash's default on macOS, it does in fact delete `a` and `b` for me - even without specifying `-f`. Do the same commands with `echo rm -f a b c*` instead to see the actual behavior. <comment371435> In tcsh, `echo rm -f a b c*` yields `echo: No match.` <comment371443> @SolarMike why? life would be so boring otherwise and the learning experience is the best. <comment371446> @inf as part of an answer to another similar question I mentioned that at Uni (this was before GUI...) the students passed around the name of a "new" chat program - it was well done with instructions for user name and password and the name to enter at the command line was "rm -rf /". It caught many... :) <comment371447> @AnoE You suggest running the command even if you don't know what it does just for the learning experience - so, in your experience, do ALL users keep up to date current backups if it is their home machine? Most sensible companies have a backup outside the control of the user. The best part of your answer : "Caveat Emptor" ..... <comment371466> @Gallifreyan on macOS? https://pastebin.com/aVAsNcKC indicates otherwise <comment371475> @barrycarter and fluffy: What happens depends on if the shell variable *nonomatch* is set or not. <comment371476> Actually rm removes all reference of the file, doesn't scrub the hard drive of the file by overwriting each byte, if I'm understanding the documentation correctly. <comment371477> @SolarMike do all users keep up-to-date backups? No. _Should_ they? _Hell yes!_ Hard-drive failure or accidental overwrites can happen at any time, no need to type any commands for that (no matter if you know them 100% or not). <comment371482> `-f` flag is crucial here. Should you run `rm` whithout any arguments, it would print usage information. <comment371496> @SolarMike, check my comment again. "Absolutely do run a comman dif you're not certain 100%" is something else than "if you don't know what it does". And I have plenty of qualifications in the comment. Amongst others "Together with studying the man page, obviously." and "...when to be extra careful". I just object to the very blatant "If you are not sure (certain 100%) then don't run a command.". <comment371500> @AnoE It seems the 29 people who agreed with my comment outweigh yours with 1 so I leave it to the judges... <comment371503> You win, yes, @SolarMike. <comment371541> And because of `-f`, it's not an error to run it with no args.  `rm -r` will complain about "missing operand", but `-f` suppresses that, and also suppresses errors for files that don't exist.  (So for example a script could use `rm -rf /foo/bar/*` to empty a directory that might already be empty, without having to `2/dev/null` to squash errors.) <comment371542> @Gallifreyan: `find / -delete` should "work" (i.e. actually delete things, so don't run it.) <comment371544> @NoBugs But in fairness this is how all modern 'deletes' work, Windows included. If the delete feature is overwriting each byte then it'll be advertised as such (mainly because it takes longer and is unnecessary most of the time).
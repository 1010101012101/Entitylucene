Services bug that prematurely activates an application <body> I have discovered a very strange bug with Services.  To witness this behavior, please do the following:  ul liMake sure that Safari is in your Dock./li liOpen Automator. Create a new Service./li liSet the service to receive "no input" in "any application."/li liInsert a "Run AppleScript" action./li liPaste the following into the action:  precodeon run {input, parameters}      delay 5     display dialog "Hello"           tell application "Safari" to activate      return input end run /code/pre/li liSave the Service./li liClose the Service./li liRe-open the Service./li liAutomator should present you with a dialog asking, "Do you want to install the “ServiceName” service?" Click "Install."/li liWhen given the "Installation complete" dialog, click "Done."/li /ul  Now, run the Service. To do this, click on the current-application title in the top-left corner of the screen (the second item in the menu bar). Then click on the Service title.  You will notice that Safari will immediately open (evidenced by the black dot underneath its logo in the Dock). Safari will open strongbefore the 5 second delay and before the "Hello" dialog is displayed./strong  Placing the codeactivate/code statement in a subroutine does not fix the issue.  Can someone confirm that this is a bug? I am convinced that this is a bug with the Services feature because when you run the Service from within Automator (by clicking the "play" button in the top-right corner of the Automator window), the code runs correctly.  If this is a bug, does anyone have a workaround so that the application is not in fact opened before the previous code runs?  hr  My Macbook Pro is running OS X El Capitan, 10.11.6.  hr  The bug might be related to another piece of strange behavior that I noticed:  ul liQuit out of Safari.app and Automator.app, if they are running./li liPull up the folder where the computer's Services are stored (/Users/Me/Library/Services/) in Finder./li liRight-click the Service file and open the file with Automator./li /ul  You will notice that opening the .workflow file with Automator will activate Safari. It shouldn't do that.  <answer271588> The only workaround I've found after testing several different scenarios is to wrap the Safari emcommands/em within a codedo shell script/code emcommand/em, e.g. codedo shell script "osascript -e 'tell application \"Safari\" to activate'"/code. Note that with codeosascript/code, multiple code−e/code emoptions/em may be given to build up a multi-line script.  From the manual page for codeosascript/code:     strong−e/strong emstatement/em      Enter one line of a script. If strong−e/strong is given, strongosascript/strong will not look for a filename in the argument list. Multiple strong−e/strong options may be given to build up a multi-line script. Because most scripts use characters that are special to many shell programs (e.g., AppleScript uses single and double quote marks, “(”, “)”, and “*”), the statement will have to be correctly quoted and escaped to get it past the shell intact.   Example AppleScript emcode/em:  precodetell application "Safari"     activate     make new document in front     set URL of front document to "http://apple.stackexchange.com/questions/271133/services-bug-that-prematurely-activates-an-application" end tell /code/pre  An example of the AppleScript emcode/em above, written as a codedo shell script/code emcommand/em using codeosascript/code with the code-e/code emoption/em, as necessary.  precodedo shell script "osascript -e 'tell application \"Safari\"' -e 'activate' -e 'make new document in front' -e 'set URL of front document to \"http://apple.stackexchange.com/questions/271133/services-bug-that-prematurely-activates-an-application\"' -e 'end tell'" /code/pre  As you can see, each line of AppleScript emcode/em from the normal codetell/code emblock statement/em is its own code-e/code emoption/em, and as noted in the manual page for codeosascript/code with the code-e/code emoption/em, escaping with a backslash has been done as necessary for the emcode/em to emcompile/em correctly before being run.  In other words, this turn the normal codetell/code emblock statement/em and its included emcommands/em to a one-line codedo shell script/code emcommand/em so as to circumvent the apparent bug in the use case scenario presented in the OP.  Note that you should be able to do similar with other applications triggered by the same bug, by substituting the appropriate application emname/em (and emcommands/em) as needed.  <comment341251> I can replicate the issues you've described under OS X El Capitan 10.11.6. <comment341253> Thanks for checking @user3439894! Can you think of any workarounds? <comment341257> The only workaround I've found after testing several different scenarios is to wrap the Safari commands within a  `do shell script` command, e.g. `do shell script "osascript -e 'tell application \"Safari\" to activate'"`.  Note that with `osascript`, multiple −e options may be given to build up a multi-line script. <comment341372> That works great! If you post that as an answer, I'll accept it. Also, if you don't mind, can you expand on that final sentence a little bit? I don't really understand what it means. <comment341403> Thanks for providing and explaining an example! I now understand the concept.
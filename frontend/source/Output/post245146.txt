Making ~/.bashrc function callable to set up an environment <body> I have an installed app lets call it codemy_app/code that I wish to be able to call from the command line. It is located in code/Applications/my_app.app/Contents/Resources/code.  So what I was hoping to do was to have my code~/.bashrc/code look like the following:   precode# .bashrc  my_app-start(){ export PATH=$PATH:/Applications/my_app.app/Contents/Resources/ } /code/pre  and then every time I want to be able to use the app from a new terminal session I would load call codemy_app-start/code after which I expect my app to be callable by simply typing codemy_app/code anywhere on my system. However my terminal does not recognise the codemy_app-start/code function... On another linux platform this works for me but perhaps Macs need some fiddling with ~/.bash_profile. I never understood the difference.   ol liHow do I make the function automatically callable?/li liIs this method a safe, sensible way of loading my application?/li /ol  <answer245147> Why not just create a symlink in code/usr/local/bin/code?  precodeln -s /foo/bar/hello_world.app /usr/local/bin/hello_world.app /code/pre  You won't have to create any functions in code.bashrc/code  In fact, what I have done with scripts that I have written that have multiple versions, is create a symlink to a file with the text "-latest" and then copy the latest version into that file.  My symlink looks like this:  precodeln -s /foo/bar/my_app-latest.app /usr/local/bin/my_app.app /code/pre  Whenever I have a new version, I just copy to codemy_app-latest.app/code and everything is updated.  <answer245150> Your function doesn't work because OS X starts your shell as a login shell, thus .bashrc isn't read. I wouldn't use a function in this case. If there is only one executable file in code/Applications/my_app.app/Contents/Resources//code then I would use an alias.  I would use separate files when changing your environment. Set your PATH and whatever in these/this file(s) then at any time source your environment file and your good to go. As an example, I have the AST tool set installed. I'm testing the tools supplied by AST but need to use the minimum PATH supplied by OS X and the PATH to the AST tools. So, I have to modify my PATH that is set in my .profile. I've created a file .astenv in my home folder.  precode# #  .astenv # #  The AT&amp;T Software Technology tools from AT&amp;T Research # #  PATH=$(/usr/bin/getconf PATH) ASTPATH=$HOME/local/opt/ast-master/arch/darwin/bin  PATH=$ASTPATH:$PATH export PATH /code/pre  To use this config file,  I can start a new terminal session and source the file,  precode. ~/.astenv /code/pre  or in my current terminal session start a new instance of my shell then source the file.  precodeksh . ~/.astenv /code/pre  When I codeexit/code this shell, I'm back to my original environment.  <comment302156> Interesting - is the symlink peramanent or do I have to call it everytime I open a new terminal? The reason I wanted to do it via a function is so that I could choose to set up the environment or not when I open a new terminal. <comment302157> I also read that ideally you would link to `/usr/local/sbin` and not `/usr/sbin` though I'm not sure why. <comment302161> Ok thanks for the clarification about login shell. Im not exactly sure about your second point could you please elaborate (I'm not a very experienced linux user) <comment302167> The symlink is permanent.  Every time you open terminal, it will be available since it's in your path.  It may be `/usr/local/sbin`...between FreeBSD, OS X, Linux, and Windows, it tough to keep them all straight. <comment302210> `/usr/sbin` is not user-writeable on El Capitan, I've changed it to `/usr/local/bin` in your answer. <comment302259> @patrix Appreciate that...I was on my Surface Pro 3 yesterday and couldn't test out
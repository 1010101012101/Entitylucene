Can I modify a terminal command to do additional stuff? <body> I've looked into aliases, functions... but I have not come up with anything satisfying. Let me give you a couple of scenarios:  ul li95% of times that I codecd/code into a folder, I follow up with a codels/code command./li li90% of times that I codemkdir/code, I codecd/codemyself into it./li /ul  You get the idea.  What would be the "cleanest" way to bind those commands together (or other functionality)?  <answer206674> I think functions are the way to go. Something like  precodechglist() {     cd "$1" &amp;&amp; ls } /code/pre  as an example.  <answer206695> I have tried adding things like these to my code.bashrc/code:  precodecd() {     command cd "$@"     command ls }  mkdir() {     command mkdir "$@"     command cd "$@" } /code/pre  However, I've found that this can mess up scripts that use the overridden commands, and the option handling can be fragile (for example, if you want to pass code-p/code to the above codemkdir/code command, it's also passed to codecd/code). Better would be just to define aliases with different names (say, codec/code or codemcd/code).  <answer206716> I'd tend to make a new command for this. I think it would even be logical to combine them into a single one.  precodego() {     if [ -d "$1" ]; then         cd "$1" &amp;&amp; ls     else         mkdir -p "$1" &amp;&amp; echo "Created directory $1" &amp;&amp; cd "$1"     fi } /code/pre  <answer207133> You can put these lines in your code.zsrhc/code or code.bashrc/code  precodefunction cd { builtin cd "$@" &amp;&amp; ls -F } [ -z "$PS1" ] &amp;&amp; return /code/pre  strongResult -/strong  img src="https://i.stack.imgur.com/K7ePz.png" alt="enter image description here"     [ -z "$PS1" ] checks if the $PS (interactive prompt variable) is "zero length" (-z). If it is zero length, this means it has not been set, so Bash must not be running in interactive mode. The &amp;&amp; return part exits from sourcing .bashrc at this point, under these conditions.   https://unix.stackexchange.com/questions/20396/make-cd-automatically-ls  Btw, thanks for the question, it's really cool :)  strongEdit :/strong  An other solution will be to integrate your ls to your prompt, I'm sure that you can do that with OhMyZsh ;)  <comment249112> Why didn't aliases work for you? <comment249115> So should the cd result of mkdir then tack on the ls? <comment249168> @bmike Well, a newly created directory will be empty, so ls prints nothing. <comment249186> I like your idea combining these ones! :-) <comment249192> This answer is also the cleanest as it doesn't disturb default definition of cd/mkdir when used by scripts <comment249206> @Random832 you assume no flags on ls, but more importantly my question will reveal how broken / heavy handed a change is desired. I prefer aliases over functions, but both can attempt what is asked. <comment249214> Coincidentally I was going to ask this same question. Will post my answer in some time. <comment249242> Sure, but what if you decide to start using the Go programming language? :P <comment249244> @Thorbjørn Ravn Andersen Because an alias will not apply arguments to commands, only the last command receives the arguments. Try `alias foo='echo "cd "$1"" && echo "du "$@"" && echo "ls "$2""'`  then `foo fred barney dino` <comment249247> @fd0 I am not doubting that aliases did not work.  I'm asking why.  There might be a simpler solution to the problem. <comment249248> @arxanas: You use makefiles? ;-) <comment249257> hmmm I like this one. but if you accidentally mistype the name, you create a new directory. Is it hard to implement a check on a leave (cd `/.... ` or`../` or something) and delete the directory if it's empty? I mean if you leave a directory just check if it's empty and if so, delete it. if you don't want that, you can still use cd instead of go <comment249482> @ThorbjørnRavnAndersen aliases don't seem to accept arguments; They are just a string replacement tool. <comment249485> I tried that, but it doesn't solve the problem, it just creates a different one. In this case, I have to remember new commands. I want to *upgrade* **existing** commands. There must be something besides recompiling from the source, right? :\ <comment249759> In general don't use the same name as standard commands as cd ls rm etc as you will need to use these standard commands <comment249760> @Mark I'm agree for 'rm -rf ~/*' ^^ But for a cd command, it's not really dangerous. And Carles want to 'upgrade existing commands', so... <comment249771> What @Random832 did here is one of the cleanest and simplest way to build in one answer a composed command to your 2 examples. `&&` is the shell building glue to chain `command2` after `command1` if `command1` suceeded. This isn't any "recompiling from the source".
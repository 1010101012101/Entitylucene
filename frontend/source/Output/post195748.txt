Adding content from mail to Excel using Applescript <body> I have gone through and used some great code form the these forms for Adding content from mail to Excel using Applescript. I am nearly there but have one more question.  I have the following layout of an email  precodeFrom: xxxxxx Gender: xxxxxx Age: &gt;18 - 24 Phone Day: xxxxxx Mobile: Address: xxxxx xxxxx xxxx xxxx /code/pre  Notice each line has an intro "From:", this content is being pulled in correctly. My issue is adding line 2,3 and 4 of the address as it has no intro.  Any thoughts?  This is what I have used so far.  Any help gratefully received.  precode--APPLESCRIPT _main() on _main()   set mm to {}   tell application "Mail"   repeat with m in (get selection)   set mm's end to m's content &amp; linefeed   end repeat   end tell   set r to my _retrieve_data(mm) do shell script "printf '%s' " &amp; r's quoted form &amp; " &gt; ~/desktop/$(date +scores_%F_%H%M%S.csv)"   return r end _main  on _retrieve_data(mm) (*         list mm : list of message text     *)   script o   property pp : mm   property qq : {}   property rr : {}   property boundary : do shell script "uuidgen" without altering line endings -- UUID &amp; LF   property batch : 50 -- number of messages to be processed at once; combined text should not exceed ca. 200K    -- divide messages into batches   repeat with i from 1 to count my pp by batch   set j to i + batch - 1   if j &gt; (count my pp) then set j to -1   set my qq's end to my pp's items i thru j   end repeat    -- retrieve data per batch   repeat with q in my qq   set my rr's end to do shell script "perl -CSDA -w &lt;&lt;'EOF' - " &amp; boundary's quoted form &amp; " use strict; local $\\ = qq(\\n); local $, = qq(,);  my $boundary = shift; my @data = (); my ($new, $complete, $i) = (1, 0, -1); while (&lt;DATA&gt;) {     next if ! ($new ||= $_ =~ /^$boundary$/) &amp;&amp; $complete;     if ( $new ) {         ($new, $complete) = (0, 0);         ++$i;     }    /^From:\\s*(.+?)\\s*$/o           &amp;&amp; do { $data[$i]{from}  = $1; next; };   /^Gender:\\s*(.+?)\\s*$/o         &amp;&amp; do { $data[$i]{gender}  = $1; next; };   /^Age:\\s*(.+?)\\s*$/o            &amp;&amp; do { $data[$i]{age}  = $1; next; };   /^Mobile:\\s*(.+?)\\s*$/o         &amp;&amp; do { $data[$i]{mobile}  = $1; next; };   /^Phone Day:\\s*(.+?)\\s*$/o      &amp;&amp; do { $data[$i]{phoneday}  = $1; next; };   /^Address:\\s*(.+?)\\s*$/o        &amp;&amp; do { $data[$i]{address1}  = $1; next;  character id(200);};   /^Address:\\s*(.+?)\\s*$/o       &amp;&amp; do { $data[$i]{address2}  = $1; next; };   /^Address:\\s*(.+?)\\s*$/o         &amp;&amp; do { $data[$i]{address3}  = $1; next; };   /^Address:\\s*(.+?)\\s*$/o       &amp;&amp; do { $data[$i]{address4}  = $1; next; };      /^Email:\\s*(.+?)\\s*$/o          &amp;&amp; do { $data[$i]{email}  = $1; next; };   /^I would like to be kept up to date on future Eden events, competitions and special offers\\s*(.+?)\\s*$/o          &amp;&amp; do { $data[$i]{eden}  = $1; next; };   /^I would like to be kept up to date on future Kuoni events, competitions and special offers\\s*(.+?)\\s*$/o          &amp;&amp; do { $data[$i]{Kuoni}  = $1; next; };   $complete = (0 + keys %{$data[$i]} == 12);       }    my @keys = ('from', 'gender', 'age', 'mobile', 'phoneday', 'address1', 'address2','address3','address4','email',  'eden',  'kuoni' ); print map { s/\"/\"\"/og; qq(\"$_\") } @keys;  for (@data) {     print map { $_ = '' unless defined $_; s/\"/\"\"/og; qq(\"$_\") } @{$_}{@keys}; } __END__ " &amp; _join(q, boundary) &amp; " EOF" without altering line endings   end repeat    -- combine data from each batch   set r to my rr's item 1 -- include header   repeat with i from 2 to count my rr -- exclude header for rest   set r to r &amp; my rr's item i's text from paragraph 2 to text -1   end repeat   return r   end script   tell o to run end _retrieve_data  on _join(tt, d) (*         list tt : source list         string d : separator         return string : tt joined with d     *)   local astid0, t   try   set {astid0, AppleScript's text item delimiters} to {AppleScript's text item delimiters, {} &amp; d}   set t to "" &amp; tt   set AppleScript's text item delimiters to astid0   on error errs number errn   set AppleScript's text item delimiters to astid0   error errs number errn   end try   return t end _join --END OF APPLESCRIPT /code/pre  if anyone is interested below is some amended code which is pretty much working.  precode    --APPLESCRIPT _main() on _main()     set mm to {}     tell application "Mail"         repeat with m in (get selection)             set mm's end to m's content &amp; linefeed         end repeat     end tell     set r to my _retrieve_data(mm)     do shell script "printf '%s' " &amp; r's quoted form &amp; " &gt; ~/desktop/$(date +list_%F_%H%M%S.csv)"     return r end _main  on _retrieve_data(mm)     (*         list mm : list of message text     *)     script o         property pp : mm         property qq : {}         property rr : {}         property boundary : do shell script "uuidgen" without altering line endings -- UUID &amp; LF         property batch : 50 -- number of messages to be processed at once; combined text should not exceed ca. 200K          -- divide messages into batches         repeat with i from 1 to count my pp by batch             set j to i + batch - 1             if j &gt; (count my pp) then set j to -1             set my qq's end to my pp's items i thru j         end repeat          -- retrieve data per batch         repeat with q in my qq             set my rr's end to do shell script "perl -CSDA -w &lt;&lt;'EOF' - " &amp; boundary's quoted form &amp; " use strict; local $\\ = qq(\\n); local $, = qq(,);  my $boundary = shift; my @data = (); my ($new, $complete, $i, $j) = (1, 0, -1, 0); while (&lt;DATA&gt;) {     next if ! ($new ||= $_ =~ /^$boundary$/) &amp;&amp; $complete;     if ( $new ) {         ($new, $complete) = (0, 0);         ++$i;     }      /^From:\\s*(.+?)\\s*$/o         &amp;&amp; do { $data[$i]{from}     = $1; $j=0; next; };     /^Gender:\\s*(.+?)\\s*$/o       &amp;&amp; do { $data[$i]{gender}   = $1; $j=0; next; };     /^Age:\\s*(.+?)\\s*$/o          &amp;&amp; do { $data[$i]{age}      = $1; $j=0; next; };     /^Mobile:\\s*(.+?)\\s*$/o       &amp;&amp; do { $data[$i]{mobile}   = $1; $j=0; next; };     /^Phone Day:\\s*(.+?)\\s*$/o    &amp;&amp; do { $data[$i]{phoneday} = $1; $j=0; next; };     /^Email:\\s*(.+?)\\s*$/o        &amp;&amp; do { $data[$i]{email}    = $1; $j=0; next; };      /^I would like to be kept up to date on future Eden events, competitions and special offers\\s*(.+?)\\s*$/o                                      &amp;&amp; do { $data[$i]{eden}     = $1; next; };     /^I would like to be kept up to date on future Kuoni events, competitions and special offers\\s*(.+?)\\s*$/o                                     &amp;&amp; do { $data[$i]{kuoni}    = $1; next; };      /^Address:\\s*(.+?)\\s*$/o      &amp;&amp; do { $data[$i]{address1} = $1; $j=1; next; };     $j == 1 &amp;&amp; /^\\s*(.+?)\\s*$/o   &amp;&amp; do { $data[$i]{address2} = $1; $j++; next; };     $j == 2 &amp;&amp; /^\\s*(.+?)\\s*$/o   &amp;&amp; do { $data[$i]{address3} = $1; $j++; next; };     $j == 3 &amp;&amp; /^\\s*(.+?)\\s*$/o   &amp;&amp; do { $data[$i]{address4} = $1; $j++; next; };      $complete = (0 + keys %{$data[$i]} == 12); }  my @keys = ('from', 'gender', 'age', 'mobile', 'phoneday', 'address1', 'address2','address3','address4','email', 'eden', 'kuoni'); print map { s/\"/\"\"/og; qq(\"$_\") } @keys;  for (@data) {     print map { $_ = '' unless defined $_; s/\"/\"\"/og; qq(\"$_\") } @{$_}{@keys}; } __END__ " &amp; _join(q, boundary) &amp; " EOF" without altering line endings         end repeat          -- combine data from each batch         set r to my rr's item 1 -- include header         repeat with i from 2 to count my rr -- exclude header for rest             set r to r &amp; my rr's item i's text from paragraph 2 to text -1         end repeat         return r     end script     tell o to run end _retrieve_data  on _join(tt, d)     (*         list tt : source list         string d : separator         return string : tt joined with d     *)     local astid0, t     try         set {astid0, AppleScript's text item delimiters} to {AppleScript's text item delimiters, {} &amp; d}         set t to "" &amp; tt         set AppleScript's text item delimiters to astid0     on error errs number errn         set AppleScript's text item delimiters to astid0         error errs number errn     end try     return t end _join --END OF APPLESCRIPT /code/pre  <answer195884> Correct code below for interest.  precode--APPLESCRIPT _main() on _main()     set mm to {}     tell application "Mail"         repeat with m in (get selection)             set mm's end to m's content &amp; linefeed         end repeat     end tell     set r to my _retrieve_data(mm)     do shell script "printf '%s' " &amp; r's quoted form &amp; " &gt; ~/desktop/$(date +list_%F_%H%M%S.csv)"     return r end _main  on _retrieve_data(mm)     (*         list mm : list of message text     *)     script o         property pp : mm         property qq : {}         property rr : {}         property boundary : do shell script "uuidgen" without altering line endings -- UUID &amp; LF         property batch : 50 -- number of messages to be processed at once; combined text should not exceed ca. 200K          -- divide messages into batches         repeat with i from 1 to count my pp by batch             set j to i + batch - 1             if j &gt; (count my pp) then set j to -1             set my qq's end to my pp's items i thru j         end repeat          -- retrieve data per batch         repeat with q in my qq             set my rr's end to do shell script "perl -CSDA -w &lt;&lt;'EOF' - " &amp; boundary's quoted form &amp; " use strict; local $\\ = qq(\\n); local $, = qq(,);  my $boundary = shift; my @data = (); my ($new, $complete, $i, $j) = (1, 0, -1, 0); while (&lt;DATA&gt;) {     next if ! ($new ||= $_ =~ /^$boundary$/) &amp;&amp; $complete;     if ( $new ) {         ($new, $complete) = (0, 0);         ++$i;     }  /^From:\\s*(.+?)\\s*$/o         &amp;&amp; do { $data[$i]{from}     = $1; $j=0; next; }; /^Gender:\\s*(.+?)\\s*$/o       &amp;&amp; do { $data[$i]{gender}   = $1; $j=0; next; }; /^Age:\\s*(.+?)\\s*$/o          &amp;&amp; do { $data[$i]{age}      = $1; $j=0; next; }; /^Mobile:\\s*(.+?)\\s*$/o       &amp;&amp; do { $data[$i]{mobile}   = $1; $j=0; next; }; /^Phone Day:\\s*(.+?)\\s*$/o    &amp;&amp; do { $data[$i]{phoneday} = $1; $j=0; next; }; /^Email:\\s*(.+?)\\s*$/o        &amp;&amp; do { $data[$i]{email}    = $1; $j=0; next; };      /^Address:\\s*(.+?)\\s*$/o      &amp;&amp; do { $data[$i]{address1} = $1; $j=1; next; };     $j == 1 &amp;&amp; /^\\s*(.+?)\\s*$/o   &amp;&amp; do { $data[$i]{address2} = $1; $j++; next; };     $j == 2 &amp;&amp; /^\\s*(.+?)\\s*$/o   &amp;&amp; do { $data[$i]{address3} = $1; $j++; next; };     $j == 3 &amp;&amp; /^\\s*(.+?)\\s*$/o   &amp;&amp; do { $data[$i]{address4} = $1; $j++; next; };   /^I would like to be kept up to date on future Eden events, competitions and special offers\\s*$/o                                       &amp;&amp; do { $data[$i]{eden}     = '1'; $j=0; next; };     /^I would like to be kept up to date on future Kuoni events, competitions and special offers\\s*$/o                                     &amp;&amp; do { $data[$i]{kuoni}    = '1'; $j=0; next; };  $complete = (0 + keys %{$data[$i]} == 12); }  my @keys = ('from','gender','age','mobile','phoneday','email','address1','address2','address3','address4','eden','kuoni'); print map { s/\"/\"\"/og; qq(\"$_\") } @keys;  for (@data) {     print map { $_ = '' unless defined $_; s/\"/\"\"/og; qq(\"$_\") } @{$_}{@keys}; } __END__ " &amp; _join(q, boundary) &amp; " EOF" without altering line endings         end repeat          -- combine data from each batch         set r to my rr's item 1 -- include header         repeat with i from 2 to count my rr -- exclude header for rest             set r to r &amp; my rr's item i's text from paragraph 2 to text -1         end repeat         return r     end script     tell o to run end _retrieve_data  on _join(tt, d)     (*         list tt : source list         string d : separator         return string : tt joined with d     *)     local astid0, t     try         set {astid0, AppleScript's text item delimiters} to {AppleScript's text item delimiters, {} &amp; d}         set t to "" &amp; tt         set AppleScript's text item delimiters to astid0     on error errs number errn         set AppleScript's text item delimiters to astid0         error errs number errn     end try     return t end _join --END OF APPLESCRIPT /code/pre  <comment233741> nice work so far, you might have to wait till our scripting gurus come online to take look.
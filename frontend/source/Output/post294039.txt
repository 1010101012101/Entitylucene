How to strip a Hebrew text of vowels and punctuation in AppleScript? <body> Take the first several verses of Genesis, in Hebrew, for example:     בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ׃      וְהָאָ֗רֶץ הָיְתָ֥ה תֹ֙הוּ֙ וָבֹ֔הוּ וְחֹ֖שֶׁךְ עַל־פְּנֵ֣י תְה֑וֹם וְר֣וּחַ אֱלֹהִ֔ים מְרַחֶ֖פֶת עַל־פְּנֵ֥י הַמָּֽיִם׃      וַיֹּ֥אמֶר אֱלֹהִ֖ים יְהִ֣י א֑וֹר וַֽיְהִי־אֽוֹר׃      וַיַּ֧רְא אֱלֹהִ֛ים אֶת־הָא֖וֹר כִּי־ט֑וֹב וַיַּבְדֵּ֣ל אֱלֹהִ֔ים בֵּ֥ין הָא֖וֹר וּבֵ֥ין הַחֹֽשֶׁךְ׃      וַיִּקְרָ֨א אֱלֹהִ֤ים ׀ לָאוֹר֙ י֔וֹם וְלַחֹ֖שֶׁךְ קָ֣רָא לָ֑יְלָה וַֽיְהִי־עֶ֥רֶב וַֽיְהִי־בֹ֖קֶר י֥וֹם אֶחָֽד׃ (פ)   (That code(פ)/code for some reason isn't formatting properly in the blockquote, but it does in my text file.)  Now, I'd like to strip this text of all characters except for the standard 27-letter Hebrew alphabet codeאבגדהוזחטיכךלמםנןסעפףצץקרשת/code, plus line breaks (which Script Editor automatically parses as code\n/code) and line and paragraph breaks (code:/code and code(פ)/code or code(ס)/code). You'll notice on several lines that there are hyphens - those should be replaced with a space. Some lines also contain code|/code - those should be replaced with a single code/code. When done, it should look like:     בראשית ברא אלהים את השמים ואת הארץ׃      והארץ היתה תהו ובהו וחשך על פני תהום ורוח אלהים מרחפת על פני המים׃      ויאמר אלהים יהי אור ויהי אור׃      וירא אלהים את האור כי טוב ויבדל אלהים בין האור ובין החשך׃      ויקרא אלהים לאור יום ולחשך קרא לילה ויהי ערב ויהי בקר יום אחד׃ (פ)   I tried something simple at first - set the Hebrew alphabet plus code/code, code(/code, and code)/code to a list, set codex/code to the length of the inputted string, then do a repeat for each character of the string: if it's on the list, then append it to the output; if it's a code-/code, append code/code to the output; if it's a code\/code and the next one is a coden/code, append code\n/code to the output; and if there are two spaces in a row, delete the second.  I logged the output and got some gibberish:  precode(*אאית   א    ים  ת     ם   ת    ץץץץץץץץ    ה  הה   הה       ללללי    ם         ים     ת  ללללי    םםםםםאאר    ים   י   ר    ייייררררררא    ים  תתתתתר  ייייב     ל    ים  ין    ר   ין           א    ים    אאא   ם         א    ה    ייייב    ייייר   ם   דד (פ)*) /code/pre  which seems to be every letter in the passage without a vowel, duplicated in the event that the following letter(s) do. (My mistake on the repeats - wrote the repeat loop poorly.) But that it skips over consonants that also have vowels is what left me wondering.  So I did a test:  precodeset charNum to ASCII number "בְּ" log charNum set charNum to ASCII number "ב" log charNum --&gt;result: (*63*) (*63*) /code/pre  Although in the text editor, vowels and the like are separate characters overlaid on the previous ones, Script Editor doesn't see it that way, and sees בְּ and ב as the same letter. And yet, when comparing it to my list, it doesn't recognize the character and skips it.  So how can I strip the vowels and the like from the letters while not doing an if-loop for any possible letter and vowel combination?  <answer294149> codeASCII number/code is deprecated and doesn't work correctly with unicode text, use codeid of someCharacter/code:  precodeset charNum to id of "בְּ" -- this return id of 3 characters because "בְּ" is a composed character log charNum set charNum to id of "ב" log charNum --&gt;result:  (*1489, 1456, 1468*) (*1489*) /code/pre  So, I do not know how to do this in pure AppleScript.  hr  But, you can use a strongperl/strong command in a codedo shell script/code:  precode-- The text look not good in this code block, but it will be correct after the compilation of the script set theString to "בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ׃  וְהָאָ֗רֶץ הָיְתָ֥ה תֹ֙הוּ֙ וָבֹ֔הוּ וְחֹ֖שֶׁךְ עַל־פְּנֵ֣י תְה֑וֹם וְר֣וּחַ אֱלֹהִ֔ים מְרַחֶ֖פֶת עַל־פְּנֵ֥י הַמָּֽיִם׃  וַיֹּ֥אמֶר אֱלֹהִ֖ים יְהִ֣י א֑וֹר וַֽיְהִי־אֽוֹר׃  וַיַּ֧רְא אֱלֹהִ֛ים אֶת־הָא֖וֹר כִּי־ט֑וֹב וַיַּבְדֵּ֣ל אֱלֹהִ֔ים בֵּ֥ין הָא֖וֹר וּבֵ֥ין הַחֹֽשֶׁךְ׃  וַיִּקְרָ֨א אֱלֹהִ֤ים ׀ לָאוֹר֙ י֔וֹם וְלַחֹ֖שֶׁךְ קָ֣רָא לָ֑יְלָה וַֽיְהִי־עֶ֥רֶב וַֽיְהִי־בֹ֖קֶר י֥וֹם אֶחָֽד׃ (פ)"   return do shell script "perl -CSD -pe  'use utf8; s~\\p{NonspacingMark}~~og; s~־|׀~ ~g;  s~ +~ ~g;' &lt;&lt;&lt; " &amp; quoted form of theString /code/pre  Here is a brief explanation of the perl script  ul lithe code-CSD/code option : the output and the error will be in UTF-8, the input is assumed to be in UTF-8/li licodes~\\p{NonspacingMark}~~og/code : Remove non spacing marks/li licodes~־|׀~ ~g/code : Replace all code־/code and code׀/code by a space/li licodes~ +~ ~g/code : Replace multiple spaces in a row by one space/li /ul  hr  If your AppleScript read the text from a file, you can use strongperl/strong to read the file:  precodedo shell script "perl -CSD -pe  'use utf8; s~\\p{NonspacingMark}~~og; s~־|׀~ ~g;  s~ +~ ~g;' &lt; " &amp; quoted form of posix path of pathOfTheTextFile /code/pre  The encoding of the file must be utf8.  hr  Another solution is to use a strongCocoa-AppleScript/strong:  precode        use framework "Foundation"         use scripting additions         -- The text look not good in this code block, but it will be correct after the compilation of the script         set theString to "בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ׃  וְהָאָ֗רֶץ הָיְתָ֥ה תֹ֙הוּ֙ וָבֹ֔הוּ וְחֹ֖שֶׁךְ עַל־פְּנֵ֣י תְה֑וֹם וְר֣וּחַ אֱלֹהִ֔ים מְרַחֶ֖פֶת עַל־פְּנֵ֥י הַמָּֽיִם׃  וַיֹּ֥אמֶר אֱלֹהִ֖ים יְהִ֣י א֑וֹר וַֽיְהִי־אֽוֹר׃  וַיַּ֧רְא אֱלֹהִ֛ים אֶת־הָא֖וֹר כִּי־ט֑וֹב וַיַּבְדֵּ֣ל אֱלֹהִ֔ים בֵּ֥ין הָא֖וֹר וּבֵ֥ין הַחֹֽשֶׁךְ׃  וַיִּקְרָ֨א אֱלֹהִ֤ים ׀ לָאוֹר֙ י֔וֹם וְלַחֹ֖שֶׁךְ קָ֣רָא לָ֑יְלָה וַֽיְהִי־עֶ֥רֶב וַֽיְהִי־בֹ֖קֶר י֥וֹם אֶחָֽד׃ (פ)"          return stripString(theString)          on stripString(t)             set sourceString to current application's NSMutableString's stringWithString:t             set myOpt to current application's NSRegularExpressionSearch             set theSuccess to sourceString's applyTransform:(current application's NSStringTransformStripCombiningMarks) |reverse|:false range:(current application's NSMakeRange(0, (sourceString's |length|))) updatedRange:(missing value)             if theSuccess then                 -- *** Replace all "־" and "׀" by a space, each character must be separated by a vertical bar character, e.g. "a|d|z"                 sourceString's replaceOccurrencesOfString:"־|׀" withString:" " options:myOpt range:(current application's NSMakeRange(0, (sourceString's |length|)))                  -- **** Replace multiple spaces in a row by one space                 sourceString's replaceOccurrencesOfString:" +" withString:" " options:myOpt range:(current application's NSMakeRange(0, (sourceString's |length|)))                 return sourceString as string -- convert the NSString object to an AppleScript's string             end if             return "" -- else, the transform was not applied         end stripString /code/pre  hr  According to the commentary:  For a droplet, the script need an codeon open handler/code, like this:  precodeon open theseFiles     repeat with f in theseFiles         set cleanText to do shell script "perl -CSD -pe  'use utf8; s~\\p{NonspacingMark}~~og; s~־|׀~ ~g;  s~ +~ ~g;' " &amp; quoted form of POSIX path of f         -- do something with that cleanText     end repeat end open /code/pre  hr  If you want to do an in-place editing (the perl script need  the code-i/code option + code'.some name extension'/code):  This will create backup of each file (it add "strong.bak/strong" after the    name)  precodeon open theseFiles     repeat with f in theseFiles -- ***  create a backup and edit the file in-place ***         do shell script "perl -i'.bak' -CSD -pe  'use utf8; s~\\p{NonspacingMark}~~og; s~־|׀~ ~g;  s~ +~ ~g;' " &amp; quoted form of POSIX path of f     end repeat end open /code/pre  If you don't want a backup of each file (the perl script need  the code-i/code option + code''/code), like this:  precode-- ***  edit the file in-place without backup*** do shell script "perl -i'' -CSD -pe  'use utf8; s~\\p{NonspacingMark}~~og; s~־|׀~ ~g;  s~ +~ ~g;' " &amp; quoted form of POSIX path of f /code/pre  <comment371269> Cocoa for some reason doesn't always work on my machine, which is odd considering that it's the new MacBook Pro. Is there some sort of extension I have to download for it to work? In any event, having Applescript make Bash call Perl, while slightly convoluted, works perfectly, so I gave you your checkmark. Thanks! One last question: if I save the second perl as a droplet, can I just drop a .txt file onto it, and it'll parse it for me in that file? Does the `return` function allow for editing files? <comment371356> This code should work on `MacOS 10.11.x` or later (without needing anything).  If this does not work, it may depend on one or more factors. This requires code debugging to find out. But if the **perl** script works, no need to continue with the **Cocoa-Applescript**. I updated my answer for the other question. <comment371416> Great, this works perfectly. Thanks so much!
Can I use GNU ps on OS X? <body> We can install GNU coreutils via codebrew/code. But there's no codeps/code in the utils. Can we use gnu codeps/code in OS X?  I'd like to use GNU codeps/code as it has more options and features.  <answer187793> codeps/code is not part of GNU coreutils according to Wikpedia.  The version that comes with my Linux distribution seems to be from procps, but it seems like there is no formula for it in homebrew.  There are formulas for codepstree/code which can give you great tree views, and also codehtop/code is another good process viewer.  <answer187796> No - since it does not exist. As to strongwhy/strong there is no builtin codeps/code in GNU’s codecoreutils/code package, see this answer on the Unix &amp; Linux Forums.  The best alternative formula available via Homebrew is codepsgrep/code:     psgrep  is a small Bash shell script that searches the process list   (as obtained by strongps(1)/strong ) using the awesome utility stronggrep(1)/strong  for  its  power.   That said, you can still use codepsgrep/code to behave as OS X’s codeps/code would. For example:  precode   OPTIONS    -a     Search the process list using BSD's "ps aux" format. This option           includes all users' processes in the search.     -b     Search the process list using BSD's "ps  ux"  format  (default).           This option only includes the running user's processes. /code/pre  hr  codepgrep/code is also available via codebrew/code, which is syntactically closer to codeps/code, but less efficient than codepsgrep/code:     strongpsgrep(1)/strong is  more  useful  than strongpgrep(1)/strong because not only can it search the process list and return a PID, it can give more useful information such as  its  UID,  GID,  memory/CPU usage, niceness, strongand anything else supported by ps./strong    hr  All emphasis mine.   <answer187829> There is no portable ps program. The ps command available on linux is, as others have mentioned, from the "procps" package. The reason why this cannot be ported to OSX is because Linux and OSX kernels do not expose this information in the same way. Linux uses a pseudo-filesystem in /proc, whereas OSX uses the sysctl function. Other systems may use either mechanism but provide data in a different format, or may require programs like ps to read directly from the kernel's memory.  In general there is no standard for how process information is available to programs like ps and top; so the program has to be designed for a specific operating system. If there is a specific feature missing from the OSX ps, you'll have to find another program that can do it, or write one yourself (look at the sysctl manual, in particular KERN_PROC as a starting point), or modify the existing ps command to add the feature.  Alternately, if you can get what you need by parsing the output of the ps command itself, you may be able to write a portable program - the output with the code-o/code option is reasonably reliable across platforms, particularly if you refer to the UNIX standard for the column names to use.  <comment222091> `pgrep` is part of recent versions of OS X as well <comment222095> @patrix agh! good point, confirmed: `type -a pgrep` `pgrep is /usr/local/bin/pgrep` `pgrep is /usr/bin/pgrep` <comment222145> have you tried running `ps` or `ps -ef` in a terminal on OSX? works for me on OSX 10.7.5 with no modifications, on two different machines. It's in /bin/ps <comment222146> Yup, I know, I wanted to use GNU `ps` because it has more options and features. <comment222147> ah OK, sorry I didn't realise that from the question as stated. I'd suggest including that somewhere, incase anyone else thinks the same as me - good luck with finding a solution <comment222151> Thank you for the suggestion. I added more explanation about that. <comment222161> Is the `/proc` filesystem the only method the Linux kernel provides for getting a list of processes, or are there also separate system calls which provide that information? <comment222163> @TannerSwett I don't think so. Before /proc was implemented, the ps command on linux worked by reading from /dev/kmem and /dev/swap.
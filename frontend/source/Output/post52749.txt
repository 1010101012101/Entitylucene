An iTunes Applescript that appends to tag only when it doesn't match part of the tag string? <body> I'm trying to find a way to add a keyword or group of words/tags/strings to a set of selected iTunes tracks if they haven't been added. A use-case would be to add extra metadata in a comment such as (live) or (remix).  If some tracks previously contained (live) while appending, then it would not append it- only the non-matched files. So a comment tag containing em(remix)(fast)(accordion)(random)/em would become em(remix)(fast)(accordion)(random)(live)/em afterwards. However, if reapplied, it would skip this track.  The closest thing I can find is Smart Append, but its for Windows only (being JavaScript).   The well known Doug has an append to tag script, but it doesn't have any detection capabilities. I peeked into the code (by right click  Show Package Contents) and can't seem to wrap my head around editing the script.  Anyone know of an existing script or a way to modify the existing script?  <answer56646> This script works if the keyword is between parentheses as in your example, otherwise partial match will be a problem. Example : "strongfast/strong" match "strongfaster/strong"  precodeproperty matchCase : true -- or false -- change according to your needs   set myTitle to "Append to Comments Tag, if the keyword not exists" set keywordSeparator to ";" -- keyword separator  tell application "iTunes"     set sel to selection     if sel is not {} then -- if tracks are selected...         set s to "s"         set x to (length of sel)         if x is 1 then set s to ""         set be to (display dialog "Enter keyword to append to the beginning or ending of each selected track's Comments tag:" &amp; return &amp; return &amp; " If more than one keyword, use this character " &amp; keywordSeparator &amp; " as separator." default answer "" buttons {"Cancel", "Beginning", "Ending"} cancel button 1 with title myTitle)         set appendage to text returned of be         set buttonOpt to button returned of be is equal to "Ending"         if appendage is "" then return         set listOfAppendage to my makeListOfKeywords(keywordSeparator, appendage)         set oldfi to fixed indexing         set fixed indexing to true         repeat with t from 1 to x             tell contents of item t of sel                 try                     set tresult to my checkExistKeywords(comment, listOfAppendage, buttonOpt)                     if tresult is not false then set comment to tresult                 end try             end tell         end repeat         set fixed indexing to oldfi         activate         display dialog "Done!" buttons {"OK"} default button 1 with icon 1 with title myTitle giving up after 4     else         activate         display dialog "You must select some tracks first." buttons {"Cancel"} default button 1 with title myTitle     end if end tell  on checkExistKeywords(tagValue, tKeywords, tOpt)     set isAdding to false     repeat with tKey in tKeywords         if matchCase then             considering case                 contents of tKey is not in tagValue             end considering         else --Ignore Case             contents of tKey is not in tagValue         end if         if the result then -- no match             set isAdding to true             if tOpt then                 set tagValue to tagValue &amp; tKey             else                 set tagValue to tKey &amp; tagValue             end if         end if     end repeat     if isAdding then return tagValue     return false -- nothing to add end checkExistKeywords  on makeListOfKeywords(tofind, t)     set ditd to text item delimiters     set text item delimiters to tofind     set t to text items of t     set text item delimiters to ditd     return t end makeListOfKeywords /code/pre 
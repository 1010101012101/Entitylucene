Listing in Terminal the last mounted volume <body> codeAttach(1)/codeing different copies of the same codedmg/code file create in code/Volumes/code folders representing each image. Let the first image be called codeImage/code; the subsequents will receive an incrementing number in their tail, e.g. codeImage 1/code, codeImage 2/code and so on.   However, detaching codeImage 1/code and then attaching another instance will recycle the the numerical id, so that my last image will actually be codeImage 1/code.   This means that I cannot rely on codels(1)/code's output (by default sorted lexicographically) to determine the last mounted image. I don't seem to have more success with codels -U/code or codediskutil/code's output either.   I may very well be missing something. Is there any way to reliably determine in codebash/code the latest mounted image? Thank you.  <answer257674> Use codegrep "Image_Volume_Name" /var/log/system.log/code. Replace codeImage_Volume_Name/code by the volume name of the mounted image (in the example below codednscrypt-pkg/code).  precodeOct 18 03:34:49 host kernel[0]: hfs: mounted dnscrypt-pkg on device disk7s1 Oct 18 03:34:49 host.sld.tld mds[70]: (Normal) Volume: volume:0x7f7fe6814c00 ********** Bootstrapped Creating a default store:1 SpotLoc:(null) SpotVerLoc:(null) occlude:0 /Volumes/dnscrypt-pkg 1 Oct 18 03:34:53 host kernel[0]: hfs: mounted dnscrypt-pkg on device disk8s1 Oct 18 03:34:53 host.sld.tld mds[70]: (Normal) Volume: volume:0x7f7fe7012c00 ********** Bootstrapped Creating a default store:1 SpotLoc:(null) SpotVerLoc:(null) occlude:0 /Volumes/dnscrypt-pkg 4 Oct 18 03:49:00 host kernel[0]: hfs: mounted dnscrypt-pkg on device disk5s1  Oct 18 03:49:00 host.sld.tld mds[70]: (Normal) Volume: volume:0x7f7fe6883800 ********** Bootstrapped Creating a default store:1 SpotLoc:(null) SpotVerLoc:(null) occlude:0 /Volumes/dnscrypt-pkg 2 /code/pre  This works in older system (in the example above 10.9.5).  In Sierra you have to "pipe" the disk identifier found in codegrep "Image_Volume_Name" /var/log/system.log/code of the last mounted disk to hdituil:  precodehdiutil info | grep disk5s1 /dev/disk5s1    48465300-0000-11AA-AA11-00306543ECAC    /Volumes/dnscrypt-pkg 2 /code/pre  hr  The bigger picture: use the -volname switch in hdiutil to rename the volume name of the mounted image while creating the dmg file. Then you don't have to deal with myriads of em/Volumes/Image X/ems  <answer257686> o list all mounted drives and their accompanying partitions from the Terminal on Mac OS X, you can use the diskutil command with the list flag. This is easily done at the command line by typing the following command: diskutil list Hit return to see the results, showing all mounted volumes, drives, and their respective partitions. This will give you feedback like the following, listing out the mounted drives, their volume names, the size of the drive and partitions, their partition types, and their identifier location:  <answer257736> The last line from the output of codemount/code would be the last filesystem mounted.  <comment321939> :Thank you for your insight. I am trying to build a system where I download a `dmg` file as an update for my app. I imagine there are rare instances when a previous update file, for some odd reason, has not been unmounted. In such cases, my script still needs to identify the latest downloaded update (by a different executable) and make use of it. <comment321941> Thank you for your effort. As a somewhat older user of StackOverflow, my well-meaning advice is to always read the question with care. (Sometimes, this means more than one take, at least for me.) I've been in your place and I know in the beginning we may miss some finer points. (And sometimes pay for this by being down-voted into oblivion.) I encourage you to stick around and contribute. (I won't downvote your answer.) <comment321946> @elderelder Hmm, you may still use different volume names or a routine to check the crc value of the update.dmg mounted as /Volumes/Image\ X with `hdiutil imageinfo -checksum ../update.dmg`. <comment321947> I think I see what you're saying. Food for thought. <comment321948> I prefer it for its terseness and it *should* work no matter the OS (X) version (have yet to test this on more than one system to be sure, as the man page doesn't say). Thanks. <comment321951> This is far from my initial reqs above, but it may help someone else, as an alternative to achieve the same result (while avoiding the inherent problems): downloading updates as zip files. I'd be able to preserve the code signature by preparing the archives using `ditto`. Less chances of anything going wrong, or relying on (what seem to me as) implementation details of `mount` that may change in future.
Using Automator to move subtitles files <body> Is it possible to use Automator to automatically move a subtitle file em.srt/em to the folder where a video file with the same name is located?  Let's say I have a file code~/Videos/MyVideoFolder/my_video.avi/code and I download a file code~/Downloads/my_video.srt/code, I want it to automagically move it to  code~/Videos/MyVideoFolder//code.  The subtitles files are identifiable by its extension em.srt/em, but videos can be of any type.  <answer119607> Consider using AppleScript instead of, or in combination with, Automator. Automator does not easily fit into workflows that require conditional branches.  Conditional branches are steps within the workflow that perform an action depending on some state or situation. In this case, if the video file is present in the destination folder.  AppleScript can handle this type of task; as could a perl script or other scripting language.  See Can Automator branch based on the value of a variable or the result of a step? for a script based approach combined with Automator.   h2Scripted Approach/h2  For tasks like this I prefer scripting languages like perl. Below is a script that should get you started - or that others can build on. It is untested, so treat with care:  precode#!/usr/bin/env perl  use strict; use warnings;  use File::Basename; # for fileparse  # WARNING: lack of error checking  # Use: ./move_srt.pl &lt;path to source folder&gt; &lt;path to destination folder&gt;  my $source_path = shift; my $destination_path = shift;  # Get the video file names - without their 3 or 4 letter suffixes my @destination_video_files = glob($source_path.'/*'); my %named_video_files = map { $_ =&gt; fileparse($_,qr/\..{3,4}/); } @destination_video_files;  # Get a list of srt files my @source_srt_files = glob($source_path.'/*\.srt');  foreach my $source_srt_file (@source_srt_files) {     print "[Encountered] $source_srt_file\n";      # Strip suffix and check if video exists with same name     my $named_srt_file = fileparse($source_srt_file,qr/\.srt/);     if (exists($named_video_files{$named_srt_file})) {          # Move the matching srt File         system('/bin/mv '.$source_srt_file.' '.$destination_path);          print "[Matched] $source_srt_file\n";     } else {         print "[Unmatched] $source_srt_file\n";     } } /code/pre  <answer119615> You can use a Automator folder action workflow.  The folder action watches the downloads folder.  The strongFilter Finder Items/strong filters be extension  The Applescript does the rest.  img src="https://i.stack.imgur.com/Ph7D9.png" alt="enter image description here"  hr  Applescript Code:  precodeon run {input, parameters}     (* video folder path *)     set folderName to "videos:MyVideoFolder"     set homePath to (path to home folder as text) as text     set thepath to POSIX path of (homePath &amp; folderName)      (* repeat with the srt files from input*)     repeat with i from 1 to number of items in input         set this_item to (item i of input as text)          (* get the file name *)         set baseName to (do shell script "basename  " &amp; quoted form of (POSIX path of this_item))         (* strip the extension from the name *)         set fileName to (do shell script "echo  " &amp; quoted form of baseName &amp; "  |cut -d'.' -f1")           (*test if a Video file with the name fileName  exists in the video folder *)         if (do shell script "/bin/test -e " &amp; (quoted form of (thepath &amp; "/") &amp; fileName &amp; ".") &amp; "*  ; echo $?") is "0" then             --0 = exists              (*test if a srt file with the exact name baseName extension exists in the video folder *)             if (do shell script "/bin/test -e " &amp; (quoted form of (thepath &amp; "/" &amp; baseName)) &amp; "  ; echo $?") is "1" then                 --1 = not exists                   (*move the scrt file *)                 do shell script " /bin/mv " &amp; (POSIX path of this_item) &amp; space &amp; thepath &amp; "/\"\""             end if          end if      end repeat  end run /code/pre  hr  The code is commented to explain what it is doing.  This is an example. It works as is on my tests when a file with the correct extension is added to the watched folder. Then moves it/them to the videos folder if they do not exist there already.  You can set it to overwrite if you want be removing the inner strongif condition/strong and just use the first if condition with the move code.  I have not tested it be actually downloading. Only drag and drop. You may have to adjust if the folder action does not pick up on the extension change drom strong.download/strong  to the file actual extension  <answer119638> You could also use a shell script like this:  precodeshopt -s globstar extglob nullglob for f; do   [[ $f != *.@(srt|ass|ssa) ]] &amp;&amp; continue   base=${f##*/}   target=$(printf %s\\n ~/Movies/**/"${base%???}"* | head -n1)   [[ $target ]] &amp;&amp; mv "$f" "${target%.*}.${base: -3}" done exit 0 /code/pre  img src="https://i.stack.imgur.com/rp6em.png" alt=""  You need Bash 4 for codeglobstar/code, which makes code**/code match multiple levels of directories. You can install Bash 4 and make it your default login shell by running codebrew install bash;echo /usr/local/bin/bash|sudo tee -a /etc/shells;chsh -s /usr/local/bin/bash/code.  codenullglob/code makes patterns with no matches expand to an empty string. codefor f; do/code is equivalent to codefor f in "$@"; do/code. When codeextglob/code is enabled, code@(srt|ass|ssa)/code matches exactly one out of codesrt/code, codeass/code, and codessa/code. Bash doesn't perform word splitting or filename expansion inside code[[/code, so code$f/code doesn't have to be quoted. codeprintf %s\\n/code prints each argument on a separate line. code${f##*/}/code removes the longest code*//code pattern from the start, code${base%???}/code removes the last three characters, code${target%.*}/code removes the shortest code.*/code pattern from the end, and code${base: -3}/code expands to the last three characters. code[[ $target ]]/code is equivalent to code[[ -n $target ]]/code, or it tests if code$target/code is set and not empty. codeexit 0/code makes Automator not display an error dialog if the last test exits with 1.  <comment139500> automagically?? Did you invent that word? <comment139501> When do you want that to happen? Before the download or after the download. You can specify the folder for the download so it will be there already. How does the automagical supposing to know which download belongs where? <comment139514> I love that word "automagically" I going to use it when something I automated is to complex to explain how I did it.
How do I make find fail if -exec fails? <body> When I run this command in the shell (in a non-empty directory):  precodefind . -exec invalid_command_here {} \; /code/pre  I get this:  precodefind: invalid_command_here: No such file or directory find: invalid_command_here: No such file or directory find: invalid_command_here: No such file or directory /code/pre  (and so on for each file)  I need codefind/code to fail after the first error. Is there any way to get this to work? I can't use codexargs/code, as I have spaces in my path, but I need the script calling this to return an error code.  <answer49047> I can use this instead:  precodefind . -name *.xml -print0 | xargs -n 1 -0 invalid_command /code/pre  <answer49156> This is a limitation of codefind/code. The POSIX standard specifies that the return status of codefind/code is 0 unless an error occurred while traversing the directories; the return status of executed commands doesn't enter into it.  You can make commands write their status to a file or to a descriptor:  precodefind_status_file=$(mktemp findstatus) : &gt;"$find_status_file" find … -exec sh -c 'trap "echo \$?" EXIT; invalid_command "$0"' {} \; if [ -s "$find_status_file" ]; then   echo 1&gt;&amp;2 "An error occurred" fi rm -f "$find_status_file" /code/pre  Another method, as you discovered, is to use xargs. The codexargs/code commands always processes all files, but returns the status 1 if any of the commands returns a nonzero status.  precodefind … -print0 | xargs -0 -n1 invalid_command /code/pre  Yet another method is to eschew codefind/code and use recursive globbing in the shell instead: code**//code means any depth of subdirectories. This requires version 4 or above of bash; macOS is stuck at version 3.x so you'd have to install it from a port collection. Use codeset -e/code to halt the script on the first command returning a nonzero status.  precodeshopt -s globstar set -e for x in **/*.xml; do invalid_command "$x"; done /code/pre  Beware that in bash 4.0 through 4.2, this works but traverses symbolic links to directories, which is usually not desirable.  If you use zsh instead of bash, recursive globbing works out of the box with no gotchas. Zsh is available by default on OSX/macOS. In zsh, you can just write  precodeset -e for x in **/*.xml; do invalid_command "$x"; done /code/pre  <comment56273> Very detailed, thank you! <comment56422> The `**` syntax also works in zsh. <comment338171> I always seem to forget the `-n 1` on macOS. Thanks for the reminder of the syntax. <comment338172> There's so much goodness in this answer.  <comment366882> note that you can use $1 as the parameter in xargs <comment366883> You can also combine `for` with `find`: https://stackoverflow.com/a/5247919/67824 <comment367041> @OhadSchneider You should not combine `for` with `find`. It's hard to make it work reliably with all file names. <comment367080> True, but they give a solution that works for most file names (I think only newlines in the file name break it).
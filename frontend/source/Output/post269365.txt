Why can't browsers resolve localhost? <body> I've got a program on my machine listening on port 8080 to respond to HTTP requests.  But when I try to go to codehttp://localhost:8080//code in a browser...   Chrome says:     The localhost page isn’t working      localhost didn’t send any data. ERR_EMPTY_RESPONSE   Firefox redirects the request to www.localhost.com:8080 which of course isn't correct.  My research suggests that it is doing this because it can't find localhost.  Safari says it can't open the page because "the server unexpectedly dropped the connection."  However, if I go to codehttp://127.0.0.1:8080/code the page loads correctly.  Therefore, it would seem that for some reason OS X isn't properly resolving localhost to 127.0.0.1.  If I try to codeping localhost/code from the command line, it works, but my understanding is that name resolution works differently in different places.  I have read various issues where localhost doesn't resolve e.g. from ping, but I am not having that problem. All the cases where localhost were not working in the browser appear to not have solutions related to the actual problem I am having.  I have also seen places where people have mentioned that localhost emdoes/em work in the browser, so I am wondering what I am doing wrong here.  From commentsbr If I try the IPv6 address for localhost codehttp://[::1]:8080//code then I get the same errors as using localhost.  <answer269551> Maybe try to use the port 80. You said code127.0.0.1:8080/code works so I am wondering if code127.0.0.1/code works too. I think if you type in codelocalhost/code it will resolve to codelocalhost:80/code where nothing is listening.  <answer269671> I am not a Javascript programmer so if anyone has better links please edit.  The issue is that your server is listening on the IPv4 address only and it should be listening on the IPv6 address as well.  How you chnage your server is off topic for Ask Different as it requires code changes. This StackOverflow answer might help.  Apple has changed macOS from El Capitan onwards to look for IPv6 addresses in preference to the older ones as reported here  You can test the server directly at codehttp://[::1]:8080/code  In the worse case you could remove localhosts alias to ::1 but better if you can't do anything then just use codehttp://127.0.0.1:8080/code in your testing  <answer269672> First check name resolution with the system resolver:  precodedscacheutil -q host -a name localhost /code/pre  If you get an output like:  precodename: localhost ipv6_address: ::1  name: localhost ip_address: 127.0.0.1 /code/pre  the system resolver works correctly.  Stop your node.js app, create a simple node.js server by using this file with an arbitrary name (e.g. multiserver.js):  precodevar http = require('http'); function handler(req, res) {   res.writeHead(200, {'Content-Type': 'text/plain'});   res.end('Hello World\n'); }; http.createServer(handler).listen(3000, '127.0.0.1'); http.createServer(handler).listen(3001, 'localhost'); http.createServer(handler).listen(3002, '192.168.0.5'); http.createServer(handler).listen(3003, 'host.example.com'); http.createServer(handler).listen(3004, 'LocalHostName.local'); /code/pre  (replace the IP of the :3002 server by an IP of your host (codeifconfig/code), the emhost.example.com/em of the :3003 server by the output of codeecho $HOSTNAME/code and emLocalHostName/em by the output of codescutil --get LocalHostName/code)  and start it with  precodenode ../multiserver.js /code/pre  Now test your "multiserver" with Google Chrome by entering http://name:port (don't forget to prepend stronghttp:///strong).  The first two ports should work with both "names" (127.0.0.1/localhost). So entering either http://127.0.0.1:3000, http://127.0.0.1:3001, http://localhost:3000 or http://localhost:3001 should all yield "Hello World".  Also check the nine permutations of the next three ports and names (e.g. http://LocalHostName.local:3002 or http://192.168.0.5:3004) which should also all yield "Hello World" if the hostname/DNS are set up correctly.  If all this works, your express/node.js app is faulty.  <comment338385> Firefox redirects a properly formed "http://" url? <comment338386> What is your server and what do its logs show <comment338388> @Allan yes it does <comment338389> @Mark my server is a node.js app using express.  it produces no output when trying to connect to "localhost" but logs the connecting IP address and URL when connecting via 127.0.0.1 <comment338592> Perhaps OSX is finding localhost as the IPv6 address ::1 - what does entering http://::1:8080   give <comment338721> @Mark Entering that exact URL into the Chrome address bar returns a Google search as if that was the search string. <comment338722> @Mark funny enough, the first thing in that page is a SuperUser SE question which mentions using http://[::1]:8080/ ... when I try *that* URL I get the same above error message, replacing localhost with [::1]. <comment338734> OK then does your server understand IPv6? ping is purely IPv4 ping6 does the new protocol <comment338735> @Mark it's actually listening explicitly on 127.0.0.1... tcp4       0      0  127.0.0.1.8080         *.*                    LISTEN tcp46      0      0  *.8080                 *.*                    LISTEN <comment338790> Definitely seems to be something with my app... although I'm now calling createServer exactly as you do in my app (not using express, basically stripped out everything http to match your example) and it *still* won't respond on localhost while your example will.
Determine flags that were given for packages installed with homebrew <body> Is there a way to check what flags were given when a package was installed with homebrew?  For example, the emacs formula has an absurd number of flags. If I did  precodebrew install emacs --with-glib --with-librsvg /code/pre  I would like to later determine that for the homebrew installation of emacs I gave the flags code--with-glib --with-librsvg/code and not any other flags.  Test case with lua package:  Before installing the package, info shows all options.  precode$ brew info lua lua: stable 5.2.3 (bottled) http://www.lua.org/ Not installed From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/lua.rb ==&gt; Options --universal     Build a universal binary --with-completion     Enables advanced readline support --without-sigaction     Revert to ANSI signal instead of improved POSIX sigaction /code/pre  I install the package with just the code--with-completion/code flag.  precode$ brew install lua --with-completion ==&gt; Downloading http://www.lua.org/ftp/lua-5.2.3.tar.gz ######################################################################## 100.0% ==&gt; Downloading http://luajit.org/patches/lua-5.2.0-advanced_readline.patch ######################################################################## 100.0% ==&gt; Downloading http://lua-users.org/files/wiki_insecure/power_patches/5.2/lua-5 ######################################################################## 100.0% ==&gt; Patching patching file Makefile patching file src/Makefile patching file src/lua.c Hunk #1 succeeded at 231 (offset -5 lines). Hunk #2 succeeded at 559 (offset -4 lines). Hunk #3 succeeded at 575 (offset -4 lines). patching file src/lua.c ==&gt; make macosx INSTALL_TOP=/usr/local/Cellar/lua/5.2.3_1 INSTALL_MAN=/usr/local ==&gt; make install INSTALL_TOP=/usr/local/Cellar/lua/5.2.3_1 INSTALL_MAN=/usr/loca   /usr/local/Cellar/lua/5.2.3_1: 13 files, 312K, built in 6 seconds /code/pre  After installing the package, info shows all options, including those I did not use. The command does acknowledge that the package was built from source and not poured from a bottle.  precode$ brew info lua lua: stable 5.2.3 (bottled) http://www.lua.org/ /usr/local/Cellar/lua/5.2.3_1 (13 files, 312K) *   Built from source with: --with-completion From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/lua.rb ==&gt; Options --universal     Build a universal binary --with-completion     Enables advanced readline support --without-sigaction     Revert to ANSI signal instead of improved POSIX sigaction /code/pre  <answer153290> When a package is built from source the flags that were used to build are shown when you do codebrew info &lt;package&gt;/code.  In this case: codebrew info emacs | grep "Built from source"/code  <answer227913> There is a file in code/usr/local/Cellar/code underneath each package that is called codeINSTALL_RECEIPT.json/code, e.g. for codegawk/code:  precode/usr/local/Cellar/gawk/4.1.3/INSTALL_RECEIPT.json /code/pre  that defines how the package was installed. I think the correct way to access it is with  precodebrew info --json=v1 &lt;packagename&gt; /code/pre  e.g.  precodebrew info --json=v1 gnuplot /code/pre  That spews out loads of stuff, but if you send it through codejq/code (JSON Processor - handily available via codehomebrew/code) you can select out the options you used to install the package like this (checking the codegnuplot/code package):  precodebrew info --json=v1 gnuplot | jq '.[].installed[0].used_options' [     "--with-qt" ] /code/pre  which tells me I installed codegnuplot/code using:  precodebrew install --with-qt gnuplot  /code/pre  <answer228741> Another useful tool is codehomebrew-bundler/code. Once installed via codebrew tap Homebrew/bundle/code, you can run codebrew bundle dump/code and it will create a Brewfile file that lists all of the packages you have installed along with any additional args used to install them.  <answer246422> Here's a little bash function that returns the flags irrespective of if package was built from source or not.  precodefunction brew_options() {     [ "$#" -ne 1 ] &amp;&amp; &gt;&amp;2 echo -e "$FUNCNAME requires only 1 option, the package name" &amp;&amp; return 1      local item=$1     local opts      ## Check if package installed     [ -n "$(brew ls --versions $item)" ] || ( &gt;&amp;2 echo -e "$item is not installed" &amp;&amp; return 1 )      set -o pipefail      ## Get options if built from source     if ! opts="$(brew info $item | grep 'Built from source with:' | sed 's/^[ \t]*Built from source with:/ /g; s/\,/ /g')" ; then         # If not built from source, get options from brew metadata         opts="$(brew info --json=v1 $item | jq -ec '.[].installed[0].used_options' | awk '{print substr($0, 2, length($0) - 2)}' | sed 's/,/ /g;s/"//g')"     fi      ## If we're able to get options and its just not spaces echo it      if [ "$?" -eq 0 ] &amp;&amp; [[ ! -z "${opts// }" ]]; then         echo "$opts"     fi      set +o pipefail  } /code/pre  <comment180590> The output of brew info always lists all available options for the formula, not the options used if the package was installed. <comment181143> That's not true. The info specifies if the package was installed from a bottle or built from source, and if it was built from source it shows the flags that were used. <comment181365> Edited OP with an example in which, as far as I can tell, info does not specify the flags used for a package built from source. <comment181368> Oh oops, I see it and your grep command makes sense now. <comment304818> This is indeed a nice option.  And, to edit the `Brewfile` and check it into your dotfiles repo makes it easy to "setup" new machines.  Though, it lists all packages including all dependencies.  I'm currently having to parse the list from a `brew leaves` list that lists only the top-level installed packages. <comment359640> depencency note: `jq` command-line JSON processor
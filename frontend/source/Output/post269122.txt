AppleScript: How to extract section from string (based on defined characters)? <body> Example:  codeset theText to "I ate an apple at 11:54 pm without the skin."/code  I would like codetheTime/code to be a string that contains the text: code11:54/code  So, I would like the opening text item delimiter to be codeat_/code and the closing text item delimiter to be either code_pm/code or code_am/code, depending on which period exists in the string. (Note - Every instance of an underscore in this post is meant to represent a space because I am unable to represent a space in the Stack Exchange code formatting.)  The contents of codetheText/code will vary greatly. For example, it might be:  codeset theText to "I ate two navel oranges at 6:30 am with a glass of water."/code   But the time format will always remain constant. The time will always be preceded with an "at " and that "at " will always be the first instance of an "at " in the string. Similarly, the time will necessarily be followed by either " am" or " pm".  <answer269167> Running the following AppleScript emcode/em in AppleScript Editor:  precodeset theText to "I ate an apple at 11:54 pm without the skin." set theTime to do shell script "awk -F ' at | am | pm ' '{print $2}'&lt;&lt;&lt;" &amp; quoted form of theText log "The time was: " &amp; theTime  set theText to "I ate two navel oranges at 6:30 am with a glass of water." set theTime to do shell script "awk -F ' at | am | pm ' '{print $2}'&lt;&lt;&lt;" &amp; quoted form of theText log "The time was: " &amp; theTime /code/pre  Produces the following output in the AppleScript Editor's Event Log:  precodetell current application     do shell script "awk -F ' at | am | pm ' '{print $2}'&lt;&lt;&lt;'I ate an apple at 11:54 pm without the skin.'"         --&gt; "11:54"     (*The time was: 11:54*)     do shell script "awk -F ' at | am | pm ' '{print $2}'&lt;&lt;&lt;'I ate two navel oranges at 6:30 am with a glass of water.'"         --&gt; "6:30"     (*The time was: 6:30*) end tell /code/pre  In the above examples I've defined the emfield separators/em (delimiters) in codeawk/code using the code-F/code emoption/em as code' at | am | pm '/code which equates to " at ", " am " and " pm " and it prints code'{print $2}'/code what's between the emfield separators/em.  Note: The use of the codelog/code emcommand/em is not necessary to the coding for the answer and is being used just to show what the emvalue/em of codetheTime/code contains for the Event Log output aside from what's shown after code--&gt;/code, which is the emresult/em as normally shown in the Event Log.  hr  Update: I wrote my original answer based on a literal interpretation in that when said, "emSo, I would like the opening text item delimiter to be codeat_/code and the closing text item delimiter to be either code_pm/code or code_am/code/em", what was wanted was to literally use those as the delimiters. However, since a different solution using empure/em AppleScript emcode/em, in a separate answer, was presented, let me present a one-line AppleScript emcode/em solution that does the same thing the 8 lines of empure/em AppleScript emcode/em does and by focusing on the emcolon/em, but as as part of a emRegEx/em representation of the time in hours and minutes.  precodeset theTime to do shell script "awk 'match($0,/[0-9]{1,2}:[0-5][0-9]/) {print substr($0,RSTART,RLENGTH)}'&lt;&lt;&lt;" &amp; quoted form of theText /code/pre  Running the following AppleScript emcode/em in AppleScript Editor:  precodeset theText to "I ate an apple at 11:54 pm without the skin." set theTime to do shell script "awk 'match($0,/[0-9]{1,2}:[0-5][0-9]/) {print substr($0,RSTART,RLENGTH)}'&lt;&lt;&lt;" &amp; quoted form of theText  set theText to "I ate two navel oranges at 6:30 am with a glass of water." set theTime to do shell script "awk 'match($0,/[0-9]{1,2}:[0-5][0-9]/) {print substr($0,RSTART,RLENGTH)}'&lt;&lt;&lt;" &amp; quoted form of theText /code/pre  Produces the following output in the AppleScript Editor's Event Log:  precodetell current application     do shell script "awk 'match($0,/[0-9]{1,2}:[0-5][0-9]/) {print substr($0,RSTART,RLENGTH)}'&lt;&lt;&lt;'I ate an apple at 11:54 pm without the skin.'"             --&gt; "11:54"     do shell script "awk 'match($0,/[0-9]{1,2}:[0-5][0-9]/) {print substr($0,RSTART,RLENGTH)}'&lt;&lt;&lt;'I ate two navel oranges at 6:30 am with a glass of water.'"             --&gt; "6:30" end tell /code/pre  As you can see, whether or not there are one to two numbers preceding the colon the RegEx matches and the codeawk/code emprogram/em returns the desired match, of which being the time.  Personally, I'd choose to use this particular method over my original answer, as it's a better method under the circumstances, and or over the empure/em AppleScript emcode/em as I can't justify writing 8 lines of empure/em AppleScript emcode/em when a single line of emregular/em AppleScript emcode/em produces the same results as the 8 lines do!  <answer269258> You can do it with pure AppleScript, even though the shell script method presented above is very nice:  precodeset theText to "I ate an apple at 11:54 pm without the skin." set the_colon_location to offset of ":" in theText -- now we know where the colon is. -- The Time is going to be on either side of it. set the_starting_point to the_colon_location - 2 set the_ending_point to the_colon_location + 5 set the_time_string to characters the_starting_point thru the_ending_point of theText as string -- in case the hour is not two digits, the first character will be a space if character 1 of the_time_string is " " then     set the_time_string to characters 2 thru -1 of the_time_string as string end if return the_time_string /code/pre  <comment338226> I have updated my original answer to include a space _before_ and _after_ the three _field separators_ (delimiters) " at ", " am " and " pm " as it makes more sense to do so and not just a single space as originally written. <comment338255> This is another good solution, thanks. <comment338256> Cheers, thanks for the update. <comment338587> I've update my answer again to show how a single line of _regular_ AppleScript _code_ does what the 8 lines of _pure_ AppleScript _code_ does in the other answer. <comment338615> Nice, thanks. However I've realized that I actually prefer your original solution because it is more restrictive, as it exactly addressed my original question with a literal interpretation (like you noted). In general, I like to make as few assumptions as possible when I am writing code, to be conservative. While it may not be common or expected, a colon could potentially exist before the time in `theText` string, which would disorient a colon-based method of getting `theTime`. <comment338903> It's always nice to know how to do the same thing in different ways, but when `set theTime to do shell script "awk 'match($0,/[0-9]{1,2}:[0-5][0-9]/) {print substr($0,RSTART,RLENGTH)}'" & quoted form of theText` produces the same results in one line of _regular_ AppleScript _code_ that takes 8 lines of your _pure_ AppleScript _code_ to do, I don't believe I'd ever use your method. However, I have added it to my file of code snippets so as to have an example of the logic flow, in case I find a compelling reason to use it over an `awk` solution. <comment339149> Totally understood. However, my answer was not meant to compete on speed or on line count. It was meant to be readable and understandable by as many people as possible. I completely tip my hat to the use of regular expressions in the other solution.
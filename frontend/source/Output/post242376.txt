Seeking a clean way to mount a directory on one HFS+ drive as a directory on another such drive on same machine <body> I need to seamlessly mount (and automount, e.g. via fstab) a directory (folder) on one drive to appear at the commandline and GUI level as a directory on another, on the same machine. This is to defeat some "smart" software that detects that symlinks and aliases are not "real" directories and refuses to act on them.  In Linux, this would be trivially easy, with:br /  codemount --bind /path1/source_dir /path2/target_dir/codebr / However, Mac OS's version of mount does not support this bind functionality (in any form, including codemount -o bind/code, or codemount -B/code), as far as I can determine. It also appears that none of Macports, Homebrew, or Fink supply a ported version of mount with such an option.  Some available more specialized mounting tools don't seem to relate, either (e.g. xmount is for disk images, and djmount is for network volumes).  To be clear, I'm not trying to mount a disk or partition as a volume or as a local directory, nor to create a share to be mounted arbitrarily by various users on various machines. Rather, I want to mount a folder, owned and writable only by a particular user, on an HFS+ disk as if it were a folder on another HFS+ disk, locally, in a way that is effectively transparent, with the same permissions and no security/integrity issues.  A sloppy workaround is to create a CIFS share of the folder to be mounted, and (calling a custom, one-shot variant of smb.conf) limit its permissions in Samba just-so, such that it is not public, and has the same permissions as the target location, exactly the right file and directory mask, etc.; then mount it that way. But this would be inefficient, since it would be using the bletcherous Windows filesharing protocol, plus creating a visible share that shows up as a mountable volume from the SMB server, to anyone who can access this machine though SMB/CIFS (even if they cannot actually mount it). The Mac GUI will probably also represent it as a volume being shared.  <answer242379> To mount a hard drive on a custom mountpoint:     You can do this with codediskutil mount/code and the code-mountPoint/code option.   From the man page:           strongmount [readOnly] [-mountPoint path] device/strong          Mount a single volume.  If readOnly is specified, then the file system is mounted read-only, even if the volume's underlying file     system and/or device and/or media supports writing; even the     super-user may not write to it; this is the same as the rdonly option     to mount (8).  If a -mountPoint is specified, then that path, rather     than the standard path of /Volumes/VolumeName, will be used as the     view into the volume file con- tent; a directory at that path must     already exist.          From codeman diskutil/code, section 'Verbs'.         The syntax to mount to a custom mountpoint is as follows:  precodediskutil mount -mountPoint /path/to/custom/mountpoint [volume (identifier/UUID/label)] /code/pre      Bear in mind that code/path/to/custom/mountpoint/code strongmust be a   directory/strong, just like with codemount/code, and that your   identifier/UUID/label are specific to the volume (i.e. code/dev/diskXsY/code   not code/dev/diskX/code). Mounting to a custom mountpoint cannot be done with   codediskutil mountDisk/code, and only works with a single volume at a time.   From my answer to How to mount disk by UUID or LABEL in OS X El Capitan.  I've tested this by "mounting" a USB stick on an external hard drive. As an example,  precode$ diskutil list /dev/disk0 (internal, physical):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *500.3 GB   disk0    1:                        EFI EFI                     209.7 MB   disk0s1    2:                  Apple_HFS Macintosh SSD           499.4 GB   disk0s2    3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3 /dev/disk1 (external, physical):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *1.0 TB     disk1    1:                        EFI EFI                     209.7 MB   disk1s1    2:                  Apple_HFS HDD-1T                  999.8 GB   disk1s2 /dev/disk2 (external, physical):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:     FDisk_partition_scheme                        *31.6 GB    disk2    1:               Windows_NTFS USB-32                  31.6 GB    disk2s1 /code/pre  As you can see, code/dev/disk2s1/code, or codeUSB-32/code is the name of the USB stick I am going to mount on the hard drive, code/dev/disk1s2/code, or codeHDD-1T/code. To do so, make use of the code-mountPoint/code option. But first, make sure there is a landing directory to mount onto:  precode$ mkdir /Volumes/HDD-1T/mountpoint /code/pre  And now, to mount:  precode$ diskutil mount -mountPoint /Volumes/HDD-1T/mountpoint /dev/disk1s2 /code/pre  The mounted disk will appear in the following locations: code/Volumes/code,  and code/Volumes/HDD-1T/mountpoint/code as codeUSB-32/code and codemountpoint/code respectively.  Be sure to unmount (codediskutil umount/code) your codeUSB-32/code equivalent before remounting on your codeHDD-1T/code equivalent.  <comment298116> "...as if it were a folder on another HFS+ disk..."
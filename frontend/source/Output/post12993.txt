Why doesn't .bashrc run automatically? <body> I put some alias commands in my code.bashrc/code file, so that they might be loaded everytime I open a new Terminal window. Yet this doesn't happen.  I have to select coderun script:/code in the TerminalPreferences"emMyDefaultTheme/em"Shell prefpane and add:  codesource .bashrc &amp;&amp; clear/code for it to work...   This seems odd since many tutorials only say you just have to add to the code.bashrc/code file and all is good.  Note that I don't run in codebash/code when using the terminal, I like the other (default) one (don't know what it is) better, because it show me where I am all the time eg:  precode&gt;&gt;d54c6b47b:~ romeo$ /code/pre  in stead of:  precode&gt;&gt;bash$ /code/pre  In bash all is loaded as should be.   So my question is, why didn't my code.bashrc/code file load automatically and did I have to add the option to call it everytime?   Also some tutorial told me to do something like:  precode$alias la=’ls -la’ &gt;&gt; ~/.bashrc /code/pre  which should write the alias to my code.bashrc/code, this doesn't work either...  Note that I'm a UNIX novice, so be gentle.  <answer13014> Just put that in your code.profile/code file from your home dir and it should work the next time you start a new shell or after you run codesource ~/.profile/code  This link clearly states the order in which the startup files are read and loaded by the shell: http://hayne.net/MacDev/Notes/unixFAQ.html#shellStartup  <answer13019> emBeen there, done that./em What I came aware of, OS X doesn't read code.bashrc/code file on bash start. Instead, it reads the following files (in the following order):  ol licode/etc/profile/code/li licode~/.bash_profile/code/li licode~/.bash_login/code   /li licode~/.profile/code/li /ol  See also Chris Johnsen's informative and useful comment:     By default, emTerminal/em starts the shell via code/usr/bin/login/code, which makes the shell a login shell. On every platform (not just Mac OS X) embash/em does not use code.bashrc/code for login shells (only code/etc/profile/code and the first of code.bash_profile/code, code.bash_login/code, code.profile/code that exists and is readable). This is why "put codesource ~/.bashrc/code in your code.bash_profile/code" is standard advice   strongI/strong usually just put the things that I'd normally put in code~/.bashrc/code to code~/.profile/code — has worked so far like a charm.  <answer13025> I put everything into code~/.bashrc/code and just codesource ~/.bashrc/code in .profile.  This allows screen and xterm (and i guess tmux) sessions to inherit my environment as non-login sessions only run code.bashrc/code, whereas login sessions (eg terminal or iTerm) only run code.profile/code.  <answer40469> Putting...  precode[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm" # Load RVM function /code/pre  ...in code~/.bashrc/code, and then source code~/.bashrc/code into my code~/.bash_profile/code  didn't work for the Terminal program that comes installed.  But then I went to the menu drop-down strongEdit  Profile Preferences/strong, strongTitle and Command/strong tab, and selected strongRun command as a login shell/strong from the command section of that page.  After doing so, starting a new terminal shows the desired result when I type   precode type rvm|head -1 /code/pre  i.e. "rvm is a function". It did not do that until I made this change, and it's the only change I made after the code.bash_profile/code and code.bashrc/code changes described in other answers here.  <answer58111> I found that after installing rvm (auto-installer, no manual edits) it had created a code~/.bash_login/code file for itself, where I previously never had one.  However, this mean that my code~/.profile/code setups and aliases no longer got loaded! Lots of shortcuts disappeared. I thought they ran sequentially, not exclusively :-/  I added   precode. ~/.profile  /code/pre  to code~/.bash_login/code to chain things as I expected.  <answer65137> First of all let me tell you that code~/.bashrc/code is the file which is executed every time a second shell is called up (when running a shell script, for instance), and code~/.profile/code is called on every login.  So I recommend you to write code. ~/.bashrc/code command in your code~/.profile/code file, and this command will execute the bashrc file every time you login.  <answer67233> Sourcing .profile in .bash_profile did it for me  precodeecho 'source ~/.profile' &gt;&gt; ~/.bash_profile /code/pre  <answer93038> To keep with the OSX style login code.profile/code and support the normal bash behavior code.bashrc/code you can use a code.bashrc/code file if you switch between regular nix and OSX by providing a symbolic link to your code.bashrc/code file called code.bash_profile/code. Just make sure this file doesn't exist already before trying this, but this is how I do it.   precodeln -s .bashrc .bash_profile /code/pre  <answer147132> There are two scenarios:  ol liYou are using Linux/li liYou are using Mac Os X/li /ol  For both you want to source code~/.bashrc/code in your profile that gets loaded, or sourced, when your shell for your terminal starts.  hr  LINUX  In Linux, code~/.profile/code is automatically source in your shell when it starts. So, if you go to your terminal and type codecd ~; ls -A/code, you will see all of your files and directories in your home directory (code/home/usrname//code). You should see a file called code.profile/code. This is the file that is automatically "sourced" when you start the terminal.  If you want to add aliases and functions to code~/.bashrc/code (which is what I do), then you should (inside of code~/.profile/code add an if statement that checks if code~/.bashrc/code is a non-empty file and then source it.  To check if your code~/.profile/code already does this enter codenano ~/.profile/code. This will open it up in a text editor (you can use gedit if you know you have it or even vim if you know how to use it). You may get an empty text file (you shouldn't), but if you do simply proceed. If you do not see a line emanywhere/em that says codesource ~/.bashrc/code, then enter the following lines somewhere (put it in a reasonable place like at the end or beginning and not in the middle of an if statement):  precodeif [ -s ~/.bashrc ]; then     source ~/.bashrc; fi /code/pre  This checks if code~/.bashrc/code is a non-empty file (with if code[ -s ~/.bashrc ]/code), and if it is such, it sources it. Pretty simple. Now, you can add any valid alias, function, variable, etc to code~/.bashrc/code.  hr  MAC OS X  By default, Max OS X sources code~/.bash_profile/code. To be able to add things to code~/.bashrc/code (which is, again, what I do in OS X, as well), then you follow the same procedure as linux. In the terminal enter codecd ~; nano .bash_profile/code. Check for a line that says codesource ~/.bashrc/code and if it's not there add the if statement above (codeif [ -s ~/.bashrc ]; then source ~/.bashrc; fi/code).  hr  NOTES  When writing an if statement, be sure to leave spaces between basically everything (for example codeif [ -s ~/.bashrc]; then echo "found"; fi/code does not work because there is no space beween code~/.bashrc/code and code]/code - the interpreter will think this is one word).  If you want to figure out how to check for stuff in an if statement better, go to terminal and enter codeman \[/code; this essentially gives you the run-down of an if statement. For example, codeif [ -f /path/to/file ]; then echo "it's a file"; else echo "not a file"; fi/code checks if code/path/to/file/code is a file and if it is prints to stdout accordingly. I always reference this as well for easier-on-the-eyes and quick reference: 7.2. File test operators.  I hope this helps. I remember how confused I was when I started all of this stuff (which wasn't too long ago); so, good luck with your future UNIX endeavours!  <answer251957> /etc/bashrc is for global profiles on mac systems. You can add: alias ls="ls -G" to the top of this file and your good, everyone will have colorized files and folders on the system so you will not have to set anything extra for each individual user. You will also notice along with "sudo su -" to root from yourself you will still have colorized files and folders with no extra headaches.   Another fun tip: When using mac's Iterm2, importing color profiles will render the coloring of the files and folders immediately according to your color scheme after having this "/etc/bashrc" option set.  <answer288582> I ran into the same issue after installing rbenv on my remote server (Digital Ocean) Ubuntu 16.04.  It somehow created code~/.bash_profile/code. It's the same code~/.bashrc/code on an OS X system.  And Ubuntu started to read only code~/.bash_profile/code, but not code~/.bashrc/code as it should.  So I just backed up my data in code~/.bash_profile/code with this:  precodemv ~/.bash_profile ~/.bash_profile.bak /code/pre  And renamed the old code~/.bashrc/code to code~/.bash_profile/code  precodemv ~/.bashrc ~/.bash_profile /code/pre  It worked for me. After my ssh login I have everything loaded in code~/.bashrc/code.  <comment13659> I think this is very close to http://apple.stackexchange.com/questions/7984/change-terminal-apps-default-shell-to-bash. <comment13693> @boehj well it mentions "not loading `.bashrc`" but that's about it. <comment13701> OK, sorry if I confused things here. <comment13715> By default, *Terminal* starts the shell via `/usr/bin/login`, which makes the shell a login shell.  On every platform (not just Mac OS X) *bash* does not use `.bashrc` for login shells (only `/etc/profile` and the first of `.bash_profile`, `.bash_login`, `.profile` that exists and is readable). This is why “put `source ~/.bashrc` in your `.bash_profile`” is standard advice. <comment13716> accepted this one because it is has a solution (and it was the first of two near identical posts). <comment16712> this worked for me, thanks <comment23988> Re "I usually just put the things that I'd normally put in ~/.bashrc to ~/.profile": For maximum compatibility I recommend you follow Chris Johnsen's advice and place anything that you want to apply to non-login shells in ~/.bashrc and add "source ~/.bashrc" to your ~/.bash_profile to run it for login shells. Otherwise, it won't work for sub-shells, or if Terminal changes to create non-login shells, or if you ever use xterm or another terminal program that create non-login shells by default, or if you might want to use the same setup on another OS. <comment23989> On a related note, on Mac OS X you should consider having ~/.bashrc run /etc/bashrc to pick up global behaviors. In particular, there's code in /etc/bashrc to update the working directory at each prompt, which is what enables Terminal to display the proxy icon, create new terminals at the same directory, and restore the working directory for Resume and Window Groups. <comment60568> You probably like `csh` (or another variant) better.  But you should know that the `bash$` can be changed :) <comment76525> when .profile get executed on login it automatically execute the .bashrc file. <comment76526> so .bashrc gets executed indirectly at every login <comment89616> For me, sourcing .bashrc from .bash_profile didn't work.  But sourcing .bashrc / .bash_profile from .profile worked. <comment96571> Upvote for "This is why "put source ~/.bashrc in your .bash_profile" is standard advice" <comment98363> +1, this is situation I had.  I found that either .bash_login or .bash_profile will prevent .profile from being executed...  No idea why bash feels the need to have so many conflicting startup files. <comment104411> ~/.profile works on iOS! <comment109173> bashrc is for non-login shells. bash_profile/bash_login/profile/whatever else is for login shells. This is a source of a huge amount of contention, involving what is and isn't a login shell (a screen/tmux session for example, a terminal within a desktop environment, etc.). It's not necessarily the "second shell". It's a matter of shell entry. <comment146205> If you ever use a shell that isn't Bash, doing what you describe might cause you problems. .profile applies to all shells and .bashrc might contain language that some other shells don't understand. Instead of .profile, put what you wrote in .bash_profile. (Also, make the first thing .bash_profile does be "source .profile".) <comment146206> @RajkumarMasaniayan, are you using a shell other than Bash? What does `echo $SHELL` output? <comment146208> Sourcing .profile in .bash_profile is a great thing to do, but that alone wouldn't cause .bashrc to be run by login shells. Your .profile must've already sourced .bashrc, which could cause problems if you ever use a shell other than bash. Most Mac users never will, but if you do for some reason, remember this. :) <comment155131> This is my approach.  This way I can maintain a .bashrc that works on both systems... and I can put any mac specific stuff or stuff like aliases that are only for work (where I use the mac the most) in my .bash_profile file. <comment172891> By doing this linking between 2 differents shell initialisation script you are loosing a necessary separation of function. One day or another you will need an initialisation at the session level (`.bash_profile`) and an initialisation different at each shell level (`.bashrc`). <comment263238> Nice answer but a bit misinformed. I believe the bash terminal loads only **one** of the `~/.bash_profile`, `~/.profile`, `~/.bash_login`, never all of the them. You can run a simple test by creating the 3 files.  It looks like the bash terminal has the preference of `~/.bash_profile`  `~/.bash_login`  `~/.profile`.  If anyone of them exists, the ones of less preference are skipped. That's why sometimes it is recommended to also source `~/.profile` in `~/.bash_profile`. <comment264198> Down-voted. I recommend against following this advice. The issue is that Terminal creates login shells, and Bash login shells _only_ run the login startup script, not `~/.bashrc`. However, the solution isn't to simply place your `.bashrc` content into the login startup file, because these two files are intended to perform different types of setup. Instead, the canonical setup for Bash is to have your `~/.bash_profile` source your `~/.bashrc` at some appropriate point in the script (usually last). <comment264202> `.profile` is common to several different shells and should only contain POSIX-compatible sh code. `.bash_profile` is Bash-specific and can contain Bash-specific code. In general, if you're using Bash you should prefer `.bash_profile` unless you are careful to ensure that your startup code does not contain anything that depends on Bash. Whatever program created `.bash_login` probably did so because it contains Bash-specific code, but it should have included code to source `.profile` if it exists. <comment264203> Note that `.profile` is common to several shells and should only contain POSIX-compatible sh code. If it sources `.bashrc` it arguably contains Bash-specific code (the existence of the `.bashrc` file is Bash-specific). I recommend renaming your `.profile` to `.bash_profile` since you're using it in a Bash-specific way. Or, put generic code in `.profile` and create a `.bash_profile` that sources `.profile` and `.bashrc`. <comment264205> To expand on what @TerryN said: be sure to source `.bashrc` from your `.bash_profile` and not from `.profile`. `.bash_profile` is Bash-specific and should source the other two. <comment285597> I see no other identical post this just says put in the sh file <comment291024> on El Capitan, I still have to source my `.bashrc` , or `.bash_profile` first to be able to use alias that I set, I dont know where to place my alias to keep it permanent everytime I open a new terminal <comment321942> If you want commands to run *onload*, create `.profile` in your home directory <comment372632> On linux, `.profile` is only sourced if your shell is a login shell, otherwise `.bashrc` is sourced
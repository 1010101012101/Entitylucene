AppleScript: Is it possible to check if Speech is currently running? <body> I want to exactly recreate macOS's built-in Text To Speech keyboard shortcut feature with AppleScript. When I say "exactly," I mean "exactly."  The built-in option can be found in System Preferences → Dictation &amp; Speech → Text to Speech:  img src="https://i.stack.imgur.com/pGvbH.png" alt="screen shot"  Here is the description of this feature:     Set a key combination to speak selected text.      Use this key combination to hear your computer speak selected text. If the computer is speaking, press the keys to stop.   The reason that I want to recreate this feature (instead of simply using it) is because it is buggy; sometimes it works, but, other times, I press the keyboard shortcut and nothing happens. If I code it manually in AppleScript, I hope that the process will be more reliable.  hr  I understand how to start and stop Speech in AppleScript, as explained here.  But I would like to use the same keyboard shortcut, and thus the same .scpt file, to both start and stop the Speech, mirroring the functionality of the built-in Speech keyboard shortcut.  I am using FastScripts to run the .scpt file by a keyboard shortcut.  If the same .scpt file is in charge of both starting and stopping the Speech, the script requires an if statement at the top of the AppleScript, or something similar, to immediately check if Speech is currently being spoken or not, before the script can proceed. I do not know how to implement this check, or if it is even possible.  But, here's what I have:  precodeif &lt;This is where I need your help, Ask Different&gt; then     say "" with stopping current speech     error number -128 -- quits the AppleScript end if    -- Back up original clipboard contents: set savedClipboard to my fetchStorableClipboard()  -- Copy selected text to clipboard: tell application "System Events" to keystroke "c" using {command down} delay 1 -- Without this, the clipboard may have stale data.  set theSelectedText to the clipboard  -- Restore original clipboard: my putOnClipboard:savedClipboard  -- Speak the selected text: say theSelectedText waiting until completion no      use AppleScript version "2.4" use scripting additions use framework "Foundation" use framework "AppKit"   on fetchStorableClipboard()     set aMutableArray to current application's NSMutableArray's array() -- used to store contents     -- get the pasteboard and then its pasteboard items     set thePasteboard to current application's NSPasteboard's generalPasteboard()     -- loop through pasteboard items     repeat with anItem in thePasteboard's pasteboardItems()         -- make a new pasteboard item to store existing item's stuff         set newPBItem to current application's NSPasteboardItem's alloc()'s init()         -- get the types of data stored on the pasteboard item         set theTypes to anItem's types()         -- for each type, get the corresponding data and store it all in the new pasteboard item         repeat with aType in theTypes             set theData to (anItem's dataForType:aType)'s mutableCopy()             if theData is not missing value then                 (newPBItem's setData:theData forType:aType)             end if         end repeat         -- add new pasteboard item to array         (aMutableArray's addObject:newPBItem)     end repeat     return aMutableArray end fetchStorableClipboard   on putOnClipboard:theArray     -- get pasteboard     set thePasteboard to current application's NSPasteboard's generalPasteboard()     -- clear it, then write new contents     thePasteboard's clearContents()     thePasteboard's writeObjects:theArray end putOnClipboard: /code/pre  (Originally, I had wanted the AppleScript to speak codethe clipboard/code, but then I realized that this was overwriting the original clipboard contents. So, I actually want the AppleScript to speak the contents of the codetheSelectedText/code variable, as demonstrated in the above code.)  <answer272699> It's possible with the codesay/code command in a shell, not with the AppleScript codesay/code command.  Info for the AppleScript say command:   ul liyou can stop the speech of say command from the same script until the script run, not after that the script exit./li liExample:/li /ul   precodesay "I want to recreate macOS's built-in Text To Speech" waiting until completion no delay 0.5 say "" with stopping current speech -- this stop the first say command of this script delay 1 say "Hello" /code/pre   hr  This script use the codesay/code command in a shell to speak the contents of the codepbpaste/code command (the clipboard), and it put the PID of the codesay/code command to a persistent property:  precodeuse AppleScript version "2.4" use scripting additions use framework "Foundation" use framework "AppKit" property this_say_Pid : missing value -- the persistent property  if this_say_Pid is not missing value then -- check the pid of all 'say' commands, if exists then quit the unix process     set allSayPid to {}     try         set allSayPid to words of (do shell script "pgrep -x 'say'")     end try     if this_say_Pid is in allSayPid then -- the PID = an item in the list         do shell script "/bin/kill " &amp; this_say_Pid -- quit this process to stop the speech         error number -128 -- quits the AppleScript     end if end if  -- Back up original clipboard contents: set savedClipboard to my fetchStorableClipboard()  -- Copy selected text to clipboard: tell application "System Events" to keystroke "c" using {command down} delay 1 -- Without this, the clipboard may have stale data.  -- Speak the clipboard: --  pbpaste = the contents of the clipboard , this run the commands without waiting, and get the PID of the 'say' command  set this_say_Pid to do shell script "LANG=en_US.UTF-8 pbpaste -Prefer txt | say &gt; /dev/null 2&gt;&amp;1 &amp; echo $!"  -- Restore original clipboard: my putOnClipboard:savedClipboard  on fetchStorableClipboard()     set aMutableArray to current application's NSMutableArray's array() -- used to store contents     -- get the pasteboard and then its pasteboard items     set thePasteboard to current application's NSPasteboard's generalPasteboard()     -- loop through pasteboard items     repeat with anItem in thePasteboard's pasteboardItems()         -- make a new pasteboard item to store existing item's stuff         set newPBItem to current application's NSPasteboardItem's alloc()'s init()         -- get the types of data stored on the pasteboard item         set theTypes to anItem's types()         -- for each type, get the corresponding data and store it all in the new pasteboard item         repeat with aType in theTypes             set theData to (anItem's dataForType:aType)'s mutableCopy()             if theData is not missing value then                 (newPBItem's setData:theData forType:aType)             end if         end repeat         -- add new pasteboard item to array         (aMutableArray's addObject:newPBItem)     end repeat     return aMutableArray end fetchStorableClipboard   on putOnClipboard:theArray     -- get pasteboard     set thePasteboard to current application's NSPasteboard's generalPasteboard()     -- clear it, then write new contents     thePasteboard's clearContents()     thePasteboard's writeObjects:theArray end putOnClipboard: /code/pre  hr  It's possible that the first script will not work, if the value of strongthis_say_Pid/strong variable doesn't persist across runs, it depends how the script will be launched. In that case, you must write the PID to a file, so use this script:  precodeuse AppleScript version "2.4" use scripting additions use framework "Foundation" use framework "AppKit"  set tFile to POSIX path of (path to temporary items as text) &amp; "_the_Pid_of_say_command_of_this_script.txt" -- the temp file set this_say_Pid to missing value try     set this_say_Pid to paragraph 1 of (read tFile) -- get the pid of the last speech end try  if this_say_Pid is not in {"", missing value} then -- check the pid of all 'say' commands, if exists then quit the unix process     set allSayPid to {}     try         set allSayPid to words of (do shell script "pgrep -x 'say'")     end try     if this_say_Pid is in allSayPid then -- the PID = an item in the list         do shell script "/bin/kill " &amp; this_say_Pid -- quit this process to stop the speech         error number -128 -- quits the AppleScript     end if end if  -- Back up original clipboard contents: set savedClipboard to my fetchStorableClipboard()  -- Copy selected text to clipboard: tell application "System Events" to keystroke "c" using {command down} delay 1 -- Without this, the clipboard may have stale data.  -- Speak the clipboard:  --  pbpaste = the contents of the clipboard , this run the commands without waiting, and it write the PID of the 'say' command to the temp file do shell script "LANG=en_US.UTF-8 pbpaste -Prefer txt | say &gt; /dev/null 2&gt;&amp;1 &amp; echo $! &gt; " &amp; quoted form of tFile  -- Restore original clipboard: my putOnClipboard:savedClipboard  -- *** Important *** : This script is not complete,  you must add the 'putOnClipboard:' handler and the 'fetchStorableClipboard()' handler to this script. /code/pre  <comment342746> Just wanted to add, there actually is a way to tell if the (Apple)Script Editor or an AppleScript app, etc. is running the AppleScript `say` _command_. Taking readings with `ps` and `lsof` before, during and after, I was able to isolate a pattern, using `diff`, of files that come into play that are linked to the calling process and could be coded to test for. However I'd probably opt for your method as it's just to easy use the method you've proposed or to use `pgrep say` to get its `PID`. <comment342782> @jackjr300 I added some important details to my question and I realized that I actually do not want to use the clipboard directly as the speak-text source, since then the original clipboard contents may be lost; please see my edit. But anyway...your first solution did not halt the currently speaking text and instead simply triggered the Speech command again, so that they were overlapping; the two speeches happen simultaneously. The second solution behaves the same way, where, e.g., 5 speeches all speak at the same time if I run the .scpt file 5 times in a row. Does it work correctly for you? <comment342821> @rubik's sphere, The script copied and pasted from this pages doesn't work because the result of the command `do shell script "/bin/ps ....` contains a space character before the pid, while the result of my saved script is the PID only. Anyway the script is changed according to your need. <comment342822> @user3439894 Yes, I will use the `pgrep` command now, thanks. <comment342898> @jackjr300 (1/2) I appreciate it. We're getting closer, but there's still a bug in your code. This is true of both the first and second solutions. When I first run your code (either the first or the second solution), the selected text is spoken. Great. Then, I immediately run the code for a second time and the speaking is stopped. Great. But, if I run the script a third time, instead of the selected text being spoken, the clipboard text is spoken (as in, the original clipboard contents before the selected text is copied to the clipboard). But, if I wait exactly 6 minutes before <comment342899> (2/2) running the code again, the script works correctly for one run (i.e., the script speaks the selected text instead of the clipboard text), but then the cycle repeats itself, where I have to wait another 6 minutes if I want the script to speak the selected text instead of the original clipboard text. Also, I don't know if this is a separate issue or if this is related to the aforementioned bug, but occasionally I have to run the script twice in order to get a current speech to stop; running the script during a speech does nothing, so I run it again, and that does stop the speech. <comment342931> I tested with the 'FastScripts' utility  (I use a keyboard shortcut to run the script) , and I don't have this issue on my machine (even on huge selection). Make sure that the shortcut `keystroke "c" using {command down}` works from the frontmost application, if you hear a beep (the keystroke did not work).  Try to increase the time in seconds of the `delay` command.  Try to add a `delay` command before this line `my putOnClipboard:savedClipboard`. Try to add a `delay` command before this line `tell application "System Events" to keystroke "c" using {command down}`. <comment342951> @jackjr300 Now, just to simplify the debugging process for me, are you referring to your _first_ block of code or your _second_ block of code when you say that it works correctly for you with a keyboard shortcut assigned to the script in FastScripts? <comment343015> @rubik's sphere, I use my first block of code on **macOS Sierra V10.12.3** <comment343130> @jackjr300 (1/2) I've found the issue. I apologize for pinning the bug on your code. As you may notice in my original post, I've been using the F8 key to trigger the script. Since F8 is a top-row function key (set as a fixed play/pause control for iTunes), I'd downloaded a piece of third-party software entitled FunctionFlip to free up my F8 key. Well, FunctionFlip has been responsible for all of the responsiveness issues that I described. I've stopped using FunctionFlip and [now use Karabiner to free up keys](http://apple.stackexchange.com/questions/272863/). I'm using your first block <comment343131> (2/2) of code and it works perfectly. The keyboard shortcut and the script are 100% reliable. I've even changed your `delay 1` line to `delay 0.1`, and it still works perfectly. I then compared your script's response time to the response time of the built-in Text To Speech keyboard shortcut, and your script is actually slightly faster, both in terms of starting speech and stopping speech. Thanks for your help! I'm just going to add a check to your code so that if the selected text is empty when the script is run, the code does not speak the clipboard text, but instead quits the script.
Why does Spotlight give a wrong value for `cos(pi/2)`? <body> As you might know, Spotlight can do simple mathematics. For instance, typing codecos(pi)/code will result in code-1/code, as you might expect. I just typed in codecos(pi/2)/code, which should be 0 but it gave me code-5e-12/code.  Yes it is probably due to a rounding error, but come on: codecos(pi/2)/code!  In my opinion, that clearly looks like bug. What do you think?  <answer123996> It's due to the lack of precision of pi and due to the overall all lack of precision in the built-in system.   precodepi = 3.1415926536  pi/2 = 1.5707963268   cos(1.5707963268) = -5.103412e-12  FYI =  5.103412e-12 = 0.000000000005103412 ~ 0  /code/pre  br /  About the overall system precision :   precode3.141592653589793238462643383 = 3.1415926536  /code/pre  In Python we get following :   precode&gt;&gt;&gt; float("3.141592653589793238462643383") 3.141592653589793 /code/pre  As we can see there is a problem with the precision since it doesn't even match the float representation.   <answer123997> It is a bug that's reproducible on 10.9.2 - and a floating point rounding error one like that is quite typical.  It's the value of pi that is being handled without enough precision if I had to guess.  ul licos(999999*pi) doesn't have an error/li licos((999999+1)*pi) does have an error - likely rounding/li /ul  I'd head to https://developer.apple.com/bug-reporting/ if you want to see Apple's bug fixing apparatus in action.  <answer123998> Considering that code-5e-12/code is a verryyyy small number, this strongis/strong a rounding error.  I think it's the consequence of spotlight showing more decimals than than are used in the definition of the codepi/code constant or the infinite series used to calculate trig functions.  <answer124060> From the other answers and comments the following becomes clear:  The fact that you get a nonzero result is NOT a bug, even with a perfect implementation of the software you would run into the limits of floating point calculations. However, the error in the order of 10^-12 is really big.  This is NOT to blame to the inaccuracy of floating point numbers. The result you get is just this:  precodecos(1.5707963268) /code/pre  That can be validated using any alternative software package. If you were to evaluate codecos(pi/2)/code in one of those packages you will definitely get a result much closer to zero than 10^-12.  To conclude I see two possible limitations, one of which must apply:  ol liPi is not stored with sufficient precision, or at least pi/2 results in insufficient precision/li liCos simply takes insufficient precision as input/li /ol  Perhaps someone with acces to the software can validate which of these applies.  strongUpdate/strong As mentioned in the comment the problem seems to be the accuracy of the constant codepi/code.  <answer124117> They are not storing π with unusual floating-point precision.  They are using an incorrect value for π with double precision.  To emapproximate/em 3.1415926536 in binary, at least 38 bits are required:  precode3.14159265359922… &gt; 11.001001000011111101101010100010001001 /code/pre  Notice that 2^-36 is about 1.5e-11, which coincides with the trailing 99.  Double-precision floating-point has a 52-bit significand.  To evaluate codecos(pi/2)/code as -5e-12, the only other possible choice would be a 48-bit type, which would be very strange.  Near 0 and π, where the derivative is nearly zero, cos(θ) cannot be calculated very accurately:  codecos(3.1415926536) ≈ -0.999999999999999999999947911/code  That differs from -1 by about 5.2e-23, which is smaller than ε for codedouble/code, so codecos(3.1415926536)/code is calculated as emexactly/em -1... which is incorrect.  Near ±π/2, the derivative [em-sin(θ)/em] is nearly ±1, so the error at the input becomes the output.  precodecos(1.57079632679961) ≈ -4.71338076867830836e-12 cos(1.57079632679962) ≈ -4.72338076867830836e-12 cos(1.57079632680000) ≈ -5.10338076867830836e-12 /code/pre  I happen to have a TI calculator that displays one less digit and calculates codecos(π/2)/code as -5.2e-12.  However, it is very different electronically and was designed to give an exact value for codecos(90°)/code.  I would guess that in Spotlight, codecos(pi/2)/code is being calculated by retrieving a value for π, emconverting to a decimal string/em, storing that as the (exact, rational) binary value 11.00100100001111110110101010001000100100001101101111 (or 10000), dividing by 2, and then essentially subtracting that from the emtrue value/em of π/2.  You should find out whether codecos(pi/2 + cos(pi/2))/code is closer to zero (it might be -2.2e-35).  Multiplication by a power of two should affect only the exponent, not the significand.  It might be possible to determine how rounding is applied by repeated halving or doubling.  <comment144885> Is it a bug, really? What should be the precision on such a operation? <comment144886> I am not a registered developer, but I would be very grateful if you could submit it for us! <comment144890> @poitroae You can sign up for free as a safari developer and possibly there is still a free Mac tier. I've got a list of bugs to write, so I'll leave his one for someone else to file. <comment144891> @Édouard be nice to the asker - I've edited your comment on the main question. If you wanted to explain how this happens, I'd up vote it. Apple's numerics are typically well behaved for rounding errors so I was a little surprised that spotlight wasn't more precise. <comment144893> @Édouard You *might* consider it a bug if the user has been led to expect some capability for symbolic mathematics. Any computer algebra system (CAS) will of course know that cos(π/2)=0 exactly! On the other hand, it is hardly reasonable to expect Spotlight to contain a CAS. And in the realm of floating point arithmetic, results like the OP reports are to be expected. Any bug report might be better labeled a feature request, perhaps. <comment144912> @Édouard bmike is in fact correct that *this is a bug* and not just roundoff error.  The expected precision of such an operation, given standard double precision arithmetic, is about 10^-16, not 10^-12.  You can try this yourself by writing a program in your favourite language that takes advantage of the CPU's floating point support, doing the calculation, and examining the bit pattern of the result.  As bmike says, the likely reason is that the π value that Spotlight uses isn't defined with sufficient precision. <comment144913> @Édouard Yet another way to demonstrate that this is a bug due to insufficient precision in the π constant is to calculate `cos(acos(0))`.  `acos(0)` does in fact return a π/2 value as precise as can be stored in double precision, and the cosine of this is sufficiently close to zero that Spotlight will just display `0`. <comment144915> Something weird is going on here.  `cos(2*acos(0)*0.5)` returns a number of order `10^-10`.  So it's not because the π constant is not precise enough.  I can't explain this result: it's too imprecise for double precision and too precise for single precision. <comment144918> cos(1.5707963267948966) yields 0. But cos(3.14159265358979323846264338/2) does not yield 0. <comment144921> cos(x) is a transcendental function. Unless they hardcode values for pi, pi/2, etc, you should expect some error. <comment144939> @Navin actually I do expect them to hard-code these values since they're very important. <comment144942> `pi` itself would be hard-coded (as you get -1 for `cos(pi)`) but as soon as you manipulate it you get a floating point number, which has limited precision. OSX does not hard-code `pi/2`, `pi/4` etc, it actually does the operation. <comment144945> Even if you'd increase precision, the only thing you'd gain is that the result becomes `x.yzE-50`. There are no good solutions for this, short of a computer algebra system. For any floating point based program, it's easy to find cases where it should return zero, but does not. The error here is slightly larger than I'd expect out of `double`, but not by much. <comment144946> I suppose it's a characteristic of the fact that computers [work in binary](https://www.youtube.com/watch?v=PZRI1IfStY0) whereas we work in decimal. <comment144950> @harryg While there are rounding errors that can be solved by switching to decimal, this isn't one of them. Decimal is useful if you want to represent `0.1` exactly. precisely, but it's not useful for irrational numbers like pi which can't be represented exactly in either binary or decimal. <comment144951> I see, that's a good explanation. So it is a simple lack-of-precision, and probably unintelligent rounding upon display of the answer. <comment144956> For reference, in Ruby: `irb(main):009:0 Math.cos(Math::PI/2) = 6.123233995736766e-17` <comment144961> This is weird. 1.5707963268 is the result Spotlight gives you when you compute pi/2. After a few simple tries, it seems like Spotlight displays 10 significant digits for number below 1 and 11 for numbers above 1. But for what weird implementation reason would a rounding step be applied *inside* the computation instead of after? <comment144969> It is due to lack of precision, but an error of this magnitude cannot be blaimed on floating point numbers. <comment144970> It probably more a lack of precision with the pi value. <comment144973> I also wanted to point out that if you provide Spotlight with a more precise approximation pi/2 (by copy-pasting more than 10 digits from Wolfram Alpha, e.g.), the precision increases. <comment144974> @Édouard Thanks, have updated the answer <comment144975> @bmike My comment was meant to be read in the first degree (I wasn’t sure if the question was about non-exact results or insufficient precision). Despite my best efforts, it seemed it still sounded somehow caustic. However, by editing my comment, you introduced an error in it: floating-point numbers *are* a software representation (of numbers); talking about the software representation of floating point numbers doesn’t make much sense, at least to me. <comment144980> @Édouard feel free to put up a new comment if you wish I cleared it since it needs to make sense to you in the end. My apologies if my attempt to help missed the mark. <comment144988> Thanks for confirming my guess that pi's precision was the cause of the error between 0 and roughly 10^-12 in the OP's question. <comment144999> How often do you see this: "10^-12 is really big" <comment145002> This is typical for any calculator not knowing a lot of rules with symbols but just converting each name to a number when it sees it. <comment145057> Nothing is *wrong* with the Markdown — MathJax is only enabled on Math-related sites, not SE-wide. <comment145096> cos(pi/2 + cos(pi/2)) displays as 0 exactly.
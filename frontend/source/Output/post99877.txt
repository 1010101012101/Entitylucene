Applescript failing even though variables are equal <body> I have a file that is a list of numbers like so:     01      02      03      04      ...      241      242   However, this was generated from a list of files so I am not sure if it contains all the numbers in sequence from start to end, inclusive (Meaning it might be "13 15" instead of "13 14 15").   My applescript checks for that, and although it seemed like it was going it be simple, my applescript fails at the number 10 and beyond, even though my dialogues say that the numbers x and y are both equal. And by fail I mean it is telling me the numbers 10 and on are missing even though it shouldnt be, because x is equal to y at that point.  Here is my applescript, and the list can be found here.  precodeset x to 0  repeat 242 times      set x to x + 1     if x is less than 10 then         set x to "0" &amp; x     end if      display dialog "x is set to " &amp; x      #Get's the x'th line of the file and sets it to y     set y to do shell script "sed -n '" &amp; x &amp; "p' ~/Desktop/numlist.txt"      display dialog "y result is " &amp; y      if y is not equal to x then             display dialog "The number " &amp; x &amp; " is missing!"         #exit repeat      end if  end repeat /code/pre  <answer99878> Your codex/code values are strings when the value is less than ten (because you use string concatenation to prepend a zero), however they are plain numbers when the value is greater than or equal to ten.  Your codey/code values are always strings.  So, for values less than ten, your final comparison compares a string to a string; this works as expected. For higher values, the comparison will always yield codefalse/code because it is comparing a number to a string.  hr  If you want exact string matches, then you can use use this comparison code:  precodeif y is not equal to x as string then … /code/pre  hr  If you only care about numeric values, then you could remove the zero-prefixing code and use this comparison:  precodeif y as number is not equal to x then … /code/pre  Equivalently, you could do the coercion when you fetch the codey/code value:  precodeset y to (do shell script "sed -n '" &amp; x &amp; "p' ~/Desktop/numlist.txt") as number /code/pre  The parentheses are necessary there because codedo shell script/code has its own optional codeas/code parameter that is not the same as normal coercion.  <answer99902> Here's my two-cent's worth.  In the following code, the class (or type) of x is changed after contatenating the text "0" to it from an integer to text.  precodeset x to 0 set x to x + 1 if x is less than 10 then     display dialog "At point 1, class of x: " &amp; (class of x)     set x to "0" &amp; x     display dialog "At point 2, class of x: " &amp; (class of x) end if /code/pre 
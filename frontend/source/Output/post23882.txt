Moving folder to Trash in Finder is not synchronized with Terminal <body> I tried to delete a folder which I access via terminal.app. Though the Finder moved the folder to the Trash, I was still able to see the contents and edit the file from terminal.  ul licreated a textfile /li /ul  img src="https://i.stack.imgur.com/1jcuk.png" alt="created a textfile"  ul liMoved the entire directory to the Trash via the Finder/li /ul  img src="https://i.stack.imgur.com/640lv.png" alt="Deleting the entire directory from Finder"  ul liI see files even after moving the folder to the Trash/li /ul  img src="https://i.stack.imgur.com/6kfW9.png" alt="I see files even after deleting the folder"  ul liI still managed to edit/append content to the file/li /ul  img src="https://i.stack.imgur.com/52qYs.png" alt="I still managed to edit/append content to the file"  The file is not available in Recent menu of Textedit after being moved to the Trash, but can be viewed in terminal with codecat/code command. Even after moving to the Trash, the directory codePWD/code doesn't update path (with trash/tmp path)  View the complete screencast @ http://goo.gl/tuJBT (5.20 min / ~24mb)  <answer23884> I believe this is an expected behavior. Although codePWD/code doesn't update the path right away, if you do something else like codecd ../code or even codecd ./code you can see that the path gets updated.  <answer23885> Moving something to the Trash in Finder does exactly this, it just emmoves/em the file/folder to a special directory (conveniently names .Trash). In Terminal.app you are working on Unix level and can still access the folder as usual. Once you empty the Trash it's gone for good.  <answer23888> In a nutshell, yes, this behaviour is expected. It's less than ideal but it's completely explainable and it's a biproduct of how files and directories are represented on the filesystem level.  It helps to understand how files and directories are represented on the underlying filesystem via inodes. And how moving a file on the same filesystem doesn't actually change the file blocks, it just shuffles the inode metadata around.  Lets step back a bit though and make sure we understand that: when you delete a file via Finder you're (for the most part) not actually deleting it. You're just moving it to a trash location that's on the same logical partition as the file. That the trash location is on the same partition is important. It lets the OS exploit the inodes to make the delete really, really fast.  Now lets talk about inodes. For regular files, inodes hold the metadata for the file along with some pointers to the data blocks on the filesystem that actually hold the data for the file. The metadata is stuff like the creation date, the last accessed date, the owner and group, the permissions settings, etc.  For directories the inode holds all that metadata emplus/em it holds a pointer to a list of all the inodes that are "in" that directory. So if I "move" a file on a filesystem all I'm doing is taking a reference to that file's inode out of its current directory's inode file list and moving it to another directory's inode file list. The list changed, but the inode reference to the file didn't.  This metadata shuffle means that the physical location of the file blocks and the inode for the file itself don't actually change on disk. Any program currently accessing the file (assuming file locking isn't being used) can continue to access it even while I'm moving it because all the references it needs have remained the same. The inode for a file or directory doesn't change as long as it's kept on the same filesystem. And when programs access files and directories, most of that access is done via inode references.  Pretty neat.  But it can lead to some jarring behaviour if you're accessing a directory from multiple places and then you move the directory. And this is what you're experiencing.  In your case you have a Terminal prompt in a directory. When you changed in to that directory your shell read the inode metadata for that directory and updated some data structures and environment variables. One of those environment variables was the PWD variable.  Then you deleted the directory which placed that directory's inode under the code.Trash/code directory's file list. The metadata for these two inodes was updated so the deleted directory now had a parent directory metadata attribute that points to code.Trash/code and the code.Trash/code inode metadata got a new entry in its list of children: the deleted folder's inode. But your Terminal app didn't know this happened. There's nothing that told it that it should reload its data structures. That's why codepwd/code and code$PWD/code continue to show the original path to the directory. You have to trigger an action in the shell that causes that inode metadata on the working directory to be re-read and the data structures and environment variables to be re-generated. It can be something as simple as called codecd ./code to do a no-op change directory. Or you can move out and back in to the directory with absolute paths.  The reason the reason that codecat/code in the Terminal works to show you a file in that directory is that the inode that codecat/code uses to access that file didn't change just because its location on disk changed. So codecat/code can still find it given you're using a relative reference to the file. If your file was originally located at code/foo/bar/moo.txt/code and you tried to do codecat /foo/bar/moo.txt/code emafter/em you deleted the codebar/code directory via Finder you'd see that the codecat/code call would fail with a file-not-found error. But codecat moo.txt/code would continue to work because all the file system data structures that codecat/code needs to use to find codemoo.txt/code in your working directory have technically not changed enough for codecat/code at your Terminal prompt to lose track of them.  That's the long explanation. Hope I didn't lose you. :)  <comment26668> Can I just say: awesome question. The screen shots and everything make it very succinct. <comment26680> I agree with Ian, except that the title is pretty lousy.
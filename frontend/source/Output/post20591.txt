How do I use only the external display with my MacBook Pro lid open on Lion? <body> Sorry for the wordy title, but my problem is thus:  ul liWhen I'm at my desk, I would like to use emonly/em the external display./li liWith the nifty gestures in Lion, I have decided I would like to use the internal trackpad on my MacBook/li liTo physically touch the trackpad, the lid on my MacBook Pro needs to be open/li /ul  This used to be a piece of cake with Snow Leopard and below - you plug in the external display, close the lid, plug in a USB device or press a key on a connected keyboard to wake the machine, and once it's woken up and using the external display reopen the lid and the internal screen stays off.  Unfortunately, Lion detects when my MacBook Pro is open and thinks its being helpful by activating the display. Is there a way to disable that? Is there a way to fool Lion into thinking my lid is closed?  <answer21309> I know this is a bit of a kludge, but my work around for this issue is to hold down the brightness control on my macbook until the screen goes dark.  Like you, I prefer to just work on the larger display, and keep typing with my laptop keyboard (with the laptop display open only partially and open just enough the I can use the laptop's keyboard).  Anyway, this solution works for me.  Re: "..and it's frustrating when my pointer disappears to the other screen.. "  I get around that by just clicking on "mirror displays" option in the System Prefs  Displays  Arrangement   Hope this helps.  <answer21694> I've taken up olivier's suggestion to arrange my monitors to eliminate a common border:  img src="https://i.stack.imgur.com/5NmBo.png" alt="enter image description here"  I chose the bottom right because I keep my dock on the left hand side of my screen, and I use my upper right as a hot corner to sleep the display. I also moved the menu bar to my desktop monitor and the MacBook screen is completely dimmed.  There was another option I heard about: using a magnet to make your MacBook think that the lid was closed. This does work - I placed a snippet of a refrigerator magnet near the bottom left side of my keyboard and sure enough my MacBook thought I had closed the display. Unfortunately, Mac OS X also disables keyboard and trackpad input when it thinks the display is closed, so this option didn't work for me.  <answer28755> Mac OS X Hints has discovered a command that will allow this:     To go back to pre-Lion behaviour enter the following command in Terminal:   precodesudo nvram boot-args="iog=0x0"  /code/pre      To undo this change type type the following command or zap the PRAM (press Cmd+Opt+p+r at power up):   precodesudo nvram -d boot-args  /code/pre   <answer34451> Not sure if this works in Lion but if you have the lid closed and plug in a USB device it'll power up your monitor and then you can open the lid and your external monitor will be on and your lid will be off.  <answer77724> Once you have hooked up the external monitor, for sometime you do see this extended monitor setup. But if you don't want to use the laptop screen, simply close the lid of the macbook pro and continue working on the larger screen this works. The laptop doesn't go into sleep mode. This is with the Lion release.  <answer87755> I ran into the same problem a while ago, and here's what I did:  First, I mirrored the displays, as has already been suggested. Soon after doing this, I realized that it was very distracting to have the macbook's lit screen off in the corner of my eye. This required that I kill the brightness on the macbook's screen. But being the lazy guy that I am, I hated having to manually adjust the brightness every time I un/plugged an external monitor. So I wondered if there was a way to automate the process.   I found this free app called Control Plane which let's me set "contexts" based on whether certain devices (monitors, hard drives, etc) are plugged in, whether certain wi-fi networks are in range, etc; and based on these contexts, run certain shell scripts. So all I had to do was write an applescript (called codekillBrightness.scpt/code) to kill the brightness on the macbook's screen and a shell script to call codekillBrightness.scpt/code; and call this shell script in the required context.  strongcodekillBrightness.scpt/code/strong  precodetell application "System Preferences" to set current pane to pane "Displays"  tell application "System Events"     tell process "System Preferences"         repeat with theWindow in windows             if title of theWindow as string is "Color LCD" then                 tell tab group 1 of theWindow                     tell slider 1 of group 2                         set value to 0                     end tell                 end tell             end if         end repeat     end tell end tell  tell application "System Preferences" to quit /code/pre  strongThe shell script/strong  precode#!/bin/sh  osascript /path/to/killBrightness.scpt /code/pre  Since I plug many different monitors into my macbook, I noticed that when one with a different aspect ratio is plugged in, my windows hang off the edge of the screen. The solution to this would be to resize the windows, but that's highly inefficient when you use a ton of apps and windows like I do; also, me being as lazy as I am, didn't like that solution. So, with the help of the nice folks over at Stack Overflow, I was able to come up with this AppleScript (called coderesizer.scpt/code) to automagically resize all windows of (almost) all apps (the caveat is that some applications don't use the correct UI framework hooks, so it's quite difficult to resize them):  strongcoderesizer.scpt/code/strong:  precodeproperty blacklist : {"Finder", "Preview", "Console", "AppleScript Editor", "Spotify", "TaskCoach", "Skype", "VirtualBox"} property buttonApps : {"LyX", "Eclipse"} property buttonMaps : {{name:"LyX", Button:1, pname:"lyx"}, {name:"Eclipse", Button:2, pname:"eclipse"}, {name:"Spotify", Button:3, pname:"Spotify"}, {name:"TaskCoach", Button:3, pname:"TaskCoach"}}  tell application "Finder" to set theBounds to bounds of window of desktop  tell application "System Events"     set bids to bundle identifier of processes where background only is false end tell  repeat with bid in bids     tell application id bid         if name is not in blacklist then             set appName to name as string             if name is "Terminal" then                 set newBounds to {0, 0, (item 3 of theBounds) - 10, item 4 of theBounds}                 repeat with theWindow in windows                     if visible of theWindow is true then                         set bounds of theWindow to newBounds                     end if                 end repeat             else if name is not in buttonApps then                 try                     repeat with theWindow in windows                         if visible of theWindow is true then                             set bounds of theWindow to theBounds                         end if                     end repeat                 end try             else if name is in buttonApps then                 -- get the buttonNumber                 repeat with buttonApp in buttonMaps                     if (name of buttonApp as string) is appName then                         set theButton to Button of buttonApp                     end if                 end repeat                 tell application "System Events"                     repeat with theProcess in (processes where bundle identifier is bid)                         try                             tell theProcess to tell window 1 to click button theButton                         end try                     end repeat                 end tell             end if         end if     end tell end repeat /code/pre  Now, all I had to do was write a similar shell script to call coderesizer.scpt/code and put that into ControlPlane and I was all set to be lazy all over again!  Hope this helps  PS: I forgot to mention before that all of this was done on my 15 inch MacBook Pro, running Lion  <answer247237> This is a combination of a few of the other posts/comments here into one place.  I'm using a MacBook Pro running El Capitan.  Advantages of this method over the terminal commands:  ol lino restart required/li lino modification of boot-args/li /ol  Steps:  ol liplug in and turn on external monitor/li ligo to System Preferences - Displays - Arrangement  ul liuncheck "mirror displays"/li lidrag the white menu bar from the macbook display to the external monitor (reference with screenshots).  This makes the external monitor the Primary display./li liArrange the blue boxes so that only the corners touch (screenshot provided by Kyle Cronin in posts above).  This prevents the mouse from moving between screens./li /ul/li liclose the display options and tap the macbook's dimmer key (i.e. kbdF1/kbd) until the screen is black./li /ol  Undo steps (preserving the arrangement for later):  ol litap the brighten screen key on MacBook (i.e. kbdF2/kbd)./li liunplug the external monitor./li /ol  Undo steps (to change it back to the default if plugged in again):  ol litap the brighten screen key on MacBook (i.e. kbdF2/kbd)./li ligo to System Preferences - Displays - Arrangement  ul lidrag the white menu bar back to the macbook display./li lidrag the blue boxes back into place./li licheck the mirror displays option./li /ul/li liunplug external monitor./li /ol  <comment22680> Why don't you want the extra screen real estate provided by the internal display? <comment22681> @CajunLuke It just doesn't work very well. Multiple displays are best when they're sitting next to one another and are the same distance from your eyes. They're also best when two adjacent displays have the same physical dimension and resolution along the shared edge. With my MacBook Pro neither is the case, and I find it annoying having to manage it, and it's frustrating when my pointer disappears to the other screen <comment22941> Others have also wanted this for better heat dissipation as well as WiFi antenna reception. A vertical stand can help there, but it's something that might enhance Kyle's desire to control the screen independent of the display proximity sensor. (that and not needing to buy or place a magic trackpad on his work surface) <comment23324> "Mirror display" won't work if your external display has a better resolution than your internal display. I use the same solution as you (dimming the screen) but I arrange monitors so they have very few common border, in order not to lose my pointer. <comment23338> Re: "Mirror display", you're right I should have mentioned that my larger external samsung 22" monitor has the exact same 1680x1050 resolution as my 2011 15" MacBook Pro <comment43039> Worth noting: you need to restart your computer before this will work. <comment90043> I believe Kyle was asking how he can do it with the lid open. <comment134618> I'd add another upvote if it was possible. Thanks!
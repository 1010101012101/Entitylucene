Installing the most recent version of Ruby on Snow Leopard <body> I downloaded and compiled the latest version of ruby 1.9.2 which was installed in code/usr/local/bin/ruby/code, however the system officially recognizes code/usr/bin/ruby/code which is only 1.8.7 which came installed on the machine. How can I get the new ruby into place?  In this instance I need to replace the ruby version and be able to use the updated version for command line work and rails development.  <answer13842> What do you mean by "get the new Ruby into place"?  If you are trying to run it from the command line using just the command coderuby/code, the system will search each of the paths specified in code/etc/paths/code in order until it finds a match.  In Snow Leopard, the default code/etc/paths/code file looks like this:  precode/usr/bin /bin /usr/sbin /sbin /usr/local/bin /code/pre  So when you enter coderuby/code at the command line, the system looks for code/usr/bin/ruby/code first, finds it, and doesn't check the rest of the paths (so it never gets to code/usr/local/bin/ruby/code).  To confirm this, you can enter codewhich ruby/code at the command line, and the system will print the path of the executable that it would use for that command.  If you want to run your newer version of Ruby from the command line, simply enter code/usr/local/bin/ruby/code instead of coderuby/code.  If you are using another program that is using Ruby indirectly, there's probably an option somewhere to specify the path to coderuby/code.  hr  EDIT: strongAs a last resort/strong, you can overwrite the built-in system version of Ruby with your newer version.  Use the following commands, and enter your administrator password when prompted:  precodecp /usr/bin/ruby ~/Desktop/ruby_OLD sudo cp /usr/local/bin/ruby /usr/bin/ruby /code/pre  If something breaks, put it back with this command:  precodesudo mv ~/Desktop/ruby_OLD /usr/bin/ruby /code/pre  As others have mentioned, though, using a tool like RVM to manage Ruby would be a better idea than upgrading the built-in installation.  <answer13850> The way to get any self installed program to be found before an Apple supplied ome is to add the directory of the new program (e.g. /usr/local/bin) to the fromt of the PATH environment variable.  If you are running ruby from the shell edit ~/.profile or if from a GUI ~/.MacOSX/environment.plist  <answer13854> You might want to take a look at Homebrew, which makes it easy to install the latest Ruby - codebrew install ruby/code is all you need - and many other packages without interfering with anything already on your system, to a location that's (almost certainly) already in your code$PATH/code.  <answer13858> You should use RVM, the Ruby Version Manager. It allows multiple side-by-side installations of Ruby without affecting the system Ruby installation, which as another commenter pointed out can empotentially/em be problematic (or at the very least, tiresome to maintain).  It allows you to quickly and easily install the latest patchlevel of Ruby, past Ruby versions, or even alternate implementations like JRuby, MacRuby, or Rubinius.  To install:  precode$ bash &lt; &lt;(curl -s https://rvm.beginrescueend.com/install/rvm) /code/pre  Once it's installed, setting 1.9.2 as the default is as simple as typing:  precodervm default 1.9.2 /code/pre  And if you feel like switching back to 1.8.7 temporarily:  precodervm use 1.8.7 /code/pre  <answer13865> If you truly want to replace the existing code/usr/bin/ruby/code (which is simply a sym link to code/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/bin/ruby/code ) just overwrite the existing file with the one you compiled being careful to match file permissions.   The reasons to not do this are many, but it's that simple given a literal interpretation of your question.  Most people change their path to include the newer ruby before the system one since that is simpler and less likely to break other things that depend on the installed version of ruby and associated dylib, gems, rdocs, and such remaining the same.   One of the benefits of homebrew and fink and RVM and MacPorts is that they help automate the staging to an alternate location and support modifying your path.  You can do the same with the ruby you have in code/usr/local/bin/code by manipulating your path variable and using codewhich -a ruby/code to double check your work afterwards.  <comment14756> Overwriting system components is usually a bad idea. There can be other applications depending on `/usr/bin/ruby` being the Apple supplied `ruby`. <comment14759> @Bavarious I think the chances of that are very slim for `ruby` on OS X (it would be different if we were talking about making a major change like PHP4 to PHP5).  But you're right that it's generally a Bad Idea, which is why I mentioned it last.  I presume there's a reason this user prefers 1.9.2 over 1.8.7 or they wouldn't be asking this question -- the potential benefits of running the latest version probably outweigh the tiny risk of breaking something because it was upgraded to the next minor version. <comment14778> You might want to look into RVM - The Ruby Version Manager - it allows you to have multiple ruby versions installed along with specific gemsets for different projects. https://rvm.beginrescueend.com/ <comment14787> are you certain the risk is "tiny"? Managing Ruby with RVM is so much easier and safer. <comment14788> +1 Using RVM to manage my Ruby installations and gemsets has changed my life. Whenever an incompatibility or conflict has cropped up, I'm back up and running in minutes. <comment14797> @ghoppe I say the risk is "tiny" because you're not likely to break any important, core system functionality on OS X by upgrading Ruby.  Could it cause some quirkiness in a small corner of your system somewhere that's hard to troubleshoot?  Maybe.  Ultimately, the main headache would probably be maintenance related if he plans to update Ruby frequently.  You're definitely right that RVM would be a good option, and much preferable to changing system files. <comment14798> +1 This would probably be a great option for you. <comment14801> Although I love RVM - this doesn't answer the question posed. The OP already has the ruby he wants compiled and seems intent on not using $PATH to let them coexist. <comment14802> This is better IMHO than replacing the binaries as the OP asks. <comment14803> @bmike Where does the OP voice that intent? I don't see it. I disagree with your interpretation of what it means to answer a question on StackExchange. Giving advice, presenting alternatives, and outlining best practices are valid answers as well if they address the asker's need, which in this case is to install the latest version of Ruby on Snow Leopard. <comment14813> I agree RVM is the best way to maintain a non standard ruby. But unless the question gets edited (which hopefully will happen to make the question more usefully match your great answer) I don't see how "use RVM" best answers the question "how do I replace /usr/bin/ruby at 1.8.7 with /usr/local/bin/ruby at 1.9.2?" What if the OP has scripts hard coded to call /usr/bin/ruby? Does RVM step in there to assist? <comment14814> Do you really need to replace /usr/bin/ruby or are you open to alternatives like RVM or modifying the $PATH variable? <comment14857> Yes I need to replace the version of ruby that is currently installed on the system. This seems to be hard to do based on the answers I am getting. <comment14859> I want to be sure you understand what you're saying.  "Replace" Ruby is very different from "use a different version" of Ruby.  If you want the latter, RVM would be a great option, as several have mentioned.  If you are *sure* you want to *replace* the system's version of Ruby (and understand that may have negative consequences), then I explain how to do that at the bottom of my answer below.  Either way, there should be plenty of information here to answer your question now. <comment14860> It's seems that RVM is the way to go rather than replacing the system version of ruby. Thanks everyone for your input.
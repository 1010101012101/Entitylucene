Is there something stronger than "Force Quit"? <body> I have an app that won't die: it's gone from the dock, but the window remains (with a beachball, if I mouse over it).  It's using no CPU, but I want it to go away.  Is there something stronger than "Force Quit", to really emreally/em kill an app?  <answer64698> If you know the name of the app, you can check in Activity Monitor to see if it's still running there and try its Force Quit. If that doesn't work, take note of the app's process ID (pid). Go to the Terminal and type codekill [pid]/code, replacing "[pid]" with the number you noted earlier. If that doesn't work, try codekill -3 [pid]/code and if that doesn't work codekill -9 [pid]/code. If the process is owned by a different user (this is not likely), you may need to replace codekill/code with codesudo kill/code and type your password when prompted.  If the app doesn't show up in Activity Monitor or you couldn't codekill/code it, the window may be a left-over stuck someplace else and the app simply isn't running anymore. In this case, sometimes (not always) it can work to codekillall SystemUIServer/code or codekillall Dock/code.  If none of this works, you'll have to log out and back in or reboot. The few times I've gotten to this point, the app was so stuck it prevented logging out or shutting down, so I had to hard reboot.   <answer64771> The force quit window, codekillall/code, and codekill/code all send processes TERM signals by default. You can use codekillall -kill/code if that doesn't work.     The killall utility kills processes selected by name, as opposed to the selection by pid as done by kill(1).  By default, it will send a TERM signal to all processes with a real UID identical to the caller of killall that match the name procname. The super-user is allowed to kill any process.   If you run codesudo dtrace -n 'proc:::signal-send /pid/ { printf("%s -%d %d",execname,args[2],args[1]-&gt;pr_pid); }'/code and quit some application from the force quit window, the signal is usually shown as -15 (TERM). But when you quit a background process (or an application that isn't shown in the Dock) from Activity Monitor, the signal is usually shown as -9 (KILL).     SIGTERM is the default signal sent to a process by the kill or killall commands. It causes the termination of a process, but unlike the SIGKILL signal, it can be caught and interpreted (or ignored) by the process. Therefore, SIGTERM is akin to asking a process to terminate nicely, allowing cleanup and closure of files. For this reason, on many Unix systems during shutdown, init issues SIGTERM to all processes that are not essential to powering off, waits a few seconds, and then issues SIGKILL to forcibly terminate any such processes that remain.   <answer140752> As in above answers, the strongest way to terminate any process is codeSIGKILL/code, e.g. codekill -9 process_id/code.  However, exist processes what are simply impossible to codeForce Quit/code nor codekill/code. They called as codezombie/code processes.  Here is a short script what will create a codezombie/code process for two minutes:  precodeperl -e 'if($p=fork) {print "unkillable pid:$p\n" ;system("ps -l"); sleep(120)}' /code/pre  Run the above script in the Terminal and you will get output, like next:  precode     unkillable pid:50571         UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD         501 47380 47379     4006   0  31  0  2448416   2900 -      S                   0 ttys000    0:00.36 -bash         501 50570 47380     4006   0  31  0  2443512   1424 -      S+                  0 ttys000    0:00.01 perl -e if($p=fork) {print "u #THIS-&gt; 501 50571 50570     2006   0   0  0        0      0 -      Z+                  0 ttys000    0:00.00 (perl)         501 12795 12794     4006   0  31  0  2448296   1752 -      S+                  0 ttys001    0:00.75 -bash         501 50123 50122     4006   0  31  0  2448296   2688 -      S+                  0 ttys002    0:00.14 -bash /code/pre  If you check the status column for the unkillable process (in this case: 50571) you see the codeZ/code flag, whats mean codezombie/code.  You can try send any codekill/code signal (e.g. codekill -9  50571/code) and the process will still exists. Anyway, it doesn't hurts much your system, because it's in fact doesn't exists - only occupies process table.  In the above example, in 120 seconds it will be cleared.  <answer205135> I've had situations where Force Quit, Activity Monitor, codekill/code, and other methods didn't work, and my Mac couldn't shutdown because of it.  In this case, a codesudo shutdown -r now/code worked when nothing else would, and is probably better than doing a hard shutdown via the power button.  <answer231740> This is what you should do:  ol liIn Activity Monitor, Double Click the process OR Click the Info icon to open up the process' window./li liYou will see the process # in the Process Group line as processName(####) where "####" is your process' number./li liOpen terminal and type "sudo kill ####" without the quotes and hit enter/li liEnter your password, terminal will not show your input here/li liProcess is killed./li /ol  A process like this is best removed in safe mode if you are going to attempt an uninstall.  Cheers, Bryan  <comment76003> I'm not sure if it's stronger, but try Apps  Utilities  Activity Monitor. Find the process, and Force Quit. If that doesn't work, note the process number, go to Terminal and type "kill #" where # is the process number. HTH <comment76004> the power button? <comment76005> @DanielLawson Unfortunately, these situations usually result in that. <comment76010> David: I assume that what Apple calls "Force Quit" is the same no matter how you get to it, but I tried that too, with no effect. <comment76012> I tried all of these (including `sudo`, even though the process is owned by me), with no change.  Will `killall SystemUIServer` affect any of my other open apps, like forgetting window positions? <comment76013> Probably not; it'll kill most things in your menu bar and soem other stuff. You could also try `killall Dock` which will un-minimize any minimized windows (I'm going to edit the answer to add the Dock tip). <comment76015> What do the options `-3` and `-9` do? <comment76016> gentmatt: According to `kill -l`, -3 is SIGQUIT, and -9 is SIGKILL ("non-catchable, non-ignorable kill"). <comment76017> @gentmatt 3 is the QUIT signal that gives the process the ability to intercept the signal and perform cleanup. 9 is KILL is "non-catchable and non-ignorable". There are a pile of other signals you can send; run `man kill` (which is in the top-10 best UNIX commands ever) to see them all. <comment76020> I normally just do kill -9. -3 is no stronger than "Force Quit" <comment76038> @BoTian True; I skip straight to -9. Sometimes I don't bother with Force Quit at all. But for a user that doesn't know what they're doing, it could work and is less likely to be harmful. It also doesn't take very long, so the time expended to expected result ratio isn't all that bad. <comment76138> agreed, now you get upvote for both the answer and comment from me <comment76183> Some good info here, but none of these variants of killing the process seems to have any effect at all on it. <comment83936> @Ken As far as I know, most apps and programs don't handle `SIGQUIT`. [`SIGQUIT` is not used when you e.g. quit an app from Activity Monitor.](http://superuser.com/a/481317/144700) The accepted standard is to try `TERM`, `INT`, `HUP`, then `KILL`. Also, using the names rather than numeric codes is more portable; not all systems use the same codes. <comment83939> @CajunLuke [You should never jump straight to `SIGKILL`.](http://www.novosial.org/shell/kill-9/index.html) <comment105778> If not even `SIGKILL` works, the app is probably in [uninterruptible sleep](http://superuser.com/q/436239/144700), and there's really nothing you can do (short of rebooting). <comment124386> @DavidDelMonte [Force Quit for graphical applications is the same thing as `SIGTERM`, and the same thing in the dialog and Activity Monitor.](http://apple.stackexchange.com/a/64771/25019) <comment124388> @Ken `SIGQUIT` causes a program to dump its core and exit. OS X treats this like a crash (I guess probably because it is), and will display the usual thing saying `The application whatever quit unexpectedly`. It _can_ be caught, but by standard or convention, `SIGTERM` is the one you want (`kill` sends it by default), not `SIGQUIT`. <comment124389> @Ken If you give a command, and it doesn't fail with a permission-denied error, trying it again with `sudo` will usually not help. Don't worry, I used to think like that too. :) <comment124394> @BS - thanks- that's very useful. I'll remember that. <comment124395> Just wondering too, if this was a user app, like mail.app or pages.app or whether this was somehow, a system process, like Spotlight, or an app background process, like Plex (that I have trouble removing). <comment198945> It's a bit late but what helped me: `ps aux | grep WindowServer` and then `sudo kill -9 PID` where PID is the pid of WindowServer from the first command (first number). It will destroy your current session and you have to login from new, but the "zombie" App Icons from the Dock disappeared.
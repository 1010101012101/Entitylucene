Bash executes only ~/.profile but neither of ~/.bash_profile and ~/.bashrc <body> I have a strange problem with bash:  I switch my default shell to code/bin/sh/code from zsh and it doesn't execute code~/.bash_profile/code or code~/.bashrc/code when I open a new terminal, it only executes code~/.profile/code.  What could be the problem?  I could probably source code~/.bashrc/code from code~/.profile/code but that does't seem like a good idea, e.g. it would break if I changed to another shell again.  <answer258748> code/bin/sh/code is not strongbash/strong. It is Bourne Shell. Bash (Bourne Again Shell)'s location is code/bin/bash/code. Change your default shell to bash to use code~/.bash_profile/code instead of code~/.profile/code  <answer258755> I suggest that you read the codebash/code manual under the heading codeINVOCATION/code which states:  precode   If bash is invoked with the name sh, it tries to mimic the startup behavior of historical versions of sh as  closely    as  possible, while conforming to the POSIX standard as well.  When invoked as an interactive login shell, or a non-    interactive shell with the --login option, it first attempts to read and  execute  commands  from  /etc/profile  and    ~/.profile,  in that order.  The --noprofile option may be used to inhibit this behavior.  When invoked as an inter-    active shell with the name sh, bash looks for the variable ENV, expands its value if it is  defined,  and  uses  the    expanded  value as the name of a file to read and execute.  Since a shell invoked as sh does not attempt to read and    execute commands from any other startup files, the --rcfile option has no effect.  A non-interactive  shell  invoked    with the name sh does not attempt to read any other startup files.  When invoked as sh, bash enters posix mode after    the startup files are read. /code/pre  A new terminal session in OS X/macOS always starts as a login shell.  <answer258780> To get code/bin/sh/code to execute code~/.bashrc/code the same way code/bin/bash/code does, you would have to do the following.  ol liAdd the following lines to code~/.profile/code.  precodeLOGINSHELL=YES export ENV=~/.shrc /code/pre/li liCreate the file code~/.shrc/code containing the following line.  precodeif [ "$LOGINSHELL" != "YES" ]; then  source ~/.bashrc; fi /code/pre/li /ol  To help in debugging, I usually add the following line to beginning of the code~/.profile/code file.   precodeexport DEBUGSHELL=YES /code/pre  This line can be commented out when done debugging, as shown below.  precode#export DEBUGSHELL=YES /code/pre  Next, add conditional codeecho/code statements to the beginning and ending of the files such as code~/.profile/code, code~/.bashrc/code, code~/.shrc/code and others. For example, code~/.shrc/code would contain the following.  precodeif [ "$DEBUGSHELL" = "YES" ]; then echo entered .shrc; fi if [ "$LOGINSHELL" != "YES" ]; then  source ~/.bashrc; fi if [ "$DEBUGSHELL" = "YES" ]; then echo exited .shrc; fi /code/pre  Another idea, that may be useful, is to create a file code~/.bashcm/code to contain the commands that need to be executed for both login and interactive shells. For example, this is usually where I place my codealias/code commands. You will also need to include the following line in both your code~/.profile/code and code~/.bashrc/code files.  precodesource ~/.bashcm /code/pre  <comment323535> /bin/sh on OSX is bash but it tries to mimic the startup behavior of historical versions of sh as  closely   as  possible, while conforming to the POSIX standard as well. (from other answer)
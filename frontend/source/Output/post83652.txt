Mass change a portion of a file name? <body> I have a whole bunch of files named as following (example):  precodeADVANTE  18''8.0 PCD5'114.3 ET45 CB73.1.jpg ADVANTE  18x8.0 PCD6139.7 ET20 CB110.2.jpg ADVANTE 'A MI576B 20''8.5 PCD6'139.7 ET25 CB110.2 GBXZLDCP.jpg ADVANTE 'A SH10 15''6.5 PCD8'100-114.3 ET40 CB73.1 3FPBU.jpg /code/pre  How do I go to each file and change a portion of their filename to:  precodeADVANTI  18''8.0 PCD5'114.3 ET45 CB73.1.jpg ADVANTI  18x8.0 PCD6139.7 ET20 CB110.2.jpg ADVANTI 'A MI576B 20''8.5 PCD6'139.7 ET25 CB110.2 GBXZLDCP.jpg ADVANTI 'A SH10 15''6.5 PCD8'100-114.3 ET40 CB73.1 3FPBU.jpg /code/pre  using some sort of command or app? It would take too long to rename each and every one of them manually.  <answer83657> You can use the terminal as follows:  precodefind . -type f -maxdepth 1 -print0 | while read -d $'\0' file; do mv "$file" "$( echo "$file" | sed "s/\.\/ADVANTE/ADVANTI/" )" ; done /code/pre  ul licodefind/code is used to list all the files to be renamed ul licode./code is the directory where to start the search/li licode-type f/code specifies that only files have to be considered/li licode-maxdepth 1/code specified that find should not recurse on subdirectories/li licode-print0/code prints the filename followed by an ASCII NUL character (since your file names contain spaces we need a special character to separate them: the space cannot be used)/li /ul/li licodewhile read -d $'\0' file/code processes the produced filenames and stores them in the code$file/code variable/li licodeecho "$file" | sed "s/\.\/ADVANTE/ADVANTI/"/code performs the substitution (ADVANTE with ADVANTI)/li licodemv/code moves the first file (the original name) to the second one (the one with the substitution)/li /ul  Tested with:  precode$ ls -l total 0 -rw-r--r--  1 corti  corti  0 Feb 27 10:26 ADVANTE  18''8.0 PCD5'114.3 ET45 CB73.1.jpg -rw-r--r--  1 corti  corti  0 Feb 27 10:26 ADVANTE  18x8.0 PCD6139.7 ET20 CB110.2.jpg -rw-r--r--  1 corti  corti  0 Feb 27 10:26 ADVANTE 'A MI576B 20''8.5 PCD6'139.7 ET25 CB110.2 GBXZLDCP.jpg -rw-r--r--  1 corti  corti  0 Feb 27 10:27 ADVANTE 'A SH10 15''6.5 PCD8'100-114.3 ET40 CB73.1 3FPBU.jpg $ find . -type f -maxdepth 1 -print0 | while read -d $'\0' file; do mv "$file" "$( echo "$file" | sed "s/\.\/ADVANTE/ADVANTI/" )" ; done $ ls -l total 0 -rw-r--r--  1 corti  corti  0 Feb 27 10:26 ADVANTI  18''8.0 PCD5'114.3 ET45 CB73.1.jpg -rw-r--r--  1 corti  corti  0 Feb 27 10:26 ADVANTI  18x8.0 PCD6139.7 ET20 CB110.2.jpg -rw-r--r--  1 corti  corti  0 Feb 27 10:26 ADVANTI 'A MI576B 20''8.5 PCD6'139.7 ET25 CB110.2 GBXZLDCP.jpg -rw-r--r--  1 corti  corti  0 Feb 27 10:27 ADVANTI 'A SH10 15''6.5 PCD8'100-114.3 ET40 CB73.1 3FPBU.jpg /code/pre  <answer83660> In case you need to do this often (and with different file patterns), this perl script might proof very useful. Store the following script as a text file called coderename/code in a convenient place:  precode#!/usr/bin/perl -w # rename - Larry's filename fixer $op = shift or die "Usage: rename expr [files]\n"; chomp(@ARGV = &lt;STDIN&gt;) unless @ARGV; for (@ARGV) {     $was = $_;     eval $op;     die $@ if $@;     rename($was,$_) unless $was eq $_; } /code/pre  You can then use all the standard perl expressions to rename files, in your case  precoderename 's/^ADVANTE/ADVANTI/' ADVANTE* /code/pre  <answer83676> You can try the commercial app A Better Finder Rename if you want to avoid the Terminal. They also have a free trial.  [Disclaimer: no financial interest in the company which sells ABFR - just a happy customer.]  <answer83684> If you use the ZSH shell, this can be done easily in Terminal with zmv (included with OS X by default). Why use fancy scripts if the work is already done?  Type codezsh/code in a terminal window if for some crazy reason you do not have it set as your default shell.  precodeautoload zmv zmv 'ADVANTE(*)' 'ADVANTI$1' /code/pre  <answer150867> As of OS X 10.10 (Yosemite), you can use the Finder to search-and-replace strings in filenames.  Select the files you want to rename, then invoke the codeRenameâ€¦/code option.  You should see a dialog sheet with codeFind:/code and codeReplace with:/code fields.  <comment96306> Is there a specific reason you use `find -maxdepth 1` instead of a `for f in *` loop? <comment96311> Yes because of the spaces: `*` will expand in a list of tokens and the shell will separate them on the spaces. As the list of files contains spaces the shell will not be able to distinguish if the space is part of the name or a separator. <comment96332> make sure the "convenient place" is on your current `$PATH`, and after saving it you should `chmod 755 rename` to make it executable. <comment96337> Yeah, that would help indeed :-) <comment96344> Now that is a grade A, excellent reason to fire up zsh. :) +1 <comment96350> Not really, try `touch "foo bar" foo; for i in f*; do echo $i; done` <comment96378> @patrix I see but I don't understand why: the man page says that the "list of words following in is expanded". `*` in this case should be expanded as "foo foo bar" (see `echo * | od -abc`). Is * expanded differently? <comment96418> It says `localhost% zmv 'ADVANTE(*)' 'ADVANTI$1'` `zsh: command not found: zmv` <comment96865> As far as the shell is concerned, a "word" can contain blanks (because the shell internally doesn't use blanks to separate "words"). It's just if a "word" containing blanks is passed to another (non-shell) command (e.g. `od`) that the blanks cause problems. <comment157653> @Propeller Sorry for the late response, missed it the first time. The error means that either you missed the first line (`autoload zmv`), or you aren't using the stock zsh installation. <comment255874> This is the best answer. It's such a useful feature that's not very well known, and it doesn't need any third party apps or fancy script shenanigans.
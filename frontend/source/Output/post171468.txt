How to quickly know the resolution of an image? <body> I am looking for a nice and quick way to display the resolution of an image from OS X 10.9. Presently, I have to open the image in photoshop and then enter a menu to know the resolution. The process is too slow when I have to browse through dozens of pictures and get those with resolution big enough.  <answer171470> h1Get Info/h1  You can get the resolution from strongGet Info/strong menu. Select the image and press kbdâŒ˜ CMD/kbd+kbdi/kbd, or right click on that image and choose strongGet Info/strong menu item.  img src="https://i.stack.imgur.com/b4yI1.jpg" alt="enter image description here" Image from cultofmac.com  h1QuickLook plugin/h1  If you weren't on 10.9 - this lightweight QuickLook plugin called strongqlImageSize/strong which can be found on GitHub lets You check the image size on the quicklook window title. I don't have any that work on 10.9, but perhaps this will help you if you wish to search for a similar one or report 10.9 compatibility to that project for improvement.  img src="https://i.stack.imgur.com/roqcg.jpg" alt="enter image description here"  <answer171471> This is a trivial task. I have written a c++ program which can display on terminal. I could post if you are interested. It would also be trivial to write a codeService/code to display the result.  precode// //  Display  Comment, size of JPEG image //  #include &lt;iostream&gt; #include "../jpeg.h"  int main (int argc, const char * argv[]) {     Cjpeg Jpeg1;      switch(Jpeg1.OpenJpeg(argv[1]))     {         case INVALID_JPEG:             std::cerr &lt;&lt; "Invalid JPEG" &lt;&lt; std::endl;             return INVALID_JPEG;         case NOTFOUND_JPEG:             std::cerr &lt;&lt; "File Not Found" &lt;&lt; std::endl;             return NOTFOUND_JPEG;         case NOT_JPEG:             std::cerr &lt;&lt; "Not JPEG" &lt;&lt; std::endl;             return NOT_JPEG;         default:             std::cout &lt;&lt; Jpeg1.Comments &lt;&lt;  " " &lt;&lt;  Jpeg1.Width &lt;&lt;  " * "  &lt;&lt;  Jpeg1.Height &lt;&lt; std::endl;     }     return 0; }  // jpeg.cpp: implementation of the Cjpeg class. // ANSI version //////////////////////////////////////////////////////////////////////  #include "jpeg.h"  ////////////////////////////////////////////////////////////////////// // Construction/Destruction //////////////////////////////////////////////////////////////////////  Cjpeg::Cjpeg() {     Height = Width = 0;     Comments[0] = '\0'; }  Cjpeg::~Cjpeg() {  }  //-------------------------------------------------------------------------- // JPEG markers consist of one or more 0xFF bytes, followed by a marker // code byte (which is not an FF). //--------------------------------------------------------------------------  #define M_SOF0  0xC0            // Start Of Frame N #define M_SOF1  0xC1            // N indicates which compression process #define M_SOF2  0xC2            // Only SOF0-SOF2 are now in common use #define M_SOF3  0xC3 #define M_SOF5  0xC5            // NB: codes C4 and CC are NOT SOF markers #define M_SOF6  0xC6 #define M_SOF7  0xC7 #define M_SOF9  0xC9 #define M_SOF10 0xCA #define M_SOF11 0xCB #define M_SOF13 0xCD #define M_SOF14 0xCE #define M_SOF15 0xCF #define M_SOI   0xD8            // Start Of Image (beginning of datastream) #define M_EOI   0xD9            // End Of Image (end of datastream) #define M_SOS   0xDA            // Start Of Scan (begins compressed data) #define M_JFIF  0xE0            // Jfif marker #define M_APP1  0xE1            // Exif marker #define M_COM   0xFE            // COMment #define M_DQT   0xDB #define M_DHT   0xC4 #define M_DRI   0xDD  // Process a SOFn marker void Cjpeg::process_SOF (unsigned length) {     int data_precision, num_components;     unsigned char Data[128];     unsigned long   cb; // count of bytes read      cb = fread(&amp;Data, 1, length, fp);   // read JPEG      data_precision = Data[0];     Height = Get16(Data+1);     Width = Get16(Data+3);     num_components = Data[5]; }  // Process a COM marker. void Cjpeg::process_COM (unsigned length) {     unsigned nch;     unsigned long   cb; // count of bytes read      nch = 0;      nch = (length &gt; MAX_COMMENT) ? MAX_COMMENT : length;    // Truncate if it won't fit in our structure.     cb = fread(&amp;Comments, 1, nch, fp);  // read JPEG      Comments[nch] = '\0'; // Null terminate     if(cb&lt;length)     {         fseek(fp, length - cb, SEEK_CUR);   // point to next JPEG marker     } }   void Cjpeg::process_APP1(unsigned int length) {     fseek(fp, length, SEEK_CUR);    // point to next JPEG marker }   int Cjpeg::OpenJpeg(const char *JpegFile) {     int count;     unsigned long   cb; // count of bytes read      fp = fopen(JpegFile, "rb");     if(fp == NULL)     {         return NOTFOUND_JPEG;     }     cb = fread(&amp;JpegMarker, 2, 1, fp);  // read JPEG     if(JpegMarker[0] != 0xFF || JpegMarker[1] != M_SOI)     {         fclose(fp);         return NOT_JPEG;    // Not JPEG File     }     while(cb != 0) // Stop if EOF reached     {         cb = fread(&amp;JpegMarker, 2, 1, fp);  // read JPEG marker         if(JpegMarker[0] != 0xFF)         {             fclose(fp);             return INVALID_JPEG;    // Invalid File         }         switch(JpegMarker[1])         {             case M_SOS: // stop before hitting compressed data             case M_EOI: // in case it's a table only JPEG stream                 fclose(fp);                 return 0;   // Normal exit         }         cb = fread(&amp;JpegSecCount, 2, 1, fp);    // read length of field         count = Get16(JpegSecCount);         count -= 2; // value includes length bytes         switch(JpegMarker[1])         {             case M_COM: // Comment section                 process_COM (count);                 break;              case M_SOF0:             case M_SOF1:             case M_SOF2:                 process_SOF (count);                 break;              case M_APP1:                 process_APP1 (count);                 break;              case M_JFIF:              default:                 // Skip any other sections.                 fseek(fp, count, SEEK_CUR); // point to next JPEG marker                 break;         }     }     fclose(fp);     return INVALID_JPEG;    // Possible Invalid File } /code/pre  <answer171499> From the command line if you have imagemagick installed (for example through homebrew or the installer), then you can use the following command to quickly display the resolution and similar information of multiple images in a directory:  precode$ ls a.jpg b.png c.png $ identify * a.jpg JPEG 550x309 550x309+0+0 8-bit sRGB 29.4KB 0.000u 0:00.000 b.png[1] PNG 1912x827 1912x827+0+0 8-bit sRGB 2.17MB 0.000u 0:00.009 c.png[2] PNG 311x262 311x262+0+0 8-bit sRGB 185KB 0.000u 0:00.000 /code/pre  Or if you only need the resolution:  precode$ identify * | cut -d' ' -f1,3 a.jpg 550x309 b.png[1] 1912x827 c.png[2] 311x262 /code/pre  Specifying code-verbose/code will give you even more quick information which you can codegrep/code in case it's needed:  precode$ identify -verbose c.png Image: c.png   Format: PNG (Portable Network Graphics)   Mime type: image/png   Class: DirectClass   Geometry: 311x262+0+0   Units: Undefined   Type: TrueColor   Endianess: Undefined   Colorspace: sRGB   Depth: 8-bit   Channel depth:     red: 8-bit     green: 8-bit     blue: 8-bit   Channel statistics:     Red:       min: 0 (0)       max: 255 (1)       mean: 154.515 (0.60594)       standard deviation: 66.9006 (0.262355)       kurtosis: -0.83131       skewness: -0.468887     Green:       min: 0 (0)       max: 255 (1)       mean: 148.544 (0.582527)       standard deviation: 77.5386 (0.304073)       kurtosis: -1.18136       skewness: -0.438364     Blue:       min: 27 (0.105882)       max: 255 (1)       mean: 176.548 (0.692343)       standard deviation: 62.2995 (0.244312)       kurtosis: -0.971188       skewness: -0.584194   Image statistics:     Overall:       min: 0 (0)       max: 255 (1)       mean: 159.869 (0.626937)       standard deviation: 69.2078 (0.271403)       kurtosis: -0.754397       skewness: -0.568073   Rendering intent: Perceptual   Gamma: 0.454545   Chromaticity:     red primary: (0.64,0.33)     green primary: (0.3,0.6)     blue primary: (0.15,0.06)     white point: (0.3127,0.329)   Background color: white   Border color: srgb(223,223,223)   Matte color: grey74   Transparent color: black   Interlace: None   Intensity: Undefined   Compose: Over   Page geometry: 311x262+0+0   Dispose: Undefined   Iterations: 0   Compression: Zip   Orientation: Undefined   Properties:     date:create: 2015-02-11T15:20:41+00:00     date:modify: 2015-01-28T10:04:15+00:00     png:iCCP: chunk was found     png:IHDR.bit-depth-orig: 8     png:IHDR.bit_depth: 8     png:IHDR.color-type-orig: 2     png:IHDR.color_type: 2 (Truecolor)     png:IHDR.interlace_method: 0 (Not interlaced)     png:IHDR.width,height: 311, 262     signature: 35b3a0e9c50c785bece1ceff5a202823922cc78c2740cf9e0ff30d6143c89fdf   Profiles:     Profile-icc: 3276 bytes   Artifacts:     filename: c.png     verbose: true   Tainted: False   Filesize: 185KB   Number pixels: 81.5K   Pixels per second: 2.716MB   User time: 0.000u   Elapsed time: 0:01.029   Version: ImageMagick 6.8.9-1 Q16 x86_64 2014-05-12 http://www.imagemagick.org /code/pre  <answer172194> The fastest way is to have the resolution details visible all time ;)  Check out the step below:  img src="https://i.stack.imgur.com/KfI31.png" alt="Select &quot;Show View Options&quot; by right clicking on the desktop"  img src="https://i.stack.imgur.com/gnka1.png" alt="Check the box &quot;Show item info&quot;"  img src="https://i.stack.imgur.com/d5bbl.png" alt="Now its visible under the filename"  img src="https://i.stack.imgur.com/6hQku.png" alt="For column view"  *COLUMN VIEW  <comment201717> Unfortunately, this plugin does not work for 10.9 <comment201719> Ups, just read the bottom of the README. You're right. <comment201720> I couldn't find it again so anyway thanks! I am sure it will help other users. <comment202700> Why, its built in? <comment202729> @JW_: it wasn't a criteria in the original post to be a built in <comment202792> Does it work in the list mode? <comment203927> @Colas no, but if you just select one file in a list view you get all the info in the column to the right.. <comment203929> Post is updated. <comment204012> @Colas I mistakenly compared column view with list view. Sorry about that. If you want the resolution in list view you may need to hack.
Why does kernel_task cpu% grow unbounded until forced reboot? <body> I saw an issue with my MacBook Pro running El Capitan with Chrome running that the kernel_task went haywire and started sucking up all the available CPU and the % cpu just kept climbing to where it was in the 30,000+% range and the computer was nearly completely unresponsive.  Eventually, I had to force a reboot, because the shutdown command appeared to be making no progress.  On reboot, it restarted chrome automatically, and again, the cpu started climbing.  I forced reboot a second time, and Chrome did not relaunch, the computer started running more normally, I was able to relaunch chrome and not reload the tabs and all seems ok now.  What was going on?  Was there some kind of malware or virus coming in through a website on one of the Chrome tabs?  I have Sophos anti-virus installed and running on this machine.  Should I be concerned that my machine is somehow compromised now?  Is there a way to determine what program, driver, or plug-in is causing the high CPU load?  <comment299247> have a look at http://apple.stackexchange.com/questions/179150/kernel-task-hundreds-of-cpu-yet-cpu-frequency-is-being-lowered?rq=1 <comment299250> @Tetsujin That must be what the issue was, overheating. <comment299251> Should we delete this question or keep it? <comment299253> We can keep it & link it as a duplicate - which gives Google a greater chance of finding the answer in future. I'll vote to close as a dupe; it doesn't reflect on the quality of the question, merely links it to an existing one with a highly-voted answer. <comment299254> This question is not a duplicate, IMO. I can answer it, but it will take some time <comment299255> @Sergei - we're not in any rush ;) <comment299407> @Sergei By all means, if not a dup, adding an answer here is helpful.  Please post your thoughts on why not a dup, so we can reopen it and get it answered, without reopening, you cannot answer it. <comment300040> @WilliamKF In short, user can run a spindump on a kernel_task process (which is an umbrella process for all drivers and many core services), look for abnormally high subprocess cpu_time, and precisely determine, which driver causes high CPU load. Which sort of answers the question above, but not the question it was linked to.
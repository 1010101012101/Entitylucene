How do I automatically kill processes that leak memory? <body> I have problems with processes that leak memory. They cause my hard drive to be filled with swap files in code/private/var/vm/code.  strongI would like leaking processes to be killed at sight by the OS/strong. I’m not interested in a dialog that appears after 20 minutes, suggests applications to kill, and doesn’t even show the one that is leaking.  I have tried setting the coderss/code and codedata/code limits in code/etc/launchd.conf/code but it didn’t seem to have an effect.  This is my code/etc/launchd.conf/code:  precodelimit data 8589934592 8589934592 limit rss 8589934592 8589934592 /code/pre  Here is the codelaunchctl limit/code output:  precode% launchctl limit     cpu         unlimited      unlimited     filesize    unlimited      unlimited     data        8589934592     8589934592     stack       8388608        67104768     core        0              unlimited     rss         8589934592     8589934592     memlock     unlimited      unlimited     maxproc     709            1064     maxfiles    256            unlimited /code/pre  This is my code.zshrc/code:  precodeulimit -t 600 ulimit -d 512000 ulimit -v 1024000 /code/pre  And the codeulimit -a/code output (in ZSH):  precode% ulimit -a     -t: cpu time (seconds)         600     -f: file size (blocks)         unlimited     -d: data seg size (kbytes)     512000     -s: stack size (kbytes)        8192     -c: core file size (blocks)    0     -v: address space (kb)         1000     -l: locked-in-memory size (kb) unlimited     -u: processes                  709     -n: file descriptors           256 /code/pre  Yet here is what codetop/code tells me about the process:  precodePID  COMMAND      %CPU  TIME     #TH  #WQ  #POR #MRE RPRVT  RSHRD  RSIZE  VPRVT  VSIZE  PGRP PPID 886  process      30.8  01:16.40 1/1  0    17   332  2259M+ 184K   2072M- 19G+   38G    882  885 /code/pre  It just seems that none of the documented memory limitation methods actually work. Is there an additional mechanism that I may have missed?  <answer84338> ulimit on most platforms does not work as expected.  If this is not a desktop app, run the offender with a proper process supervisor such as https://github.com/arya/bluepill  If this is a desktop app, contact the app developers.  Feedback is necessary and important.  The UX on the OOM killer GUI for Mac is horrible.  It should be biggest sorted descending with a proportional bar graph for each processes' ram usage.  Furthermore, it should automatically SIGCONT all paused processes when resolved.  <answer84562> If you need this across reboots you should use only codelaunchctl limit/code command.  If you need to limit application's memory you should also limit stack segment.  <answer84690> I would create a simple script which would filter process any process with a resident memory size (or perhaps total vm size, so including any paged out pages) bigger than a threshold that I define (depending on the amount of process, total memory available and perhaps also CPU availability). One can use a bit of bash script with either codetop/code or codeps/code to dig out the list of process and memory size.  From this filtered list, I would use the codeleaks/code command (see man 1 leaks) per process PID. If the total amount of leaked memory reported by the command is higher than yet another threshold, I would then kill and respawn it.  strongNOTE/strong: You should take care not to kill any OS/System processes without knowing what you do. To avoid this situation, you should perhaps filter out the list using a "white list" approach.  <comment96534> 230 GiB?! I really hope you missed a decimal point. <comment96538> @duci9y Nope :-( <comment96569> In that case, I really hope someone fixes your problem. You'll be in my prayers. <comment96676> I eventually removed mention of what the leaking process was because people on IRC started lecturing me on why I should use clang++ instead of llvm-g++ and that only makes me want to hit them with pointy objects. <comment96688> Pointy objects on fire. <comment97380> As you can see in the output, both stack size and data size are limited. I asked the question because `launchctl limit` does *not* work. <comment97381> I've had the problem with several applications, but the straw that broke the camel's back was Apple's `llvm-g++`. The problem was reported in Radar. I'm curious: what other platform has a non-working `ulimit`? I've been using several flavours of Unix for almost 20 years and I don't remember seeing one. <comment97383> `ulimit` you use really _does not work_ as you need. `launchctl  limit` does. <comment97384> and another moment to be lighted in limits: when program reaches limits it receives warning. but with soft limit action will be executed in success, with hard — it'll be  failed. So if program requests memory beyond hard limit, no memory will be allocated. <comment97388> How do you check memory occupied by application? <comment97391> `launchctl limit` does **not** work, or I wouldn't be asking the question. <comment97392> how do you measure application size? <comment97393> `launchctl limit` like ulimit goes from BSD systems, it works in BSD, in Linux, and in Mac OS X. The only difference in how amount of application's memory calculated in different programs. If you checkout similar questions around StackOverflow, SuperUser and this communities, only answer you'll see is `ulimit` and `launchctl limit`. <comment97517> Yes, there are plenty of answers from people who believe `ulimit` and `launchctl limit` work on OS X because they’ve read about it in some documentation or someone told them. But they don’t work. The C functions `setrlimit` and `getrusage` are useless on OS X, too, despite what the documentation says. <comment97524> Have you hacked OS X kernel for it? Do you have proof links? <comment97526> Please, read this post http://stackoverflow.com/questions/3120277/virtual-memory-allocation
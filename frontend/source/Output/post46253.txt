What is the best way to clone a disk between two Macs? <body> What is the best way to clone a disk between two Macs? I ask this every couple years or so and every time I get the same answer. "Use Carbon Copy Cloner", they say. But the unfortunate fact is that CCC is a file-level copy between disks. When I migrate to my new Mac, sure all the files are there but there are quirks here and there (including file dates being different etc).   So, really now, once again: how do you clone the disk over byte-for-byte?  <answer46268> How about good ol' fashioned codedd/code. It can make a bit-by-bit copy of your drive. There are lots of guides out there on how to do this such as this one or this one  <answer46269> You can use the dd command to make a bit-perfect clone of a drive. It's a command line tool that ships with OS X. In order to make the clone perfect you'll need to ensure the source and the destination aren't actively in use.  To prepare for the clone I recommend creating a secondary boot disk that you can boot from. Your source for the clone should be an offline volume, not in use, when you're making the copy. Otherwise you risk copying things that are in incomplete states on disk.  With your machine booted to your secondary boot disk, log in and fire up a Terminal or iTerm window.  Run diskutil to get a list of your available drives. One of them will be your target drive you're trying to clone. The other will be your source drive. For example:  precode&gt; diskutil list /dev/disk0    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *320.1 GB   disk0    1:                        EFI                         209.7 MB   disk0s1    2:                  Apple_HFS Macintosh HD            319.2 GB   disk0s2    3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3        /dev/disk1    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *500.1 GB   disk1    1:                        EFI                         209.7 MB   disk1s1    2:                  Apple_HFS Backup                  499.8 GB   disk1s2 /dev/disk2    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *500.1 GB   disk2    1:                        EFI                         209.7 MB   disk2s1    2:                  Apple_HFS Clone                   499.8 GB   disk2s2 /code/pre  Let's say that codeMacintosh HD/code is the source and codeClone/code is the target for our codedd/code operation. Start the clone with:  precode&gt; sudo dd if=/dev/rdisk0 of=/dev/rdisk2 bs=1m conv=noerror,sync /code/pre  When codedd/code finishes you may see an error like this:  precodedd: /dev/rdisk2: short write on character device dd: /dev/rdisk2: Input/output error 3726+1 records in 3726+1 records out 500107862016 bytes transferred in 14584.393113 secs (34290619 bytes/sec) /code/pre  That last error message is actually okay. The last block written was a short block because there wasn't a full 1MB block to copy. No worries.  Now you've got a bit-wise perfect clone of your codeMacintosh HD/code drive. Reboot your system using the codeMacintosh HD/code drive and enjoy your clone!  <answer46272> Disk Utility can do volume-to-volume cloning with the Restore tab.  Between two Mac OS Extended volumes, this'll do a block copy, i.e. it just copies the volume structures, so all the files come out identical (down to the file ID numbers).  This is essentially the same thing codedd/code does, except that Disk Utility can expand/contract the volume if the destination isn't exactly the same size as the source, and it's a lot faster (for some reason, codedd/code is quite slow on OS X).  EDIT: After seeing @Ian's note about speed using /dev/rdiskN vs. /dev/diskN, I ran some quick&amp;dirty benchmarks copying between two 4GB flash drives:  precodedd using /dev/diskN: 2737 seconds dd using /dev/rdiskN: 907 seconds Disk Util, full volume: 840 seconds to copy + 213 seconds to verify Disk Util, empty volume: 4 seconds to copy + 1 second to verify /code/pre  So it looks like the rdisk suggestion makes dd run about the same speed as Disk Utility; the real differences are that Disk Utility verifies its data (slower, but maybe safer) and skips blank space (faster if the disk isn't nearly full).  That, and as I said above DU can resize as it copies.  <answer80816> Carbon copy cloner was good, but then on my Mac Pro it no longer made bootable clones, I tried it 3 times and every clone failed to boot unlike previously. So I switched to SuperDuper! and that clone booted fine  <answer100874> There are two types of cloning Mac drive. File level and block level based cloning. As we know carbon copy cloner can create file level based clone only and its one of the big competitor Superduper can create clone of volumes and partition only not the whole disk. So, I will suggest to go for a new emerging Mac cloning software that is Stellar Drive Clone capable to both file level and block level cloning.  It can create bit by bit exact copy of your entire drive and particular volumes on your any external drive, volume and network drive too. It can create clone of drive on folder and restore backups from the same in its free demo version feature. It can create clone of recovery HD and support window file formats, MBR, ExFAT, FAT32 etc on your Mac.   <answer116060> Apple's bespoke command line utility to do disk cloning is codeasr/code.  It is tailored to the specifics of OS X needs to perform file by file as well as block based imaging and deals with differences in partition sizes, allows network streaming (and even multicast streaming) as well as copying between disks that are locally connected. Unlike codedd/code, it knows about Apple's latest Core Storage volume management and is the program that the graphical Disk Utility calls to move data from one partition or volume to another.  You can read more at the manual page for asr.  <answer283703> h1Verbose output from codedd/code via codepv/code/h1  img src="https://i.stack.imgur.com/ftxV2.gif" alt="enter image description here"  Copying even a small disk can take a long time and the silence can be frustrating. If you install pv (pipe viewer) you can use it to monitor the progress of any stream.  If you are using homebrew (and you should be) installing codepv/code is as easy as:  precodebrew install pv /code/pre  Then decide which disks you want to copy.  precodediskutil list /dev/disk0 (internal, physical):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *251.0 GB   disk0    1:                        EFI EFI                     209.7 MB   disk0s1    2:          Apple_CoreStorage SSD                     250.1 GB   disk0s2    3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3  /dev/disk1 (internal, virtual):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:                            SSD                    +249.8 GB   disk1                                  Logical Volume on disk0s2                                  2CFBB247-D59D-474F-8467-2B1BDB275524                                  Unencrypted  /dev/disk2 (internal, physical):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:     FDisk_partition_scheme                        *15.6 GB    disk2    1:             Windows_FAT_32 boot                    43.0 MB    disk2s1    2:                      Linux                         15.5 GB    disk2s2  /dev/disk3 (external, physical):    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:     FDisk_partition_scheme                        *15.6 GB    disk3    1:             Windows_FAT_32 NO NAME                 15.6 GB    disk3s1 /code/pre  In this case code/dev/disk2/code is an Micro SD card from my Raspberry Pi in the internal reader and code/dev/disk3/code is a new MicroSD in a USB dongle.  The command to copy it is going to be very similar to common codedd/code commands except we are going to take advantage of the fact that codeof/code (output file) defaults to STDOUT and codeif/code (input file) defaults to STDIN. This allows you to use unix pipes in between.  precode# I'm going to define variables to make your copy-paste easier SRC=/dev/rdisk2 DST=/dev/rdisk3  # This is the command you want sudo dd bs=1m if=$SRC | pv | sudo dd bs=1m of=$DST  # Notice how similar this is to doing a simple sudo dd bs=1m if=$SRC | sudo dd bs=1m of=$DST  # ...which is functionally identical to sudo dd bs=1m if=$SRC of=$DST  # (except 2 processes vs. 1) /code/pre  The actual output looks like:  precodedd bs=1m if=/dev/zero count=16000 | pv | dd bs=1m of=/dev/null 16GiB 0:00:06 [2.46GiB/s] [       &lt;=&gt;                                          ] /code/pre  <comment52952> +1 for the rdisk suggestion -- I thought I'd tried that before, but I just tested and it helped enormously. <comment88321> rdisk# bypasses a 4KB OS buffer. [More info.](http://lists.apple.com/archives/filesystem-dev/2012/Feb/msg00015.html) I'd advise that you chose a smaller `bs`, as going above 1m actually makes it slower. (At least over USB. I can't tell if it's an external USB drive or a direct SATA connection.) <comment122173> As written your answer isn't much more than a list of product features but without any explanation about how the mentioned tool can solve the problem the OP has. Can you please make your answer more useful by describing the necessary steps in more detail (and maybe also explaining which benefits this method has compared to the ones described in the other answers)? <comment122174> Answers on Ask Different need to be more than just a link. It's okay to include a link, but please summarize or excerpt it in the answer. The idea is to make the answer stand alone. <comment135820> The Disk Utility for OS X is documented at http://docs.info.apple.com/article.html?path=DiskUtility/10.5/en/duh3.html. <comment138516> Note that `asr` is the same tool that Disk Utility's Restore tab uses (see my answer). The command-line interface has additional options that the GUI interface omits, such as converting between HFS+ (case insensitive) and HFSX (case sensitive) formats, and putting the copy in a Core Storage volume group. But it may be harder to use for people who aren't used to the command line. <comment166681> It may be worth experimenting a bit with the bs setting. I got significant increases in throughput (almost double) by decreasing the size from bs=1m to bs=65536. <comment166699> @JensWegar I wonder if there's a way to know the best block size to give `dd` for a given transfer without having to resort to trusting internet searches or doing trail-and-error runs? <comment166938> @IanC. I read somewhere that the block size of the HDD could be used as an indicator of the ideal size to give dd. On the other hand another source said there is no bullet proof way of figuring out the optimal size. So can't give any real advice there. However, it didn't take too long to experiment. Probably the ideal value is a factor of 2, so I'd start with 4096, then 8192, 16384 and so on. You'll find the peak pretty quickly this way. <comment259979> Is it save to execute this from the recovery mode in terminal? I've unmounted all partitions on the disk before starting dd. It's running at the moment but I'm a bit scared about the result ;) Thanks for the nice hint with "rdisk" instead of "disk" <comment259987> @MatthiasKleine yes, it's safe to execute this from recovery mode. It can take a long time to run if your disk is big. <comment357690> If you get an error: `dd: /dev/rdisk2: Resource busy` Try `diskutil unmountDisk /dev/rdisk2` (or whatever your disk number is)
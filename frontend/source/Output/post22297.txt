Is bash in OSX case-insensitive? <body> Are bash commands on OSX case insensitive? I type "which TR" and it shows /usr/bin/TR, though there is no such binary there. Same thing for other binaries, when capitalized. Or is Terminal.app maybe doing this translation? How do I turn this off?  <answer22299> Take a look at your filesystem, as there are both case sensitive and case insensitive variations on HFS.  The default is case insensitive, in which case it's not so much a case of BASH, but the underlying filesystem.  You can test this by formatting a spare USB stick with the case sensitive option, and copying files over ato repeat your test, etc.  <answer22304> This is actually a feature of the filesystem of your disk, not bash or Terminal.app.  HFS+ (the Mac filesystem) is usually configured to be emcase insensitive/em but emcase preserving/em. This means that the file system will consider codefoo/code and codeFoO/code to be the same, but when you create a new file it will remember which letters where capitalized and which were not.  When you format a disk with HFS+ you can chose whether the file system should case sensitive or not. If you chose to format with UFS (Unix FileSystem) it is always case sensitive, AFAIK.  To check whether a disk is case sensitive, run:  precode diskutil info &lt;device&gt; /code/pre  For example:  precode diskutil info disk0s2 /code/pre  Look for the codeName:/code line. If it reads something like codeMac OS Extended (Case-sensitive, Journaled)/code it means that it is case-sensitive. If it just reads codeMac OS Extended/code (without the codeCase-sensitive/code) then it is only emcase preserving/em but not emcase sensitive/em.  <answer115656> I managed to fix this with one line by following http://blog.nickburwell.com/blog/2008/11/mac-os-x-terminal-case-insensitive-auto  precodeecho "set completion-ignore-case On" &gt;&gt; ~/.inputrc /code/pre  <answer281501> Bash is definitely case sensitive.   I just typed `whoami' into terminal and the caps lock button was on.  I got a completely different response from `WHOAMI'.  I can see there is a WHOAMI command with 'which' but I can't find it with 'ls'.  <comment24711> Out of curiosity, why would you want to turn this off? <comment24712> This is a spectacular question. Bash has a **nocaseglob** option to control whether cases match in ranges, but this little bit of trickery is deeper than the normal `locale` and **completion-ignore-case** / **nocaseglob** <comment24720> HFS+ really is a bit of an oddity, having the ability to both recognise and ignore case *at the same time*.  Your case preserving note was missing from my answer, and is important for a Unix based OS which would normally be expected to be case sensitive where Foo and FOO are 2 different files.  I suspect the behaviour came about between Mac OS 9 HFS and Mac OS X HFS+ and the requirement to be understood by both classic and new apps etc. <comment24725> Outside of Unix, the case preserving nature isn't so unusual. For example, NTFS is the similar: not case sensitive by default, but you can format it so it is. I also think that the *case insensitive is default* came via Mac OS 9, but the fact that a lot of Mac and Windows developers are lazy in this respect and don't care about correct casing makes it almost impossible to switch to case sensitive as default, it breaks lots of apps. Coming from Unix, I found it very strange at first as well. <comment24726> I haven't gone back and looked, but I'm pretty sure Mac OS has used case-preserving (but not case-sensitive) filesystems since the original 1984 Mac (which used MFS -- Macintosh File System -- to format its 400k floppy disks) <comment24727> I have to admit I never used Classic Mac OS, so was guessing.  Either way, this is the answer, and DarkDust put it better than me so this one should be accepted I think. <comment24730> Every version of Mac OS has been case-insensitive-but-preserving, for usability reasons. While UNIX favours precision (byte-by-byte comparisons of filenames), it can be a usability nightmare for end users who accidentally save 'Resume' and 'REsume' and then get confused when they open the wrong version and all their changes are gone. <comment24993> Thanks for the explanation DarkDust, very informative. Funny, I've been using OSX for years and never noticed, until yesterday I accidentally typed 'LS' and to my surprise received output I expected from 'ls'. <comment24996> The reason I wanted to turn it off is silly, really. I'm used to case sensitivity when working at the shell. I am just worried this feature will trip me up. Example, I write a bash script, mistype 'lS'; the script will run fine on OSX. I move it to my cenTOS box, and it breaks. Granted, this would be easy to detect and fix, but could avoid the scenario entirely if I could keep the scripts working the same way between the two systems. I discovered this by accident, and it hasn't been a nuisance thus far, so I probably will not go through the exercise changing filesystems just for this. <comment93583> The reason you would want to turn this off is that case insensitivity causes problems for some apps, like SVN. Case insensitive globbing could be useful, but SVN gets very very confused if you create a file called "Foo", then somehow the repository creates a reference to "foo". <comment105167> On the other hand, it can *also* be a "usability nightmare" when typing "HEAD" at the command-line results in the program /usr/bin/head (show first lines of a file) being executed instead of /usr/local/bin/HEAD (from LWP: make an HTTP 'HEAD' request). <comment228700> Thinking that for every uppercase character there is one lowercase equivalent and vice versa is typical of English speaking programmers, and is not locale-independent. I don't know what solution has been adopted for Turkish, where there is the dotted lowercase `i` corresponding to the DOTTED uppercase `İ`, while the dotless uppercase `I` corresponds to the DOTLESS lowercase `ı`, but ANY solution will be bad. And what about the German `ß`, often capitalized with 2 `S`s? And accents that are often left out when capitalizing? And... Case sensitivity does away with all of these headaches. <comment253427> Another reason to disable: I have had a script ~/bin/CC in my path since circa 1980.   cc plus some pleasant defaults.  It has worked from UNIX v6 through v7, Eunice, BSD 4.1, 4.2, 4.3, SVr4, Xenix, Gould UTX, Linux, cygwin...  and it failed for the first time on MacOS, infinite recursion. <comment253434> I wondered if HFS+'s case insensitivity could be exploited for a security hole. Googling reveals that the problem has already been encountered  http://article.gmane.org/gmane.linux.kernel/1853266  http://www.itworld.com/article/2868393/linus-torvalds-apples-hfs-is-probably-the-worst-file-system-ever.html January 2015  Although fixed in Git, this is an exploit waiting to happen, for Mac users who have ever installed software from some other UNIX-like case-sensitive system.   For that matter, it is probably a potential security hole for code ported from case sensitive iOS to Mac OS X. <comment299914> This just screwed me over as well. A build and dev deployment that work fine on OSX break in test on Ubuntu because I mistyped one letter in my gulp script in lower case rather than upper-case. I'm not a fan of this feature because it forgives errors that, in all likelihood, your production system won't. <comment354261> This isn't the shell being case sensitive, it's the `whoami` program itself. It's actually the same program as `id`, but it checks which name it was run as, and uses a different output (equivalent to `id -un`) if run under the name "whoami". *That* check is case sensitive. Compare the output of `id`, `WHOAMI`,`WhOaMi`, `WhoAmI`, etc. Also, compare the output of `ls -li /usr/bin/whoami` vs `ls -li /usr/bin/WHOAMI`, and note that the inode number (the first thing listed in the output) is the same -- they're two different ways of specifying the exact same file.
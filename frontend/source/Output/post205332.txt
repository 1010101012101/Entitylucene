Why does leaked memory appear malloced to kernel_task, and why can't OS X therefore garbage collect it <body> I have previously been told that a sign that some application has a memory leak is that codekernel_task/code has a large memory footprint, commonly on the order of gigabytes. If an awry codekext/code was causing this memory usage, we would expect to see a discrepancy between the allocated memory and those expected to be allocated, i.e.   precodediff &lt;(kextstat|tr -s ' ' | cut -d ' ' -f 5) &lt;(kextstat| tr -s ' ' | cut -d ' ' -f 6)  /code/pre  would return something other than the words 'Wired' and 'Name'.   Whilst writing my thesis, I have noticed that changing a pdf whilst it is open in Preview often causes bad things to happen: occasionally, the memory usage of codekernel_task/code can grow to around eight gigabytes, or more. strongIf I kill preview, it returns to normal, instantly/strong. So, obviously something is wrong -- and Preview is leaking memory under these conditions.  So, my question is this: if emI/em know that a process has leaked ram via a sudden and unexpected increase in the footprint of codekernel_task/code, why can't emOS X/em know that something has gone wrong. If killing Preview restores my missing codemalloc()/code'd memory, why emdoesn't/em Darwin do garbage collection automagically for me?   Do I have a fundamental misunderstanding of how memory management works?   strongEDIT:/strong (15/9/15)  Here's a demonstration of what I'm talking about. First of all, I notice high memory usage by codekernel_task/code (note Preview is open, just visible at the bottom of Activity Monitor, using 333 MiB of ram):   img src="https://i.stack.imgur.com/n2L94.png" alt="High kernel memory usage"  Following the helpful remarks by Ashley below, let's find out how much each kext is using:   precode$ kextstat | awk 'NR==1{ printf "%10s %s\n", $5, $6; } NR!=1{ printf "%10d %s\n", $5, $6; }' | sort -n  ... ... ...    1249280 com.apple.driver.DspFuncLib    1769472 com.apple.nvidia.driver.NVDAGK100Hal    2629632 com.apple.nvidia.driver.NVDAResman    6184960 com.apple.driver.AirPort.Brcm4360 $ /code/pre  So, not a huge amount. My machine has both discrete and integrated GPUs; their drivers are only using a few MiB of wired ram. On my hunch, let's kill Preview, and look what happens to the memory footprint of codekernel_task/code:  img src="https://i.stack.imgur.com/IiRgs.png" alt="Killing preview helps things"   Preview's gone, and the memory footprint of the kernel has gone down dramatically.  There's still no evidence of a change in kext usage: the output of the above command is unchanged.  strongEdit/strong: Bug reported as No. 22701036. I am still waiting for a response from apple. There's nothing particularly interesting if you inspect the process in ActivityMonitor, but maybe I'm missing something.   <answer205699> Here's my guess, assuming your Mac has an integrated GPU (eg Intel Iris Graphics).  When you have your thesis open in Preview, graphics card memory is used to hold the image ("texture") of the Preview window, and perhaps also some off-screen-but-decoded pages from the thesis.  With an integrated graphics card, the video memory is actually (partially?) located in system RAM, which is shared between the CPU and GPU.  On some integrated graphics cards, the amount of system RAM used is dynamically allocated (see Apple HT204349).  I'd guess that you are intermittently seeing a bug in the graphics card driver and/or Preview, which isn't releasing system memory correctly when Preview reloads your thesis PDF.  (However this bug is mitigated by OS X / the driver correctly releasing the memory when Preview quits.)  You could try looking at the output of codekextstat/code and see if the numbers in the codeSize/code column increase when you experience the issue.  My theory is that the 8GB increase you mention will be due to the graphics card driver.  The following command (from a comment on this related and interesting answer) sorts the output of codekextstat/code to make it easier to see which kext is using the most memory (although note this sorts by the codeWired/code column... there's a similar, simpler incantation in this answer with an explanation if you'd like to tweak this).  precodekextstat | awk 'NR==1{ printf "%10s %s\n", $5, $6; } NR!=1{ printf "%10d %s\n", $5, $6; }' | sort -n /code/pre  <answer205721> The core of OS X is not garbage collected; IOKit's libkern C++ Runtime requires developers to manage their own memory.  h2Mac Memory Management/h2  From How does memory management work in Mac OS X?     Apple documents the lowest levels of the Mach Kernel and the virtual memory subsystem fairly well on the web as part of it's developer documentation.      ul   liKernel Programming Guide: Memory and Virtual Memory/li   /ul      Since that kernel was developed by Carnegie Mellon University, you can find dozens of papers describing it quite easily.   h3Other Sources/h3  ul liWikipedia discusses Mac OS memory management./li liApple's support note: Use Activity Monitor to read system memory and determine how much RAM is being used/li /ul  h1Garbage Collection/h1  Garbage collection exists at the user or application layer. Even at this layer, garbage collection only helps if the application has released all claims to the memory. A circular dependancy can defeat garbage collection. Garbage collection itself is an evolving area of research and difficult to get right.  h2Report Bugs and Memory Leaks/h2  Bugs within OS X will be leaking memory. Given the size of the code base, this is almost certain.  Please report reproducible bugs directly to Apple. Every bug report helps and maybe your example will be the one that helps Apple's engineers pin down the cause.  <comment248061> I'm confused about two things -- could you clarify? 1) I think your `diff` command is comparing the `Size` and `Wired` columns from the `kextstat` output. I agree that `Size` is "allocated memory", but I don't think `Wired` is "expected to be allocated" (`man kextstat` describes it as "The number of wired bytes of kernel memory that the kext occupies"). 2) Are you seeing the discrepancy between `Size` and `Wired` when you have the issue with Preview? <comment248063> 1) You're right -- I am comparing the elements in Size and Wired from `kextstat`. My understanding is that if a _kext_ is leaking, then the allocated bytes and those that the kernel knows _are_ allocated will be different. In this case, I've put that there to show that I _don't_ have a leaking kext -- so, 2) this doesn't occur when Preview eats ram. Instead, `kernel_task` grows a lot. I'll try and recreate this issue and take a picture :-). <comment248064> Thanks! Hold on a sec: I'm just writing an answer that might help. <comment248090> Good guess -- and thank you hugely for a useful, sorted output of `kextstat`. However, it still doesn't look like that's what is actually going on: during the Preview-gobbling, the memory footprint of `com.apple.nvidia.driver.*` was unchanged. I've edited my question to reflect this. <comment248733> This is disappointing, but undoubtedly correct. I've reported the bug to Apple -- I just find it annoying! <comment248806> Please can you share the bug number as an edit to your question. Others finding your question helpful can then file duplicate bugs noting your original. A pile of related bugs will help justify more engineering time.
My Launch Daemon doesn't work despite returning a 0 status <body> For some reason, the launch daemon I created will not run successfully at system boot. I have tried it as a launch agent but that also doesn't work.  This is my plist located in /Library/LaunchDaemons:  precode&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt; &lt;plist version="1.0"&gt; &lt;dict&gt;     &lt;key&gt;Label&lt;/key&gt;     &lt;string&gt;com.inetmac4.status&lt;/string&gt;     &lt;key&gt;ProgramArguments&lt;/key&gt;     &lt;array&gt;         &lt;string&gt;/bin/sh&lt;/string&gt;         &lt;string&gt;/Users/inetmac4/script/VMSTATUS/vmstatus_startup&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;KeepAlive&lt;/key&gt;     &lt;false/&gt; &lt;/dict&gt; &lt;/plist&gt; /code/pre  Interestingly, the script does run correctly if executed manually, just not through the daemon. And when running launchctl list after boot, the status for com.inetmac4.status is 0, but the script didn't appear to ever run.  Any help would be greatly appreciated! I've Googled but none of the solutions out there that I've found will work for me.  EDIT: It should be noted that I'm trying to run it on a Mac Pro on 10.8.5  EDIT2: And the script:  precode`#!/bin/bash #cd /Users/inetmac4/ #python -m SimpleHTTPServer &gt; ~/outfile 2&gt; ~/errfile &lt; /dev/null &amp; disown cd /Users/inetmac4/Script/VMSTATUS/ ./VM.sh  &gt; ~/outfile 2&gt; ~/errfile &lt; /dev/null &amp; disown` /code/pre  VM.sh:  precode#!/bin/sh  #  VM.sh #   # #  Created by INETMac4 on 9/12/13. # COUNTER=0  while [  1 ]; do      perl VM_STATUS.pl     let COUNTER=COUNTER+1     sleep 5 done /code/pre  and VM_STATUS.pl:  precode#!/usr/bin/perl use Data::Dumper;  #-- the same command in list context        my @result = `prlctl list --all`;      shift @result;     open (VMSTATUS, '&gt;/Users/inetmac4/Sites/index.html');     open (USERLOG, '&lt;/Users/inetmac4/script/username_log.txt');      my @user_log = &lt;USERLOG&gt;;     my @user_log = reverse(@user_log);      my @user_status;      my %hash = ();     foreach (@user_log){          my @values = split(/\\/), $_;          my $computer_name = $values[1];          if (exists($hash{ $computer_name }) == 0){             $hash{ $computer_name } = 'true';             push(@user_status, $_);         }      }      my @user_status_formatted;     # Replaces domain name with OS type     foreach (@user_status){         my @values = split(/\\/), $_;          if ($values[1] =~ /PSSTEAM-W7VPC/){             push(@user_status_formatted, $values[0] . '\\' . "Windows 7" . '\\' . $values[2]. '\\' . $values[3])         }         if ($values[1] =~ /PSSTEAM-W8VPC/){             push(@user_status_formatted, $values[0] . '\\' . "Windows 8" . '\\' . $values[2]. '\\' . $values[3])         }         if ($values[1] =~ /PSSTEAM-XPVPC/){             push(@user_status_formatted, $values[0] . '\\' . "Windows XP" . '\\'. $values[2]. '\\' . $values[3])         }      }     #print Dumper %hash;      #print @result;      foreach (@result){          my @columns = split(/\s+/), $_;         my $name  = $columns[3]." ".$columns[4];         print VMSTATUS "&lt;b&gt;Virtual Machine: &lt;/b&gt;". '&lt;a href="VM_Start_INETMAC4_Windows7.cgi"&gt;'.$name."&lt;/a&gt;&lt;/br&gt;\n";         print VMSTATUS "&lt;b&gt;STATUS:&lt;/b&gt; ". $columns[1]."&lt;/br&gt;\n";         if ($name =~ 'Windows 8.1'){             print VMSTATUS "&lt;/br&gt;\n";         }         foreach (@user_status_formatted){             my @values = split(/\\/), $_;              if ($values[0] =~ 'LOGGEDOUT' &amp;&amp; $values[1] =~ $name){                 print VMSTATUS "&lt;b&gt;User:&lt;/b&gt; Loggedout/ No user"."\n&lt;/br&gt;&lt;/br&gt;";                 last;             }             if ($values[1] =~ $name){                 print VMSTATUS "&lt;b&gt;User: &lt;/b&gt;  " . $values[2] . "\\" . $values[3]."\n&lt;/br&gt;&lt;/br&gt;";             }          }         print VMSTATUS "&lt;hr&gt;";     }      close (VMSTATUS); /code/pre  <answer104322> You need to add code&lt;key&gt;RunAtLoad&lt;/key&gt;&lt;true/&gt;/code to run the program when the job is loaded (or at login). See codeman launchd.plist/code:  precodeRunAtLoad &lt;boolean&gt; This optional key is used to control whether your job is launched once at the time the job is loaded. The default is false. /code/pre  If you want the program to be ran again if it terminates, also set codeKeepAlive/code to true.  You can apply changes to a plist by unloading and loading it.  <answer104564> For those who don't want to read through the comments, it was a pretty simple fix after Mark gave me a bit of insight.  Initially, I wrote the vmstatus_startup script to call VM.sh which would then continually refresh the perl script (every 5 seconds). I was attempting to call the shell script from launchctl which just adds layers of complexity.  Instead, calling the perl script directly from the .plist and giving the keep alive key allowed it to run constantly after boot.  Finally, I had to make sure to add the perl directory to the .plist above the location of the script since launchd doens't have a PATH the same way a user does.  <comment122722> What is in vmstatus_startup? does it fork? <comment122725> *Edited original with script*  @Mark it's supposed to call a shell script that refreshes the status of installed virtual machines and posts them to an html file. It works just by calling the executable in a terminal window though... Thanks! <comment122726> Can you put that in the question and make it readable <comment122727> No problem, didn't realize how poorly it would format. <comment122728> We need to see VM.sh as this is what should be in the .plish - all the pipes etc should be done in the .plist and not a shell script. Also disown I don't think should not used in a Launch Agent <comment122730> Thanks for all the help so far, I'll post VM.sh. The only reason disown is in there is so VM.sh will continuously run, vmstatus_startup is meant to call VM.sh once and VM.sh to refresh every 5 seconds with the status of the installed virtual machines. <comment122732> You need to effectively start and use launchd to manage all these with launchd - better to run a script (in this case VM_STATUS.pl) every 5 secs as a Launch Agent <comment122738> Thanks! It took a little additional tinkering with the perl script but it works! <comment122745> It would be useful if you provide an answer below and accept it so people know: a) this has been answered, b) this does not need others to spend time going through all the comments <comment122753> No problem! Since I'm a new user I can't answer my own question for 8 hours after the original post. I'll post the answer once it allows me to. Thanks!
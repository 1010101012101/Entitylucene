Export PATH directly from command line in Yosemite--where is my PATH? <body> I want to use the latest version of git which I installed via Homebrew, so I needed to change my codePATH/code variable to ensure OS X uses the Homebrew version instead of the outdated version that ships with OS X and Command Line Tools. This tutorial recommends simply running:  code$ export PATH=/usr/local/bin:$PATH/code  That's what I did and it worked great.  My question is: where did this command modify my codePATH/code variable? I don't have code~/.bashrc/code, code~/.bash_profile/code, or code~/.profile/code files in my home directory at all, but when I code$ echo $PATH/code then the codePATH/code appears correct and when running codewhich git/code and codegit --version/code everything appears to point to the right place. I do see the correct paths listed in code/etc/paths/code but if I add a test path using codeexport/code from the command line then the test path does not appear in that file.  Another question: is this a good way to modify my codePATH/code variable?  Final question: what are the advantages and disadvantages of this method?  strongEdit:/strong I do see the correct paths listed in code/etc/paths/code but if I add a test path using code$ export PATH=/test:$PATH/code then the test path does not appear in code/etc/paths//code, but it appears first when I run code$ echo $PATH/code, however it is lost after rebooting.  <answer189028> h2On June 3 you posted the following comment/h2  @DavidAnderson So if I understand correctly, running export PATH... from an interactive shell session only affects $PATH for that session and the newly added path is not saved anywhere (and therefore there is no file where the newly added path can be edited). E.g., if I run export PATH=/test:$PATH but I meant to export the /testing_123 dir instead, then my best option is to simply start a new session rather than attempt to locate and edit a file containing the erroneous /test dir (because there is no such file). Correct?  h2My response to your comment/h2  From the manual page for bash, I have extracted the following.  precodeA parameter is an entity that stores values.  It can be a name, a number, or one of the special characters listed below under Special Parameters.  A variable is a parameter denoted by a name.  A variable  has a value and zero or more attributes. /code/pre  codePATH/code is the name of a variable. Normally, this variable has only the export attribute turned on. The export attribute marks a variable for export to subsequent  commands via the environment. The codeexport/code command turns on the export attribute, but in the case of the codePATH/code variable, the export attribute is already turned on. Therefore, for the codePATH/code variable, the next four commands are equivalent.  precodePATH=/test:$PATH export PATH=/test:$PATH declare PATH=/test:$PATH typeset PATH=/test:$PATH /code/pre  As for your comment, you are correct. There is no such file.  In the case of a mistake of the type you mentioned, I do not think starting a new session would be the best option. I would enter the command   precodedeclare -p PATH /code/pre  and then highlight the output. You can then cut and paste the text as your next command. Before hitting the return key, use the other keys to correct your mistake.  For more information on this subject, see the manual page for bash. Either enter the command   precodeman bash /code/pre  or visit the site: bash - GNU Bourne-Again SHell.  h2In response to your Edit:/h2  Yes, you are suppose to lose /test in your PATH variable when you reboot. This is why you need to put an codeexport/code command in your code~./profile/code file.  h2Original answer:/h2  You seem confused when the code~/.bashrc/code, code~/.bash_profile/code, and code~/.profile/code files execute. Maybe this will help.  Here is how I set up my computer. I have three files: code~/.profile/code, code~/.bashrc/code and code~/.bashcm/code. If you are missing any of these, you can create them.  When I start the Terminal application or select "New Window" from "Shell" on the menu bar, an interactive bash login shell is invoked. This shell executes the code~/.profile/code script at startup. You can substitute code~/.bash_profile/code or code~/.bash_login/code for code~./profile/code if you wish. If an interactive bash shell that is not a login shell  is  started,  the shell reads  and executes commands from code~/.bashrc/code. The purpose of code~/.bashcm/code is to provide a common script to be executed by both code~/.profile/code and code~/.bashrc/code.  Here is an example of a code.profile/code file  precodeecho in .profile source ~/.bashcm export PATH=$PATH:~/bin echo exit .profile /code/pre  The purpose of the echo commands are to illustrate when the scripts are executed. Once you are comfortable, you can either comment out or delete them.  The code.profile/code file executes code.bashcm/code script, then modifies the PATH variable and exits. An example code.bashcm/code file is shown below.  precodeecho in bashcm PS1='\h:\W \u\$ ' alias home='cd ~' echo exit .bashcm /code/pre  Other than the echo commands, code.bashcm/code only sets the prompt and an alias. The example code.bashrc/code file shown below simply executes the code.bashcm/code script. Again the echo commands are just for illustration purposes.  precodeecho in .bashrc source ~/.bashcm echo exit .bashrc /code/pre  If I start the Terminal application and enter the commands  precodeecho $PATH alias bash echo $PATH alias  in the window, I get the following.  Last login: Wed May 27 14:48:19 on ttys000 in .profile in bashcm exit .bashcm exit .profile Steelhead:~ davidanderson$ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/davidanderson/bin Steelhead:~ davidanderson$ alias alias home='cd ~' Steelhead:~ davidanderson$ bash in .bashrc in bashcm exit .bashcm exit .bashrc Steelhead:~ davidanderson$ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/davidanderson/bin Steelhead:~ davidanderson$ alias alias home='cd ~' Steelhead:~ davidanderson$  /code/pre  <comment223814> This is a duplicate of many (and you have several questions here)  - however /usr/local/bin is on your default path set in /etc/paths <comment223824> @Mark I believe my main question is more specific than most other questions I've seen on the topic. I have not yet seen a question where it is answered. So telling me that it's a duplicate is essentially saying "someone somewhere answered your question" but omitting where the answer may be within a vast body of questions and answers. If you care to point me in the right direction then that would be most helpful. If it is indeed answered elsewhere then I will happily remove my question. Thank you. <comment223827> Sorry I eft the second bit of the comment as the answer until I could find a decent duplicate and found one but forgot to give it see http://apple.stackexchange.com/a/121021/237 - and see what the answer lists in /etc/path. Also please comment on what is not explained on that answer as we need to get a canonical answer set up - so the next person does not have to do all the searching <comment223830> re the adding to /etc/paths not working - that I think should be a separate question as it does work so we need to know exact try what you did (including if yo did a reboot which is needed) <comment223838> @Mark thanks for clarifying. I will consult that stack and perform some more tests and update this stack according to what I uncover. <comment223842> Entering the command `export PATH=/usr/local/bin:$PATH` did not accomplish anything. It does not modify the file `/etc/paths`. This file already had `/usr/local/bin` on its first line. What you did was change the PATH variable from `/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin` to `/usr/local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin`. <comment223931> @DavidAnderson running that command did accomplish *something*, it just didn't modify `/etc/paths`. I edited the question to reflect that. When I run that `export` I do not see the first path twice as you say I should. <comment223951> hat edit confirms that editing /etc/paths needs to be a separate question - export etc has nothing to do with /etc/paths. export .... does chnage what the environment is in your current shell <comment223958> If I see it, then you change the question so you don't see it, that does not mean I didn't see it. It means you changed the question! <comment223965> `export` actually makes sure that `PATH` is visible in processes run from within the shell. Without `export`, variables are only visible in the current (shell) process, not in any child processes. <comment225435> @DavidAnderson So if I understand correctly, running `export PATH...` from an interactive shell session only affects `$PATH` for that session and the newly added path is not saved anywhere (and therefore there is no file where the newly added path can be edited). E.g., if I run `export PATH=/test:$PATH` but I meant to export the `/testing_123` dir instead, then my best option is to simply start a new session rather than attempt to locate and edit a file containing the erroneous `/test` dir (because there is no such file). Correct? <comment225608> @patrix: Upon further research, it turns out the use of `export` is optional for the `PATH` variable. So for example, `PATH=$PATH:~/bin` would be equivalent to `export PATH=$PATH:~/bin`. To make the two commands act differently, you would first have to enter the `declare +x PATH` command. This would turn off the export attribute. <comment225610> @cfx: I updated my answer in response to your latest comment. <comment225628> It's enough to `export` a variable once, for PATH this already takes place in `/etc/profile` when the output of `/usr/libexec/path_helper -s` is evaluated. <comment225634> @patrix: Actually, the export attribute is set before `path_helper` is evaluated. The `PATH` is changed by  `path_helper`  from `/usr/bin:/bin` to `/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin`.
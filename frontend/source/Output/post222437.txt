Mac Terminal - Rename Keeping Last 6 Characters <body> I'm using the built in Terminal, and I am totally new to this coding so I will need to know exactly what to type when I open the Terminal. Also, please don't direct me to any other software. So lets say...  ul liI have a folder named "Power" on my Desktop (without the quotation marks around it of course)./li liIn that folder there are multiple .tif files named like the following:  ul liWashington,George-150987.tif/li liLincoln,Abraham-755103.tif/li liSmith,Jack &amp; Jill-102347.tif/li liJones-Newman,Martha &amp; John Newman-137881.tif/li /ul/li liThese names have one thing in common. They all have a 6 digit number before the extension, and always will./li liI want a way to batch rename a large group of these files keeping just the last 6 digits. Hell, if there's a code that could rename keeping just numbers, that would be THE BEST, because in rare occasions, there might be a  Smith,Jane-108965(mrs).tif/li /ul  But if there is no code for that, that's fine, I can use another software to get rid of that (mrs) in a second.  <answer222441> strongMake a backup of the files first!/strong  Then open Terminal (, start a codebash/code shell if you are not using the default shell) and run  precodecd ~/Desktop/Power \ls | while IFS= read f; do echo mv -vn "$f" "${f/*-/}"; done /code/pre  This will emnot/em rename anything but just show how each file will get renamed. If the output looks ok, run  precode\ls | while IFS= read f; do mv -vn "$f" "${f/*-/}"; done /code/pre  PS: This assumes that the only code-/code in the file names is the one right before the number.  hr  Some explanations about what's going on here:  ul licode\ls/code lists all files, the code\/code ensures that no alias expansion takes place. The output is fed into a pipe but we do not need to worry about multi-column output because codels/code in these cases automatically assumes code-1/code/li licodewhile ... do; ...; done/code loops over all lines/files/li licodeIFS= read f/code reads a file name from standard input into code$f/code. The codeIFS=/code ensures that none of the characters on standard input confuses coderead/code into expecting two values instead of one (technically this is probably not required here, but it's good practice anyway)/li licode${f/*-/}/code does string substitution on the value of code$f/code, in this case replacing everything up to and including the code-/code with the empty string. See codeman bash/code (Parameter Expansion) for details./li /ul  <comment269637> Just a small nitpick for your learnings, it would not be called `code` but `command`, which can be combined into a `script`. Since you are using  preexisting applications and utilities
Why does this applescript not actually set the input volume to zero? <body> I have this command that builds a script to mute the input volume. The input volume is not fully muted, though. It seems to be closer to 10% than 0%.  precodeosacompile -x -e 'tell application "System Events" to set volume input volume 0' -o ~/bin/mute_mic.scpt /code/pre  This is odd, because the slider bar is as far left as it can go, but as you can see from the attached image, sound still is registering. However, if I use the mouse to click on the slider at zero, then it does actually mute the input.  Why does this happen? Am I using applescript improperly here?  img src="https://i.stack.imgur.com/8SmjB.png" alt="Proof of script not muting."  I can even replicate this with the basic AppleScript Editor, so I know it's not a problem with the compilation.  img src="https://i.stack.imgur.com/B97Fy.png" alt="applescript not working"  (Note: I originally took my cue for the solution to this problem from this question's answer.)  <answer67069> As far as I can tell, the script works as expected, the problem is in the OS X audio input code. When I run it, the slider goes to 0%, verified by mousing over the slider until the tooltip appears:  img src="https://i.stack.imgur.com/QRJjt.png" alt="tooltip"  This is the same as if I drag the volume slider manually.  The problem is seemingly that "0%" doesn't actually mean emoff/em, but rather a very low threshold. In some quick testing, I could record the sound of my finger tapping on my MacBook Pro's casing near the mic (on most machines I believe it's around the right speaker grill) emwhen the volume was set to 0/em. I could replicate that regardless of whether I set the slider manually or via AppleScript. It did seem to be low enough that virtually any other sound isn't picked up, but clearly the microphone isn't truly off.  As far as I can tell, there's no way to properly mute the built-in mic. The best I can suggest is changing the audio input to use the line in, strongif your Mac is equipped with a line in port/strong. Doing that via AppleScript requires some GUI scripting unfortunately, but this should do it (source):  precodetell application "System Preferences"    activate    set current pane to pane id "com.apple.preference.sound" end tell tell application "System Events"    tell process "System Preferences"        set frontmost to true        --get properties of UI element of tab group of window "Sound"        click radio button "input" of tab group of window "Sound"        tell row 2 of table 1 of scroll area 1 of tab group 1 of window "Sound" to set selected to true    end tell end tell /code/pre  If you have more than the two standard audio inputs (Mic and Line In), you may need to change the number in coderow 2/code to whichever is appropriate, according to the order in your Input preferences.  <answer67079> This builds off of @robmathers GUI scripting piece and my question about if you can "click" the slider with applescript. I did some digging into AppleScript and UI actions and it turns out you emcan/em.  This uses GUI scripting which is sad, but it WORKS.  precodetell application "System Events"     set volume input volume 0 end tell tell application "System Preferences"     activate     set current pane to pane id "com.apple.preference.sound" end tell tell application "System Events"     tell process "System Preferences"         set frontmost to true         click radio button "input" of tab group 1 of window "Sound"         perform action "AXDecrement" of slider 1 of group 2 of tab group 1 of window "Sound"     end tell end tell tell application "System Preferences"     quit end tell /code/pre  Here's what's happening in this script:  ol liSets the input volume to 0 -- this moves the slider all the way to the left/li li"Clicks" the slider to do whatever behind-the-scenes voodoo that Apple has deemed necessary to actually "mute" the input line (this is getting ridiculous)/li liQuits the System Preferences Application./li /ol  One thing to note: The Sound Preferences window cannot already be open before running this or the first codeset volume input volume 0/code doesn't work.  It's also trivial to edit the script to unmute (which also suffers from the same issue). (Use "AXIncrement" for the action)  Huge props to @robmathers on getting me as far as I needed to figure this last piece out. I'll still wait to award the bounty in case someone else has a more elegant solution, but otherwise, it's his for the taking.  <answer227901> There now seems to be an app to do this Shush https://itunes.apple.com/us/app/shush-microphone-manager/id496437906?mt=12  <comment79063> You'll notice from my screenshot, I don't have any other "input" method than the "Internal microphone". Why would there be no "Line in"? <comment79066> Sorry, I missed that. I forgot that most of the recent MacBooks don't have line in, only the 15" non-retina MBPs do. Technically you can still do mic-in with an iPhone compatible headset, but that's not really useful in this case. <comment79067> Since we're talking GUI scripting, is there a way to simulate a click on the slider once I've set it to zero? (my applescript knowledge on how to do this is lacking) <comment79075> (yes it is, see my answer) <comment79076> Looks like you got that, but your script doesn't seem to change anything, it's the same as setting it directly via AppleScript or manuallyâ€”the issue of it not actually being muted is still there. Perhaps I misunderstood your original intent? <comment79079> I was wrong in assuming the click on the slider was equivalent to the AXDecrement action; it's not. I have updated my answer and it is working for me wonderfully. <comment79080> If anyone wants to keep track of future changes to this little utility, look at my dotfiles: https://github.com/kyounger/dotfiles/tree/master/osx/muting-scripts
How do I reset the scrollback in the terminal via a shell command? <body> When using Terminal.app, you can clear the screen by using the shell builtin codeclear/code or by pressing kbd^/kbd+kbdL/kbd (Control-L).   However, all this does is push the current screen content back one screen height and reset the cursor/input at the first line. Meaning you can still scroll back and see it.  What you are also able to do, is reset your entire scrollback by pressing kbd⌘/kbd+kbdK/kbd (Command-K).   After you've done this, you cannot scroll back at all.  In certain situations (notably, before running codescreen/code or codevim/code), I'd like to reset the scroll back before the command actually executes.  Is there a command (like codeclear/code) that is implemented in OS X that allows me to do this? Given the existence of codepbcopy/code and codepbpaste/code, I'm thinking something similar might exist that will allow me to do this.  <answer31887> ⌘K, shortcut to “View  Clear scrollback”.  strongUPDATE/strong: This can be automated with AppleScript by the following command:  precodeosascript -e 'tell application "System Events" to keystroke "k" using command down' /code/pre  …which you can of course codealias/code to whatever you want, or store in a function in your code~/.profile/code login script&nbsp;&nbsp;:)  As a security though, to be able to use this even in background without risking to issue a keystroke to a wrong front app, I'd advise surrounding it with the following test:  precodeif application "Terminal" is frontmost /code/pre  …which gives us the following code:  precodeosascript -e 'if application "Terminal" is frontmost then tell application "System Events" to keystroke "k" using command down' /code/pre  …which in turns, properly escaped and codealias/codeed, ends in:  precodealias clear="osascript -e 'if application \"Terminal\" is frontmost then tell application \"System Events\" to keystroke \"k\" using command down'" /code/pre  And here is your new codeclear/code!&nbsp;&nbsp;:)  <answer113168> Terminal supports an extension of the ED (Erase in Display) escape sequence to erase the scroll-back. It is also supported by xterm. The ED command, described in the VT100 manual, accepts these values for the Ps parameter:  pre ESC [ Ps J  Parameter   Parameter Meaning  0           Erase from the active position to the end of the screen 1           Erase from start of the screen to the active position 2           Erase all of the display /pre  Terminal (and xterm) adds:  pre 3           Erase the scroll-back (aka “Saved Lines”) /pre  Note that this only erases the scroll-back, not the screen. This allows you to erase one or the other, or both by sending two escape sequences.  For example, you can clear the screen and the scroll-back with the following shell command: codeclear &amp;&amp; printf '\e[3J'/code  (The codeclear/code command looks up the appropriate sequence for clearing the screen for the current terminal, but the “erase scroll-back” escape sequence is custom and must be hard-coded. If you put this in a shell script that you don’t know for certain will only ever be run with Terminal, you should check that $TERM_APPLICATION is Apple_Terminal before sending it.)  <comment36556> The point here is I'd like to set up something in my shell's environment so that when I run a command (say `vim`), the shell executes the "scrollback reset" before executing vim.  Programmatic, not interactive. <comment36561> @JasonSalaz Ok, didn't get that, sorry. Added code for that. <comment36927> @JasonSalaz if this answer did solve your problem, please remember to validate it. If it didn't, please get back to us in the comments  :)  Remember, [users from the future](http://xkcd.com/979/) will thank you  ;) <comment36928> That comic is about me, you know. I do program in Denver, CO.  (No, not really, it'd be insane if it were, though.) <comment144431> This does not work for me. As far as I can tell, it is the equivalent of typing `clear`; that is, it clears the screen, but I can still scroll back. Hitting `Command` `K` works normally. <comment144582> @ZevEisenberg Are you sure you did `alias clear` in the same session as calling it? Otherwise, if you invoke `clear` later on, you will call the builtin `clear`. You can check that by typing `alias clear`. If it tells you `alias: clear: not found`, then you were calling the builtin  :) <comment144802> Pretty sure I didn’t even get that far. I was calling osascript directly. Figured I would get it working before making the alias in my .zshrc. <comment144995> @ZevEisenberg Well, I confirm copy-pasting and executing the `osascript` line works fine under OS X 10.6.8 and 10.9.2, with the built-in Terminal and bash 4.2. Could you please give more information for reproducing? <comment145021> If I type Command-K and then try to scroll up with my trackpad, it does not scroll. If I use the AppleScript, it scrolls past the top line to some blank space. Close, but not identical. <comment155334> This is so much faster than osascript! <comment227733> This is a much better answer. So, to make this permanent, add to your ~/.bash_profile:  `alias clear="clear && printf '\e[3J'"` <comment279876> I put this script in my PATH: `echo $'#!/usr/bin/env bash\n/usr/bin/clear\nprintf \'\\e[3J\'' clr; chmod +x clr` <comment280053> @WalkerHaleIV Why are you creating an executable instead of just printing the escape sequence to stdout? <comment373974> As Chris Pages answer says in Terminal use command: `clear && printf '\e[3J'` _(You have selected the wrong answer as correct answer!)_
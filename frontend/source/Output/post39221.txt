Is there a way to auto-complete the open command in Terminal? <body> I frequently use the codeopen -a/code  command in Terminal to open applications via ssh. How do I make it auto-complete an application's name?  <answer39238> Programmeable autocompletion to the rescue! Needed a lot of copying from the Bash Completion Homepage though, which is worth installing anyway for a lot of auto-completion magic. If you do, you will only need the last function (code_open/code) and the initialising command from below.  Add the following to code.bashrc/code:  precode# taken from http://bash-completion.alioth.debian.org/  _compopt_o_filenames() {     # We test for compopt availability first because directly invoking it on     # bash &lt; 4 at this point may cause terminal echo to be turned off for some     # reason, see https://bugzilla.redhat.com/653669 for more info.     type compopt &amp;&gt;/dev/null &amp;&amp; compopt -o filenames 2&gt;/dev/null || \         compgen -f /non-existing-dir/ &gt;/dev/null }  _tilde() {     local result=0     # Does $1 start with tilde (~) and doesn't contain slash (/)?     if [[ ${1:0:1} == "~" &amp;&amp; $1 == ${1//\/} ]]; then         _compopt_o_filenames         # Try generate username completions         COMPREPLY=( $( compgen -P '~' -u "${1#\~}" ) )         result=${#COMPREPLY[@]}     fi     return $result }  _quote_readline_by_ref() {     if [[ ${1:0:1} == "'" ]]; then         if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then             # Leave out first character             printf -v $2 %s "${1:1}"         else             # Quote word, leaving out first character             printf -v $2 %q "${1:1}"             # Double-quote word (bash-3)             printf -v $2 %q ${!2}         fi     elif [[ ${BASH_VERSINFO[0]} -le 3 &amp;&amp; ${1:0:1} == '"' ]]; then         printf -v $2 %q "${1:1}"     else         printf -v $2 %q "$1"     fi      # If result becomes quoted like this: $'string', re-evaluate in order to     # drop the additional quoting.  See also: http://www.mail-archive.com/     # bash-completion-devel@lists.alioth.debian.org/msg01942.html     [[ ${!2:0:1} == '$' ]] &amp;&amp; eval $2=${!2} } # _quote_readline_by_ref()  _filedir() {     local i IFS=$'\n' xspec      _tilde "$cur" || return 0      local -a toks     local quoted tmp      _quote_readline_by_ref "$cur" quoted     toks=( ${toks[@]-} $(         compgen -d -- "$quoted" | {             while read -r tmp; do                 printf '%s\n' $tmp             done         }     ))      if [[ "$1" != -d ]]; then         # Munge xspec to contain uppercase version too         [[ ${BASH_VERSINFO[0]} -ge 4 ]] &amp;&amp; \             xspec=${1:+"!*.@($1|${1^^})"} || \             xspec=${1:+"!*.@($1|$(printf %s $1 | tr '[:lower:]' '[:upper:]'))"}         toks=( ${toks[@]-} $( compgen -f -X "$xspec" -- $quoted) )     fi     [ ${#toks[@]} -ne 0 ] &amp;&amp; _compopt_o_filenames      COMPREPLY=( "${COMPREPLY[@]}" "${toks[@]}" ) } # _filedir()  # only the following is needed if bash-autocompletion is already installed _open () {     local cur;      cur=$2;      COMPREPLY=();     if [ $COMP_CWORD -eq 2 ]; then         COMPREPLY=($(compgen -W "$(/bin/ls /Applications)" -- $cur ));         return 0     fi      _filedir }  complete -F _open open /code/pre  <answer39783> Add the following to your code.bash_profile/code or code.bashrc/code and launch a new session:  precodefunction _complete_open {     cur=$2     COMPREPLY=( );      [[ "$COMP_WORDS" = "open" ]] || return     [[ "${COMP_WORDS[ $(( $COMP_CWORD - 1 )) ]}" = "-a" ]] || return      OLDIFS="$IFS"     IFS=$'\n'     local _part="${COMP_WORDS[$COMP_CWORD]}"      if [[ "${_part:0:1}" = '"' || "${_part:0:1}" = "'" ]] ; then         COMPREPLY=( $( compgen -W "$( mdfind kMDItemKind==Application | sed -e 's|.*/||g' -e 's|.app$||' | sort -u )" -- $cur ) )     else         COMPREPLY=( $( compgen -W "$( mdfind kMDItemKind==Application | sed -e 's|.*/||g' -e 's|.app$||' -e 's| |\\\\ |g' | sort -u )" -- $cur ) )     fi     IFS="$OLDIFS" }  complete -o default -F _complete_open open /code/pre  No need to install anything. This works with codebash/code out of the box.  hr  It will only autocomplete program names if the previous option is code-a/code and otherwise show default behavior, e.g. return a list of all files in the current directory or complete the current path prefix.  The results are generated from codesystem_profiler SPApplicationsDataType/code, which is the easiest way to get emall applications/em that can be launched this way on your system like that. The list is processed to only return the program names, emwhich can contain spaces and can be different from the bundle names (even when ignoring code.app/code suffix)/em  Usage: Type codeopen -a/code, followed by a space, followed by pressing codeTab/code or codeEsc/code (twice on my system, not sure if it's everywhere).  Example showing all the helper applications for my scanner:  precode$ open -a Scan Scan to E-mail          Scan to Excel           Scan to Folder          Scan to Print           Scan to Searchable PDF  Scan to Word            ScanSnap Manager /code/pre  hr  Drawbacks and problems of this solution:  ul liThere are tons of programs on your system you might not be aware of, like everything in code/System/Library/CoreServices/code. You might not want to list all of them. OTOH, it's really easy to see and launch e.g. codeCharacterPalette/code or codeKeyboardViewer/code this way. *Configure the codemdfind/code call(s) appropriately with the code-onlyin/code argument./li listrikeIt's kind of slow, due to codesystem_profiler SPApplicationsDataType/code. You might need to wait a second or two before completion shows up./strike Now uses codemdfind/code to quickly get the programs. strongThanks @Lri/strong/li liIt can handle spaces in application names, and quotation enclosed program names, but it's rather hacky. It requires the quote to be the first character: While codeScan" to "P/code is valid in codebash/code, this program will not detect it. Completion does not work after an escaped space either (e.g. codeScan\ to/code), use quotation marks in such cases (code"Scan to/code). Support for escaped spaces is only good to complete codeDVD/code to codeDVD\ Player/code./li /ul  <answer39796> precode_complete_open() {         COMPREPLY=()         local cur="${COMP_WORDS[$COMP_CWORD]}"         local prev="${COMP_WORDS[COMP_CWORD-1]}"         [[ "$cur" == -* || "$prev" != '-a' ]] &amp;&amp; return         apps="$(mdfind kMDItemKind==Application -onlyin /Applications -onlyin ~/Applications -onlyin /Developer -onlyin ~/Developer | grep -v '/.*/.*/.*/.*/' | sed -E 's|.*/||g;s|\.app$||g' | uniq)"$'Finder\nArchive Utility\nCharacterPalette\nKeyboardViewer'         local IFS=$'\n'         if [[ "${cur:0:1}" = '"' || "${cur:0:1}" = "'" ]]; then             quote="${cur:0:1}"             cur="${cur:1}"         fi         local found="$(grep -i "^$cur" &lt;&lt;&lt; "$apps")"         if [[ "$quote" == '"' ]]; then             found="$(sed "s|^|\"|g;s|$|\"|g" &lt;&lt;&lt; "$found")"         elif [[ "$quote" == "'" ]]; then             found="$(sed "s|^|'|g;s|$|'|g" &lt;&lt;&lt; "$found")"         else             found="$(sed 's| |\\ |g' &lt;&lt;&lt; "$found")"         fi         COMPREPLY=($found) }  complete -o default -F _complete_open open /code/pre  Third version, which should now both be case insensitive and work within quotes.  <comment44375> What shell are you using? <comment44377> I guess a marginally quicker way would be to type out the full path (just go with me for a while here!!), e.g. `open -a /Applications/Textedit.app foo.txt` (I assume thats what you're trying to do). If you press Tab after the `/A` of `/Applications` and then Tab again after the `/Te` of `/Textedit.app` then that should autocomplete both parts for you as you go. Not ideal, I admit, but maybe a but better. This was using Bash. <comment44424> You could also try following through the instructions at the end of this post: [brettterpstra.com/grabbing-a-mac-apps-icon-advanced-bash-usage-2](http://brettterpstra.com/grabbing-a-mac-apps-icon-advanced-bash-usage-2/) <comment44939> So I followed the install instructions and added the code to `.bashrc`. Now how do I get it to autocomplete? What do I push to autocomplete? (Sorry, I can't read the code) <comment44940> @DanielBeck Bash. <comment44957> Does not handle program names with spaces (like `DVD Player.app`). Lists directories in `/Applications` as well (like `iWork 09`, as separate entries `iWork` and `09`), but not the programs contained therein. <comment44960> Wouldn't `mdfind 'kMDItemKind==Application'` be faster? If `completion-ignore-case` is set on, grep should probably ignore case as well. <comment44980> @Lri You're right. Couldn't find a case where these results would have made a difference. <comment44981> I couldn't get this to work with `DVD Player`. Any ideas what's wrong? Looks like a Tab instead of a space... <comment44999> @DanielBeck It was missing `IFS=$'\n'`. Anyway, I edited the answer again. <comment45004> Looks good. A late +1 for the `mdfind` idea. Nice work on the optimization and fixes. `CoreServices` are probably personal preference though. What's the reason for `nospace` though? If there's only 1 program, I want to continue right away with the filen to open. Just personal preference? Any idea about the remaining quoting issue? AFAICT, that's the only thing left for a proper solution. <comment45014> @DanielBeck I always put the `-a` flag at the end, so I guess `-o nospace` is just a personal preference. Maybe we should ping Brett Terpstra or something to finish this nerdfest... <comment45436> Thank you so much!! @DanielBeck you too. I chose Lri's version because of the speed. Unfortunately, yours was a bit slow. Thanks so much both of you! You've helped me a lot and made my Terminal speed increase. <comment164387> Very handy trick! +1
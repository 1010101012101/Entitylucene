Compare multi-digit version numbers in bash <body> Trying to write a script that searches for the version of the Application then returns the value. My problem is the value is three to four intergers long (example 4.3.2).  I have searched for a while and can't find any syntax that would allow you to use a != or -ge for anything higher than a number with periods in it.  Just wondering if anyone has a better way or I will just keep adding for every version release.  h3What I want/h3  precodeelse if [ $version1 -ge "9.0.8" ]; then /code/pre  h3How it is written now/h3  precodevercheck=`mdls -name kMDItemVersion /Applications/iMovie.app` version=`echo ${vercheck:17}` version1=`echo ${version:1:5}`  [...]  else if [ $version1 = "9.0.8" ]; [ $version1 = "9.1.1" ]; then     echo "You already have this version or a higher version installed"     exit 0 /code/pre  <answer86362> Actually, comparing version numbers is pretty straightforward (at least as long as they are strictly numeric) as they are hierarchically structured left to right. A sequential comparison in that same order will yield a clear result.  The following embash/em function will return 0 (true) if two version numbers are strongnot equal/strong, 1 (false) if they are, as long as the variables code$version_1/code and code$version_2/code both contain only an arbitrary number of digit groups separated by periods:  precodefunction versions_not_equal {     while [[ $version_1 != "0" || $version_2 != "0" ]]; do         (( ${version_1%%.*} != ${version_2%%.*} )) &amp;&amp; return 0         [[ ${version_1} =~ "." ]] &amp;&amp; version_1="${version_1#*.}" || version_1=0         [[ ${version_2} =~ "." ]] &amp;&amp; version_2="${version_2#*.}" || version_2=0     done     false } /code/pre  Implementing other comparisons, like stronggreater or equal/strong, is as simple as changing the comparison operator of the arithmetic evaluation (i.e. code(( ${version_1%%.*} &gt;= "${version_2%%.*}" ))/code).  <answer123399> I can give you a long example of "if the checked version is between min  and max"  and you can optimize it for your needs changing head -1/tail -1 and cutting 1 variable:  precodemin_ver="a-1.1.1" max_ver="a-9.1.1" check_ver="a-2.2.9" if [ "$( echo -e "${min_ver}\\n${max_ver}\\n${check_ver}" | sort --sort=version | head -2 | tail -1)" == ${check_ver} ] then   echo YES - apply  ${check_ver} fi /code/pre  <answer123408> I believe I adapted this slightly from http://bashscripts.org/forum/viewtopic.php?f=16&amp;t=1248. I like it because it's fairly compact and readable.   This is optional, but desirable IMO:  precodeif [ "$#" != "2" ] then     echo "$0 requires exactly two arguments."     exit 2 fi /code/pre  Here's the meat:  I always use code$1/code for "the locally installed version" and code$2/code for "the version I am comparing against" so if this leaves me with code$? = 1/code I need to update, otherwise I'm up-to-date (or even ahead):  precodefunction version { echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'; }  if [ $(version $1) -gt $(version $2) ]; then     echo "$1 is newer than $2"     exit 0 elif [ $(version $1) -lt $(version $2) ]; then     echo "$1 is older than $2"     exit 1 else     echo "$1 is identical to $2"     exit 0 fi /code/pre  If all you cared about was whether code$1/code was up to date (that is, equal to or greater than code$2/code) you could make it even simpler:  precodeif [ $(version $1) -ge $(version $2) ]; then     echo "No Newer Version Available"     exit 0 fi /code/pre  Any code below that will only be executed if there is a newer version available. Otherwise the script will exit cleanly at that point.  p.s.: I do this in /bin/zsh not /bin/bash but I don't emthink/em it makes a difference in this case.  <answer261863> Here's another solution that:  ul lidoes not run any external command apart from codetr/code/li lihas no restriction on number of parts in version string/li lican compare version strings with different number of parts/li /ul  Note that it's Bash code using array variables.  precodecompare_versions() {     local v1=( $(echo "$1" | tr '.' ' ') )     local v2=( $(echo "$2" | tr '.' ' ') )     local len="$(max "${#v1[*]}" "${#v2[*]}")"     for ((i=0; i&lt;len; i++))     do         [ "${v1[i]:-0}" -gt "${v2[i]:-0}" ] &amp;&amp; return 1         [ "${v1[i]:-0}" -lt "${v2[i]:-0}" ] &amp;&amp; return 2     done     return 0 } /code/pre  The function returns:  ul li0 if versions are equal (btw: 1.2 == 1.2.0)/li li1 if the 1st version is bigger / newer/li li2 if the 2nd version is bigger / newer/li /ul  However #1 -- it requires one additional function (but function codemin/code is quite usable to have anyway):  precodemin() {     local m="$1"     for n in "$@"     do         [ "$n" -lt "$m" ] &amp;&amp; m="$n"     done     echo "$m" } /code/pre  However #2 -- it cannot compare version strings with alpha-numeric parts (though that would not be difficult to add, actually).  <comment96580> See http://stackoverflow.com/questions/4023830/bash-how-compare-two-strings-in-version-format <comment96587> Perfect thanks for the link <comment144084> The solution Matteo linked to seems way more complicated than it needs to be, unless I'm misunderstanding something. I've posted a shorter solution below. <comment144087> BTW `mdls -raw -name kMDItemVersion /Applications/iMovie.app` will give you just the version number without the superfluous stuff.
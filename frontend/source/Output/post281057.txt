Bug in BSD: to whom shall I report it? <body> I found what I think is a bug in the command codechown/code in OS X 11.6. It appears to work contrary to its man page, ignoring the code-f/code flag.  precodeT_MaceT 33 ) chown -f T_MaceT foo chown: foo: No such file or directory T_MaceT 34 ) echo $? 1 /code/pre  According to the man page, using code-f/code, it should ignore that the file doesn't exist nor should it change the return-value. (I have tested the correct behavior on RedHat 6 for comparison.)  I'm not sure who (if anyone) would fix these kinds of bugs. The man page refers to BSD. Is there an active project supporting these kinds of things?  <answer281079> It's not a bug, it's poorly written documentation. The code-f/code emoption/em for codechown/code states:     Don't report any failure to change file owner or group, nor modify the exit status to reflect such failures.   This means the code-f/code emoption/em is only applicable if the target emfile/em exists and there was an error in changing the emowner/em or emgroup/em of the emfile/em, which of course you can't do on a nonexistent emfile/em as in the OP example under macOS.  To show that the code-f/code emoption/em actually works as intended, use the following emcompound command/em in Terminal while not doing so as coderoot/code or using codesudo/code:  precodetouch ${TMPDIR}testfile; chown root ${TMPDIR}testfile; echo $?; rm ${TMPDIR}testfile /code/pre  The output will be, e.g.:  precodechown: /var/folders/7l/lcvbc47n3sd7jcztdhc9c_pw0000gn/T/testfile: Operation not permitted 1 /code/pre  In this first form, without the code-f/code emoption/em it fails, exits 0, because the codechown/code emcommand/em is trying to set the emowner/em of code${TMPDIR}testfile/code to coderoot/code while being executed not as coderoot/code and not using codesudo/code.  Now execute with the code-f/code emoption/em:  precodetouch ${TMPDIR}testfile; chown -f root ${TMPDIR}testfile; echo $?; rm ${TMPDIR}testfile /code/pre  The output will be:  precode0 /code/pre  In this second form, with the code-f/code emoption/em, it succeeds, exits with 0 without having made any change, because it was done not as coderoot/code and not using codesudo/code, which is necessary to change the emowner/em of a emfile/em to coderoot/code.  hr  Note that each OSes codechown/code is not equal in all functionality to each other. In other words, while I don't have Red Hat, as mentioned in the OP, I do have Linux Mint to compare to, and the man page in Linux Mint code-f/code emoption/em for codechown/code states:     suppress most error messages   As you see strongmost/strong is the keyword, so it doesn't suppress strongall/strong error messages in Linux Mint nor is the description of what code-f/code does with codechown/code under Linux Mint as detailed and explicit as under macOS.  So while in Linux Mint, not as coderoot/code or using codesudo/code, codechown -f root non_existant_filename/code will not output an error, however, its exit code is code1/code, not code0/code as it is with the macOS codechown/code example above using code-f/code within its defined context.  <comment353659> @macetw, You said, "_According to the man page, using `-f`, it should ignore that the file doesn't exist nor should it change the return-value._" and that is not at all what the man page for `chown` under macOS states! <comment353678> The f option is an extension of the POSIX Standard and should not be considered portable. <comment353729> Perceptions are different. As a long-time Linux user, I expect that "-f" is the standard way to "force the action to be done and don't complain to me about it." This behavior is true (in Linux) about "rm," "mv," "cp," and so on. Specifically with "rm," I do this all the time, that the file might not exist. My question from the title is still open: If I want to improve the command-shell experience in Mac, where do I document my bug/suggestion ? <comment353733> Perceptions are different. As a long-time Linux user, I expect that "-f" is the standard way to "force the action to be done and don't complain to me about it." This behavior is true (in Linux) about "rm," "mv," "cp," and so on. Specifically with "rm," I do this all the time, that the file might not exist. My question from the title is still open: If I want to improve the command-shell experience in Mac, where do I document my bug/suggestion ? <comment353747> @macetw This answer convincingly argues that it is not a bug. Your counterargument seems to concede that it is not a bug, so perhaps you should change the word "bug" in the question to something like "design flaw"â€”in which case you are looking for a place to discuss the [design rationale](https://en.wikipedia.org/wiki/Design_rationale) of various features? For info on bug reporting, see, e.g., https://developer.apple.com/bug-reporting/ and https://www.freebsd.org/support/bugreports.html <comment353749> @macetw, I too am a long-time Linux user however the fact that we're long-time Linux users is totally irrelevant because **macOS is not Linux** and as already stated the `-f` option is not equal between OS platforms and or versions of `chown`. I believe my test confirms it works as intended under macOS. That said, there are others ways to code to avoid unwanted output. I'll assume your scripting something in which you want only clean output displayed, as the `-f` option is not really needed with a single one time command issued on the command line. Continued in next comment. <comment353750> @macetw, So, in a script, e.g. `chown root nonexistant_filename 2/dev/null` will hide the `chown: nonexistant_filename: No such file or directory` error output. Also in scripts there are easy ways to confirm the file exists before attempting to act upon it (and probably should be done so in many cases). That said, if you really want to pursue this as a bug and or design flaw then the comment made above by Big Mac containts some links to facilitate that. <comment353756> @macetw Have a look at https://opensource.apple.com/source/file_cmds/file_cmds-264.50.1/chown/chown.c.auto.html: The `fts` functions are used to traverse the file hierarchy, failure to `stat` a file will result in a warning being displayed (search for `FTS_ERR`). So the behavior is definitively intentional. One might argue that it is not consistent with `cp`, `mv` etc, but then a lot of Unix binaries ain't (`awk` for instance uses `-f` to pass a script file). <comment356299> Your question is answered in the comments on the answer below. Recently I thought of your complaint when I experienced a similar design "issue" (not to say "bug"): I was switching between applications, and a [keyboard shortcut](https://en.wikipedia.org/wiki/Keyboard_shortcut) corresponded to different commands in each app. This was frustrating at first, but the easiest solution was to learn the relevant keyboard shortcuts in each app. If identical behavior is not specified in a common standard such as [POSIX](https://en.wikipedia.org/wiki/POSIX), it can't be expected, as @fd0 said.
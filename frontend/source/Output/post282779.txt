egrep: empty (sub)expression : Unexpected behaviour for bash Loop on Mac <body> I have the filling simplified script on Mac OS X 10.12 :  precode#!/usr/bin/env bash  echo "=&gt; BASH_VERSION = $BASH_VERSION" function testForLoopMac { local file for file do     echo File=$file done | egrep "$file" }  function testForLoopMacBis { local file for file do     echo File=$file done | egrep "$file|OK" }  testForLoopMac $@  testForLoopMacBis $@ /code/pre  But the result when I run is :  precode$ testForLoopMac.sh example.pdf  =&gt; BASH_VERSION = 3.2.57(1)-release File=example.pdf egrep: empty (sub)expression /code/pre  On Debian/Ubuntu Linux, the result is :  precode$ testForLoopMac.sh example.md  =&gt; BASH_VERSION = 4.3.30(1)-release File=example.md File=example.md /code/pre  Edit : With bash4 on Mac OSX 10.12 :  I changed the shebang to code#!/usr/bin/env bash4/code and the result is the same :  precode$ testForLoopMac.sh example.md  =&gt; BASH_VERSION = 4.4.12(1)-release File=example.md egrep: empty (sub)expression /code/pre  Edit: Thanks to you guys I understand the behavior difference on Linux or BSD codeegrep/code is because that at the time of the codeegrep/code execution the variable can be empty.  I'm going the use therefore, the following regExp :  codeegrep "File=|OK"/code  Thanks again :)  <answer282900> The shell expands the subexpression code$file/code on the right hand side of the pipe before the variable has any value. So in both functions codeegrep/code is actually called with the empty string in place of code$file/code. The first function doesn't throw an error because an empty pattern is a valid parameter for codeegrep/code both on macOS and on Linux. In the second fucntion the difference comes into play because the empty subexpression causes codeBSD egrep/code (the one used on macOS) to throw an error.  Example:  precodeecho foo | egrep "|foo" egrep: empty (sub)expression /code/pre  as another example with code$file/code having no value  precodeecho foo | egrep "$file|foo" egrep: empty (sub)expression /code/pre  So, as a workaround in your function use:  precodeegrep -e "$file" -e 'OK' /code/pre  I have no idea why you are using codeegrep/code when you are looking for fixed strings.  <comment356369> Can you add the `BASH_VERSION` both from macOS and from Linux? <comment356372> I think the script is too simplified to show your real intent. Are the arguments to the script supposed to be regular expressions? <comment356519> @patrix I update the Question with the bash version information because comments only use mini-Markdown formatting which is a pain in the @~~ <comment356522> For what it's worth editing the question to include such information is the preferred thing to do rather than adding it in the comments since comments are ephemeral. <comment356540> @0942v8653 the script is ideal to show how execution on macOS and Linux differ. Which is all the question is about :-) <comment356570> The expansion is done by `bash` not by `egrep`, so I struggle a bit to understand your first sentence. <comment356573> @patrix Yep, you're right. Will edit. <comment356577> Thanks. I still wonder why it works on Linux though <comment356582> @patrix  It's the difference between `BSD grep` and `GNU grep`. `GNU grep` doesn't complain about empty subexpressions for one thing. <comment356643> @patrix Maybe, on linux, the variable is not distroyed when the loop is finished. <comment356645> @SebMa The variable isn't "destroyed" on either system (replace `| egrep` by `; echo` to check). The way pipes work the second command (`egrep`) needs to be started *before* the loop terminates. So both functions don't work as you may think they to, in the first function `egrep` is executed with an empty pattern (because `file` is empty at the moment of execution), in the second the difference between BSD and GNU grep (as explained above) comes into play. <comment356648> @fd0. I'm using `egrep` to filter the output of `ffprobe` to simplify it a little. <comment356649> @patrix Thanks for your explanation.  I'm going the use therefore, the following regExp : `egrep "File=|OK"` <comment356650> @SebMa Just avoid using any variables in the right hand side of a pipe which get set/changed in the left hand side
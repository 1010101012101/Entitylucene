Can the contents of a partition be recovered after partition table is overwritten? <body> I ran a command to make my external hdd bootable knowing that it was risky considering the command itself did not allow me to specify a partition to which to write. (In hindsight, I would now call this a stupid decision - but at the time, I tried this command:)  precode$ sudo dd if=/Users/MyUser/Downloads/Fedora-17-x86_64-Live-Desktop.iso \ &gt; of=/dev/disk1 bs=1m /code/pre  For which the output I received was:  precode645+0 records in 645+0 records out 676331520 bytes transferred in 98.578444 secs (6860846 bytes/sec) /code/pre  I knew right away that it was fishy since code/dev/disk1/code was split into three partitions, all of which were codehfs/code.  Since it's next to impossible to find emgood/em information on making a bootable empartition/em from an external USB device, I tried this in spite of the risks.  I did no further writing to my external HDD after this point, since now the only partition I see when I mount the drive is 'Fedora 17.'    h3What is the likelihood of recovering the files I had stored in my Backup partition?  And how ishould/i I have done this in the first place?/h3  hr  strongNOTE/strong: This is how my partitions were embefore/em I tried codedd/code.  precode$ diskutil list /dev/disk0 #:                       TYPE NAME                    SIZE       IDENTIFIER 0:      GUID_partition_scheme                        *160.0 GB   disk0 1:                        EFI                         209.7 MB   disk0s1 2:                  Apple_HFS Macintosh HD            159.7 GB   disk0s2 /dev/disk1 #:                       TYPE NAME                    SIZE       IDENTIFIER 0:      GUID_partition_scheme                        *1.0 TB     disk1 1:                        EFI                         209.7 MB   disk1s1 2:                  Apple_HFS Linux                   50.0 GB    disk1s2 3:                  Apple_HFS Backup                  500.0 GB   disk1s3 4:                  Apple_HFS Misc                    449.6 GB   disk1s4 /code/pre  <answer71617> Having done this myself:  precode# dd if=freebsd.img of=/dev/hda /code/pre  at some point in the past (oops! I meant codefd0/code!) I can pretty much guarantee that the contents of codedisk1s1/code and codedisk1s2/code are trashed.  But codedisk1s3/code and codedisk1s4/code will be just fine! You just need to figure out what the partition table is supposed to be and correct it.  I suggest recovering from the GPT backup at the end of the disk or just searching for the filesystem markers to determine where they are supposed to be.  <answer71618> According to your output, you copied 645MB to disk, which means the EFI and first ~440MB of the Linux partition were overwritten. Your Backup and Misc partitions were not modified, so the data in them can be recovered... if you can find them.  This may be relatively easysup1/sup. GUID partition tables are stored at both the beginning and end of the drive, so as long as OS X didn't overwrite the ones at the end, you can use them to find your data.  sup1/sup Relative to searching for HFS headers manually, the following commands are quite easy. However, this process is delicate, and if you accidentally write back the wrong data it could make things worse.  hr  First, you need to determine the number of sectors on your drive. In Terminal, run codediskutil info disk1/code (or whatever your disk is currently connected as), and look for the Total Size section. It should list the exact number of sectors, and below that the sector size. I will call these values N and S, respectively.  Then, run these commands, replacing disk1, N and S as appropriate. This will copy the last block off of your drive to a file named codepartition_header.hex/code. Then it prints some data from that file.  precodesudo dd if=/dev/disk1 of=partition_header.hex bs=S skip=$((N-1)) count=1 od -cN 8 partition_header.hex od -tx4 -N 8 -j 72 partition_header.hex -d -tu4 -N 4 -j 84 partition_header.hex /code/pre  The output for the three codeod/code commands should look similar to this:  precode0000000    E   F   I       P   A   R   T       0000110          xxxxxxxx        yyyyyyyy         0000124              ssss                /code/pre  If the output from the first command does not match that first line, your partition tables have been overwritten. See my suggestions at the end. The values codexxxxxxxx/code and codeyyyyyyyy/code are two hexadecimal numbers. They should be numbers and letters between a and f, and they tell you where the actual partition data is stored. The value codessss/code is a number which tells you the size of a partition entry. Run this command to get the partition data, replacing disk1, S, codexxxxxxxx/code, codeyyyyyyyy/code, and codessss/code (note that the x after the 0 is literal). If codessss/code is more than 1/4 S, you may need to increase the count parameter, but this is unlikely.  precodesudo dd if=/dev/disk1 of=partition_entry.hex bs=S skip=$((0xyyyyyyyyxxxxxxxx)) count=1 od -tc -N 8 -j $((56+2*ssss)) partition_entry.hex od -tc -N 8 -j $((56+3*ssss)) partition_entry.hex /code/pre  The last two commands print the beginning of the names of the third and fourth partitions, with each letter followed by code\0/code (due to the encoding on disk). If your partition table is still valid, these should be "Back" and "Misc". If so, it is time to get the entire partition table and make the necessary modifications to store it at the other end of the drive. Run these two commands to get the proper header LBAs and total number of partition entries:  precodeod -tx1 -N 16 -j 24 partition_header.hex od -td4 -N 4 -j 80 partition_header.hex /code/pre  The first command returns codeaa bb cc dd ee ff gg hh ii jj kk ll mm oo pp qq/code. Most likely, codeii/code is code01/code and codejj/code through codeqq/code are code00/code. The second command returns codennnn/code, most likely 128. Now we can read the entire partition table, instead of just the first few. Run this command, making the proper substitutions:  precodesudo dd if=/dev/disk1 of=partition_entry.hex bs=ssss skip=$((0xyyyyyyyyxxxxxxxx * S / ssss)) count=nnnn /code/pre  Now we need to make some changes to the header since the data will be stored at a different location.  precodeprintf '\xii\xjj\xkk\xll\xmm\xoo\xpp\xqq\xaa\xbb\xcc\xdd\xee\xff\xgg\xhh' | dd of=partition_header.hex bs=8 seek=3 count=2 conv=notrunc printf '\x02\x00\x00\x00\x00\x00\x00\x00' | dd of=partition_header.hex bs=8 seek=9 count=1 conv=notrunc /code/pre  The first command swaps the current header and other header addresses. Sorry about replacing each byte separately, but I didn't know of an easier way. The second command writes the new address of the entry data. The value 2 I used is assuming that codeii/code was 1 and codejj/code through codeqq/code were 0. If they have other values, just increase the whole thing by one and use that instead. The only thing we need now is the right MBR, which is not on your disk since it isn't part of the partition table. Luckily, you can use the one from your internal drive, so you need to copy that into a file.  precodesudo dd if=/dev/disk0 of=drive_mbr.hex bs=512 count=1 /code/pre  Now that we have all of the data, we can write it out. First, unmount the Fedora volume if it is mounted.  precodediskutil unmountDisk disk1 /code/pre  Then, copy each piece to the beginning of the drive. Be sure to make the proper substitutions in these commands, writing to the wrong disk would not be good.  precodesudo dd if=partition_entry.hex of=/dev/disk1 bs=S seek=2 count=nnnn sudo dd if=partition_header.hex of=/dev/disk1 bs=S seek=1 count=1 sudo dd if=drive_mbr.hex of=/dev/disk1 bs=512 count=1 /code/pre  The seek values are based on the assumption that codeii/code through codeqq/code matched the likely values. If they do not, use code$((0xqqppoommllkkjjii))/code for the second command and code$((0xqqppoommllkkjjii+1))/code for the first.  After you perform these commands, OS X will probably reload the drive automatically and load the partitions. If it doesn't, just disconnect and reconnect it. The Linux partition will most likely fail to mount, since its header was overwritten, but the other two will hopefully work fine. Even so, I would still suggest copying your data off of the drive and reformatting it, or at the very least copying the EFI partition data from your internal drive over.  hr  h3If your partition table is corrupted:/h3  The option which is most likely to be successful is to manually search for the HFS headers at the beginning of your backup partition. The format of a HFS volume is described here. Basically, you will need to calculate the approximate offset of the partition into the drive using the partition map you have, then search each sector in the area looking for the volume header. You could probably write a script to search for you.  Another option would be to use file recovery software. I don't know what software is available which would handle this situation, so there's not a lot I can say about it.  <answer71622> Quick and Simple: Since it's a GPT disk you can run codegpart recover /dev/disk1/code to fix the table. You blew away the first ~700MB of the drive, so any partitions touching that area are gone too (more or less). The rest of the disk should be fine. I'm not sure if OSX comes with gpart, so you may need to download it somewhere.  The longer details: Concerning the partition(s) that were only partially overwritten, some of the files may be recoverable. The tools to do so are much more complicated and you'll be wanting to find someone who strongreally/strong knows what they're doing for this. If you're concerned with any of these files don't even try anything except unplugging the drive. Also, the overwritten data can emprobably/em be recovered by a data recovery service, but this would cost tens of thousands of dollars.  Also, if this was a MBR disk you'd be completely hosed unless you happen to know the exact size and offsets of all partitions. This information can be printed from fdisk, but it's best to simply not make mistakes like this.  <comment83182> Thanks so much for answering.  I will let you know tomorrow what I figure out as soon as I get my disk back.  Now I'm gonna read that book of an answer below. <comment83183> Holy moly this is a lot of information. +1 based on the first part I read so far though.  Thanks!  I'll follow up with questions if I have any. <comment83734> Jebus!  What an answer.  How did you learn all this, and are there resources you can point the community to, for anyone who's interested in learning more, or even just to fully understand this answer? <comment83755> @Harv All I knew before writing this was that there was a backup table which could be used, and how to copy things directly to/from a drive. I used the [wikipedia page](http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_table_header_.28LBA_1.29) as a reference for the table formats and just put the pieces together, using my drive's data as a test. If you want to know more about a specific command, run `man command` in Terminal.
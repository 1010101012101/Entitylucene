AppleScript: How to open text file and move cursor to specific location (signaled by specific character)? <body> I have a .txt file saved on my computer. I want my Automator application to open the .txt file and then move the location of the cursor to the first blank line in the file.  For example, I have a .txt file entitled emMy Fruit Log.txt/em saved on my computer. This is what the contents of the .txt file may look like:  img src="https://i.stack.imgur.com/7rATX.png" width="446"  So, in the above instance, I want the file to be opened, and then the cursor moved to the second line of the file.  Note: It is not necessarily the second line from the top where I want the cursor to be sent to. Depending on what text has already been written to the file, I might want the cursor on a lower line. For example:  img src="https://i.stack.imgur.com/CVTIt.png" width="446"  In the above case, I would want the cursor to be moved to the sixth line.  The location where I want the cursor will always be at least the second line from the top, but it could be as far down as the seventh line from the top.   So, the most reliable way to articulate where I want the cursor to be placed is "on the first instance of a blank line in the file."  I already have the code to open the file in TextEdit (borrowed from the top answer of this Stack Overflow question):  precodeset Target_Filepath to POSIX file "/Users/Me/Desktop/My Fruit Log.txt"  tell application "Finder" to open Target_Filepath /code/pre  Now I need the code to move the cursor. The default location of the cursor is the first line of the file.   <answer262198> Here is an AppleScript for TextWrangler to jump to the end of the first  paragraph of a text file:  precodetry     tell application "TextWrangler"         find "(?=\\r^\\r|\\A)" searching in text of front text window options {search mode:grep, wrap around:false, backwards:false, case sensitive:false} with selecting match     end tell end try /code/pre  By adding a second expression directly after code(?=\\r^\\r|\\A)/code but within the quotes one should be able to jump to the next line. Since I don't know what code(?=\\r^\\r|\\A)/code really means I can't help you further.  <answer262199> I don't know if there's an easy or pretty way to do what you're asking. In other words, you can't just simply say something like codeopen target file and move cursor to first empty line/code, however the emcode/em below will do that.  precodeset filePathName to POSIX path of (path to desktop as string) &amp; "My Fruit Log.txt" set firstEmptyLineNumber to (do shell script "awk '$1 == \"\" {print NR;exit;}' \"" &amp; filePathName &amp; "\"") do shell script "open -e " &amp; quoted form of filePathName tell application "TextEdit" to activate tell application "System Events" to tell process "TextEdit"     repeat (firstEmptyLineNumber - 1) times         key code 125 # Down Arrow     end repeat end tell /code/pre  The emcode/em above is coded to open the text file in TextEdit, which is what codeopen -e/code in the secondbr codedo shell script/code emcommand/em is doing and it's coded this way because System Events needs to know where to sent the emdown arrow/em keystrokes to. If you want a different text editor then removebr the code-e/code and the codeopen/code emcommand/em will open it in whatever app the em.txt/em file extension is registered to open with. Then you'll also need to change:  precodetell application "System Events" to tell process "TextEdit" /code/pre  To:  precodetell application "System Events" to tell front process /code/pre  And replace:   precodetell application "TextEdit" to activate /code/pre  With: codedelay 1/code  In the first codedo shell script/code emcommand/em, codeawk/code is getting the emline number/em of the first empty line and exiting and this is what's used to calculate how many emdown arrow/em keystrokes to coderepeat/code.  hr  I modified my original answer slightly to get rid of the codedelay/code emcommmand/em but wanted to add my take on adc's answer while eliminating all the codemenu_click/code stuff.  precodeset filePathName to POSIX path of (path to desktop as string) &amp; "My Fruit Log.txt" set firstEmptyLineNumber to (do shell script "awk '$1 == \"\" {print NR;exit;}' \"" &amp; filePathName &amp; "\"") if firstEmptyLineNumber = "" then set firstEmptyLineNumber to 1 as string do shell script "open -e " &amp; quoted form of filePathName tell application "TextEdit" to activate tell application "System Events" to tell process "TextEdit"     key code 37 using command down # ⌘L     keystroke firstEmptyLineNumber     keystroke return     key code 123 # Left Arrow - So the line is not highlighted. end tell /code/pre  hr  strongUpdate:/strong  The emcode/em below has been modified from the emcode/em above at the top of my answer, not my take on arc's answer although it's applicable there too, to address the issue you're having with TextEdit writing two carriage returns instead of the expected and normal two line feeds for an empty line after a line containing content or two empty lines in a row.  precodeset filePathName to POSIX path of (path to desktop as string) &amp; "My Fruit Log.txt" set firstEmptyLineNumber to (do shell script "awk '$1 == \"\" {print NR;exit;}' \"" &amp; filePathName &amp; "\"") if firstEmptyLineNumber is equal to "" then       set firstEmptyLineNumber to (do shell script "awk '/\r\r/{print NR+1;exit;}' \"" &amp; filePathName &amp; "\"") end if do shell script "open -e " &amp; quoted form of filePathName tell application "TextEdit" to activate tell application "System Events" to tell process "TextEdit"     repeat (firstEmptyLineNumber - 1) times         key code 125 # Down Arrow     end repeat end tell /code/pre  strongNote:/strong Although the modified emcode/em works with your emtestfile.txt/em file from the link in your comment, nonetheless I personally do not subscribe to this workaround and would instead find out the root cause of the issue and fix it and your files!  <answer262203> I would probably approach this using something like Ruby and TextMate— a Ruby script could determine which line to choose (probably by a simple regular expression) and even add the date for the next day if appropriate. TextMate can be invoked on the command line to move the cursor to a specific line by codemate -l 7/code for example.  That said, using only AppleScript in TextEdit and codeawk/code from user3439894's answer a somewhat more robust way of navigating to a specific line uses System Events and TextEdit's "Select Line" (Command + L) menu item.  emI also used a function from MacOSXHints because menu scripting in AppleScript is a huge pain. Disposing of the menu_click function is an exercise for the reader./em  precodeset filePathName to POSIX path of (path to desktop as string) &amp; "My Fruit Log.txt" set firstEmptyLineNumber to (do shell script "awk '$1 == \"\" {print NR;exit;}' \"" &amp; filePathName &amp; "\"") if firstEmptyLineNumber = "" then set firstEmptyLineNumber to 1  do shell script "open -e " &amp; quoted form of filePathName  menu_click({"TextEdit", "Edit", "Find", "Select Line..."})   tell application "System Events"     keystroke firstEmptyLineNumber     keystroke return end tell     -- `menu_click`, by Jacob Rus, September 2006 --  -- Accepts a list of form: `{"Finder", "View", "Arrange By", "Date"}` -- Execute the specified menu item.  In this case, assuming the Finder  -- is the active application, arranging the frontmost folder by date.  on menu_click(mList)     local appName, topMenu, r      -- Validate our input     if mList's length &lt; 3 then error "Menu list is not long enough"      -- Set these variables for clarity and brevity later on     set {appName, topMenu} to (items 1 through 2 of mList)     set r to (items 3 through (mList's length) of mList)      -- This overly-long line calls the menu_recurse function with     -- two arguments: r, and a reference to the top-level menu     tell application "System Events" to my menu_click_recurse(r, ((process appName)'s ¬         (menu bar 1)'s (menu bar item topMenu)'s (menu topMenu))) end menu_click  on menu_click_recurse(mList, parentObject)     local f, r      -- `f` = first item, `r` = rest of items     set f to item 1 of mList     if mList's length &gt; 1 then set r to (items 2 through (mList's length) of mList)      -- either actually click the menu item, or recurse again     tell application "System Events"         if mList's length is 1 then             click parentObject's menu item f         else             my menu_click_recurse(r, (parentObject's (menu item f)'s (menu f)))         end if     end tell end menu_click_recurse /code/pre  <comment328448> I think it can't be done with TextEdit because it misses a find function in the AppleScript Library. BBEdit and TextWrangler should work though because they both provide one. <comment328450> The issue I see is that TextWrangle remembers the cursor position in the document when last saved in TextWrangler and the cursor may not be at the top of the file like it will be with TextEdit when it's opened. So as coded it can fail in more then one way, it does on my system. In other words if I saved the file at the end of the first paragraph it go to the end of the second paragraph when I run the _code_. Or if I save at the end of the second paragraph it does noting whenI run the _code_ as at this point there are only three paragraphs in the file. <comment328453> Clever solution. But, for some reason, your code does not work for me. It opens the .txt file in TextEdit, but the cursor does not move. I tried changing `delay 1` to `delay 10` to be safe; still, it did not move the cursor. Then I inserted `display dialog firstEmptyLineNumber` after the second line of your code. When I ran the code, a completely empty dialog box appeared. [This is the .txt file](https://www.dropbox.com/s/490kaxysbw50dj1/testfile.txt?dl=1) that I am using to test your code. When you use this .txt file, does the code work properly on your computer? <comment328461> The "testfile.txt" file was created on my Mac. Here's how it was made (and I don't know of another way to create a .txt file on a Mac): I created a New Document in TextEdit, typed the text, clicked the Format menu and then clicked Plain Text, and saved the file as "testfile.txt" with the default encoding option of "Unicode (UTF-8)". [I see what you are seeing in the hex editor; there is a `0D0D` between the fourth and fifth lines of the file.](https://i.stack.imgur.com/xUljL.png) Is it possible to edit your code so that it can recognize both `0D0D` and `0A0D` as new blank lines? <comment328481> You could replace all that `menu_click` stuff (which is interesting BTW) with two lines of code. Place `tell application "TextEdit" to activate` just before the `tell application "System Events"` block, and add `key code 37 using command down` (which is ⌘L the shortcut key for "Select Line...") **or** `keystroke "l" using command down` above `keystroke firstEmptyLineNumber` in the `tell application "System Events"` block. I'd also add `key code 123` (right arrow) after `keystroke return` so the line is not highlighted. <comment328565> @rubik's sphere, Please delete all but your first comment under my answer up to this point as they are not really needed now that we know that the issue is TextEdit on your system is writing `0D` instead of `0A` as is the norm on a Mac. I have tried reproducing your issue in TextEdit under OS X 10.11.6 and macOS 10.12, doing as you say you do, and cannot reproduce it. All of my line endings are `0A` as they should be and thus the empty line shows as `0A0A` in the Hex Editor, two line feeds in a row as it is supposed to by default on a Mac, not two carriage returns. <comment328573> @rubik's sphere, I have updated my answer to handle your issue and tested it on your _testfile.txt_ file from the link in your comment and it works on it. FWIW <comment328633> Wow, the new code really works. Thanks very much user3439894. I will still heed your advice about diagnosing the root issue, but this will hold me over in the meantime. On a separate note, what made you decide to entirely remove the `delay` command from your code? I thought you had originally included the `delay` command to ensure that the down-arrow presses would not occur prematurely. (Not that I am having an issue with that; I am simply curious.) <comment328643> @rubik's sphere, I removed the `delay` _command_ because I added the `tell application "TextEdit" to activate` _command_ in its place and it provides a bit of a delay and forces focus to the app too. Yes the `open -e` _command_ sets focus to TextEdit too however in my testing this seemed to work better. Without it, using `delay` was necessary.
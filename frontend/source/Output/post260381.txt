How to prepend to text file in AppleScript? <body> I have a .txt file saved on my computer. I want Automator to add a bit of text to the emvery top/em of the .txt file. I do not want any text in the .txt file to be overwritten. I also want a new line to be created for the new text.  The following command adds the text to the .txt file, but at the end of the file:  precodeset TextToWrite to "This sentence should be the first line of the .txt file." set TargetFilepath to "/Users/Me/Desktop/Documents/My File.txt" do shell script "echo " &amp; quoted form of TextToWrite &amp; " &gt;&gt; " &amp; quoted form of TargetFilepath /code/pre  Can prepending to a .txt file be accomplished in AppleScript? Thank you.  hr  h2Update:/h2  I have discovered a pernicious little bug in all of the current 4 answers to this question.  Blank lines in a .txt file created on a Mac should show up as code0A0A/code in a hex editor. But, for whatever reason, the answers provided by Matteo, Christian Boyce, and user3439894 convert blank lines into code0D0D/code. In practice, code0D0D/code produces an identical result to code0A0A/code -- they both look like a blank line -- but Mac perceives code0D0D/codeas a carriage return while Mac perceives code0A0A/code as a line feed.  Here's the test that I did to discover this issue in the answers provided by Matteo and user3439894 (and if you do the same, you can reproduce the issue):  ol liCreate a New Document in TextEdit. Click "Make Plain Text" in the Format menu. Save the empty file as a .txt file./li liRun the AppleScript code provided by Matteo, Christian Boyce, or user3439894 using this .txt file as emTargetFilepath/em./li liOpen the .txt file in TextEdit and manually add a blank line to the file by using your kbdEnter/kbd key./li liOpen the .txt file in your hex editor and confirm that this new blank line is code0A0A/code./li liRun the AppleScript code again./li liOpen the .txt file in your hex editor. You will now notice that the code0A0A/code has been converted to code0D0D/code./li /ol  Here's the test that I did to discover this issue in the answer provided by Christian Boyce:  ol liCreate a New Document in TextEdit. Type "This is a sentence.". The file cannot be empty if you want run the code provided by Christian Boyce without error. Click "Make Plain Text" in the Format menu. Save the file as a .txt file./li liRun the AppleScript code that Christian Boyce provided. When asked to choose a file, open this .txt file./li liOpen the .txt file in TextEdit and manually add one blank line in between the new "Wassup?" line and the original "This is a sentence" line by using your kbdEnter/kbd key./li liOpen the .txt file in your hex editor. Notice that this new blank line is code0A0D/code. It should be, however, code0A0A/code. So, while the answer provided by Christian Boyce does not change all instances of code0A0A/code to code0D0D/code (in the way that the answers provided by Matteo and user3439894 do), it does use code0D/code instead of code0A/code when putting "Wassup?" on a new line./li /ol  It took me a long time to discover this glitch, as one could never tell that there was a problem with these AppleScript solutions unless one opens the .txt file in a hex editor.  The problem with the answer provided by Mateusz Szlosek is more severe; it replaces all instances of code0A0A/code with code20/code, thereby ensuring that there are emno/em blank lines anywhere in the .txt file (which, unlike the other answers, meant that I could easily identify that it had a bug without opening the .txt file in a hex editor).  So, I am re-opening this question, now hoping that someone can provide a way to prepend text to a .txt file using AppleScript, and strongwithout converting line feeds to carriage returns in the process./strong  If you are curious why I need the line feeds to be preserved, it is because I have a later process that writes to the first blank line of the .txt file, and this process does not work properly if the line feeds are replaced with carriage returns.  <answer260382> You could copy the current content of the file to a variable, then copy codeTextToWrite/code to codeTargetFilePath/code and then append the previous content back to codeTargetFilePath/code.  precodeset x to (do shell script "cat " &amp; quoted form of TargetFilePath)  do shell script "echo " &amp; quoted form of TextToWrite &amp; " &gt; " &amp; quoted form of TargetFilePath  do shell script "echo " &amp; quoted form of x &amp; " &gt;&gt; " &amp; quoted form of TargetFilePath /code/pre  <answer260394> Here's an example of the AppleScript You can use:  precodeset TargetFilepath to "$HOME/Desktop/file.txt" set TextToWrite to quoted form of "NewText\n" do shell script "echo " &amp; TextToWrite &amp; "$(cat " &amp; TargetFilepath &amp; ") &gt; " &amp; TargetFilepath /code/pre  It uses the formula: codeecho "prepend\n $(cat input)" &gt; input/code  <answer260425> Updated Answer:  The emcode/em below it what I'd use to replace the original code offered as there appears to be a bug in AppleScript when using the codedo shell script/code emcommand/em in the manner originally presented that isn't present went the emcode/em, in a representative manner, is run in a codebash/code emscript/em in Terminal.  Note that anytimecodeopen for access/code is used, it needs to be coded to trap any errors and try and close the file, which this attempts to do. That said it is not necessarily then only error handling I'd employ and all coding answer I present are done so as emproof of concept/em and the onus to write emcode/em employing reasonable error handing is yours to fulfill.  As emcoded/em, this will create the emtarget file/em if it doesn't exist while adding the emtext to add/em to it and if it does exist, places the emtext to add/em as the top line of the emtarget file/em.  precodeset targetFilePathname to (POSIX path of (path to desktop as string) &amp; "My Fruit Log.txt")  --    # set theTextToWrite to "This text will be written at the top of the file." &amp; "\n"     set theTextToWrite to "This text will be written at the top of the file." &amp; "\n" set theOriginalText to "" try     set theOriginalText to (read targetFilePathname) as string end try --    # set theTextToWrite to theTextToWrite &amp; "\n" &amp; theOriginalText set theTextToWrite to theTextToWrite &amp; "\n" &amp; theOriginalText try     set referenceNumber to open for access targetFilePathname with write permission     write theTextToWrite to referenceNumber starting at 0     close access referenceNumber on error eStr number eNum     display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with title "File I/O Error..." with icon caution     try         close access referenceNumber     end try     return end try /code/pre  <answer260630> You could do it this way, avoiding the shell scripts.   precodeset the_file to choose file set the_content to read of the_file  set the_new_stuff to "Wassup?" &amp; return &amp; the_content set the_file_path to the_file as string set open_for_writing to open for access file the_file_path with write permission write the_new_stuff to open_for_writing starting at 0 close access open_for_writing /code/pre  Basically you read the text in the .txt file, you put "Wassup?" and a return in front of the text, and then you write over what's in the file (because you start at position 0).  <answer262747> After a lot of trial and error, I think I have found one way to prepend text to a .txt file without carriage returns being introduced into the .txt file.  My solution is built on the solution provided by @Christian Boyce, with just one small change: replace codereturn/code with code"\n"/code.  So, the full solution would be:  precodeset the_file to choose file set the_content to read of the_file  set the_new_stuff to "Wassup?" &amp; "\n" &amp; the_content set the_file_path to the_file as string set open_for_writing to open for access file the_file_path with write permission write the_new_stuff to open_for_writing starting at 0 close access open_for_writing /code/pre  I have done tests with this code and I have not found it to insert code0D/code into the document and nor does it change any instances of code0A/code to code0D/code.  <comment326052> This code successfully prepends the text. Is it possible to create a new line in the .txt file for the new text (as requested)? <comment326060> @rubik's sphere, Change `set TextToWrite to "NewText"` to `set TextToWrite to quoted form of "NewText\n"` and when it compiles the `\n` will become a literal new line with the closing _quote_ literally on the next line and the `\n` disappears. <comment326064> @user3439894 thanks for a hint, I've added this to my answer. <comment326065> @user3439894 Thanks, your fix worked. @ MateuszSzlosek I have discovered that your code messes with the original formatting of the .txt file. For example, it randomly removes line breaks in the middle of the document. Try running your code with a .txt file that has a few paragraphs of text and empty line breaks in-between the paragraphs. Do you see what I am talking about? <comment329082> I think I may have found the root cause of the `0D0D` issue. Please do the following: 1. Create an empty plain text .txt file in TextEdit. 2. Run your script using this .txt file as _TargetFilepath_. 3. Open the .txt file in your hex editor. You will notice that the last four hex characters are `0A0A` (so far so good). 4. Manually open the .txt file in TextEdit. Create a new blank line beneath the sample sentence using your Enter key. 5. Run your script for the second time. 6. Open the .txt file in your hex editor. You will now notice that the `0A0A` has been converted to a `0D0D`. <comment329085> In other words, your code takes any previously-written instances of `0A0A` and replaces them all with `0D0D`. To be clear, it's not just your code; the codes that Matteo and @Christian Boyce provided behave similarly. The code provided by Mateusz Szlosek is even worse; upon running, it replaces all instances of `0A0A` with `20`. <comment329158> @user3439894 Can you please let me know how you feel about this solution? Is it good? <comment329163> Here's the acid test, so to speak... Writing the representative _code_ in a `bash` _script_ and running it in Terminal alone produces the expected and wanted results of having just _line feeds_ **not** _carriage returns_ whether starting with a zero length file or a file that already has ASCII Text content. The introduction of _carriage returns_ when using AppleScript's `do shell script` _command_ with the same `bash` _commands_ in this use case would have to be considered a **bug**, due to the fact that it is not producing the expected behavior. Continued in next comment... <comment329164> Therefore I would not use this methodology to write to files and instead use the other methods AppleScript offers. I have already shown you an example in http://apple.stackexchange.com/questions/260424/applescript-how-to-write-to-text-file-in-specific-location-signaled-by-specifi/260763#260763 and suggest you implement it as it does not introduce unwanted _carriage returns_ into the document. <comment329183> @user3439894 Thanks for the analysis. I don't know how to modify your code that writes to the first instance of a blank line so that the code instead writes to the very top of the document. The answer provided by Christian Boyce does not have a `do shell script` command anywhere in it. Can you tell me if [my answer](http://apple.stackexchange.com/questions/260381/how-to-prepend-to-text-file-in-applescript/262747#262747) is okay to use? <comment329210> No it is not, as it does not employ any or property error handling! See my updated answer to http://apple.stackexchange.com/questions/262687/how-can-i-use-applescript-to-see-if-a-specific-line-of-a-txt-file-matches-a-var/262689#262689 especially Part 4. Anytime you use `open for access` it needs to be coded to trap any errors and try and close the file.  This is how I coded it in the link I'm pointing you to the answer of another one of your questions. <comment329221> I've update my answer (again). :)
How to find the currently connected network service from the command line? <body> I would like to find out which of the available network services (e.g. emEthernet/em or emWi-Fi/em) is currently active. In this screenshot from the Network Preferences, you can see that emWi-Fi/em is currently active (the green dot):  img src="https://i.stack.imgur.com/TIqbI.png" alt="Network Preferences"  How can I get that information from the command line?  The codenetworksetup/code command allows me to list the available network services:  precode$ networksetup -listallnetworkservices An asterisk (*) denotes that a network service is disabled. Ethernet FireWire Wi-Fi /code/pre  It can also show some details on the service, like the device name:  precode$ networksetup -listnetworkserviceorder An asterisk (*) denotes that a network service is disabled. (1) Ethernet (Hardware Port: Ethernet, Device: en0)  (2) FireWire (Hardware Port: FireWire, Device: fw0)  (3) Wi-Fi (Hardware Port: Wi-Fi, Device: en1) /code/pre  Unfortunately, the info on which service is active (the green dot from the screenshot) is not available in this info. Is there another command that I could use to get this information?  <answer191881> The codescutil --dns/code command gives you all the network routing information you'll need to map hardware interface labels to network routes.  A little codeawk/code and codegrep/code can pretty it up if you need to script the information or pare it down. Start with gripping for "if_index" if you're curious.  <answer191887> Simply issue  precode    ifconfig /code/pre  List all network interfaces and their status.  <answer220935> Taken from Find Detailed Wi-Fi Connection History from Command Line of Mac OS X | OSXDaily:     For modern versions of Mac OS X, OS X Yosemite 10.10 and newer, use the following:   precodedefaults read /Library/Preferences/SystemConfiguration/com.apple.airport.preferences |grep LastConnected -A 7 /code/pre     Hit return and youâ€™ll instantly see the comprehensive listing of wireless network connection details.   You get a lot of info on the history of connections, including the details for current one.  Not perfect but you get the info that you're looking for - and a lot of extra info more!  <answer223446> Put it all together, I wrote a script to accomplish this task:  precode#!/bin/bash  services=$(networksetup -listnetworkserviceorder | grep 'Hardware Port')  while read line; do     sname=$(echo $line | awk -F  "(, )|(: )|[)]" '{print $2}')     sdev=$(echo $line | awk -F  "(, )|(: )|[)]" '{print $4}')     #echo "Current service: $sname, $sdev, $currentservice"     if [ -n "$sdev" ]; then         ifout="$(ifconfig $sdev 2&gt;/dev/null)"         echo "$ifout" | grep 'status: active' &gt; /dev/null 2&gt;&amp;1         rc="$?"         if [ "$rc" -eq 0 ]; then             currentservice="$sname"             currentdevice="$sdev"             currentmac=$(echo "$ifout" | awk '/ether/{print $2}')         fi     fi done &lt;&lt;&lt; "$(echo "$services")"  if [ -n "$currentservice" ]; then     echo $currentservice     echo $currentdevice     echo $currentmac else     &gt;&amp;2 echo "Could not find current service"     exit 1 fi /code/pre  The script first get a service list from codenetworksetup/code command, then check if each service is in active status from codeifconfig/code.  Name the script to codenetworkservice.sh/code for example, then execute it to get the current network service you are on.  precode$ sh networkservice.sh Wi-Fi en0 78:31:c1:c2:d7:6c /code/pre  <answer238722> Here's a fish shell script I wrote:  precodefunction netinfo -d "get network information"    # Get public ip address   set public (dig +short myip.opendns.com @resolver1.opendns.com)    if test -z "$public" # No Internet connection     set public "No Internet connection available"   end    echo " "   echo -n "    Public IP: "; set_color -i; echo $public; set_color normal   echo -n "     Hostname: "; set_color -i; echo (uname -n); set_color normal   echo " "    # Get all available hardware ports   set ports (ifconfig -uv | grep '^[a-z0-9]' | awk -F : '{print $1}')    # Get for all available hardware ports their status   for val in $ports     set activated (ifconfig -uv $val | grep 'status: ' | awk '{print $2}')      # We want information about active network ports...     if test $activated = 'active' ^/dev/null       set ipaddress (ifconfig -uv $val | grep 'inet ' | awk '{print $2}')        # and of these, the ones with an IP-address assigned to it       if test -n "$ipaddress" ^/dev/null          # Do we have an IP address?         # Then give us the information         set label (ifconfig -uv $val | grep 'type' | awk '{print $2}')         set macaddress (ifconfig -uv $val | grep 'ether ' | awk '{print $2}')         set quality (ifconfig -uv $val | grep 'link quality:' | awk '{print $3, $4}')         set netmask (ipconfig getpacket $val | grep 'subnet_mask (ip):' | awk '{print $3}')         set router (ipconfig getpacket $val | grep 'router (ip_mult):' | sed 's/.*router (ip_mult): {\([^}]*\)}.*/\1/')         set dnsserver (ipconfig getpacket $val | grep 'domain_name_server (ip_mult):' | sed 's/.*domain_name_server (ip_mult): {\([^}]*\)}.*/\1/')          # Header for the network interfaces         set_color -o; echo -n $label ; echo -n ' ('; echo -n $val ; echo ')'         echo "--------------"; set_color normal          # Is this a WiFi associated port? If so, then we want the network name         switch $label           case Wi-Fi             # Get WiFi network name             set wifi_name (/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I | grep '\sSSID:' | sed 's/.*: //')             echo -n ' Network Name: '; set_color -i; echo $wifi_name; set_color normal             # Networkspeed for Wi-Fi             set networkspeed (/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I | grep lastTxRate: | sed 's/.*: //' | sed 's/$/ Mbps/')           case '*'             # Networkspeed  for other ports             set networkspeed (ifconfig -uv $val | grep 'link rate:' | awk '{print $3, $4}')         end          echo -n '   IP-address: ' ; set_color -i; echo $ipaddress; set_color normal         echo -n '  Subnet Mask: ' ; set_color -i; echo $netmask; set_color normal         echo -n '       Router: ' ; set_color -i; echo $router; set_color normal         echo -n '   DNS Server: ' ; set_color -i; echo $dnsserver; set_color normal         echo -n '  MAC-address: ' ; set_color -i; echo $macaddress; set_color normal         echo -n 'Network Speed: ' ; set_color -i; echo $networkspeed; set_color normal         echo -n ' Link quality: ' ; set_color -i; echo $quality; set_color normal         echo ''       end        # Don't display the inactive ports.     else if test $activated = 'inactive' ^/dev/null     end   end end /code/pre  It shows all active network interfaces and relevant data.  Comment out what you don't want/need  <answer274646> Just incase someone else stumbles across this like I did the code below may be more of what you are looking for.  This is to expand on PeterVP's Answer  Also visible at https://www.kittell.net/code/mac-os-x-get-network-information/  pre #!/bin/sh  clear sExternalMACALService="http://dns.kittell.net/macaltext.php?address="  # List all Network ports NetworkPorts=$(ifconfig -uv | grep '^[a-z0-9]' | awk -F : '{print $1}') #echo $NetworkPorts  # Function to convert IP Subnet Mask to CIDR mask2cdr () { # Assumes there's no "255." after a non-255 byte in the mask local x=${1##*255.} set -- 0^^^128^192^224^240^248^252^254^ $(( (${#1} - ${#x})*2 )) ${x%%.*} x=${1%%$3*} echo $(( $2 + (${#x}/4) )) }  # Get remote/public IP address remoteip=$(dig +short myip.opendns.com @resolver1.opendns.com)  # Get computer name computername=$(scutil --get ComputerName)  # Get serial number sSerialNumber=$(system_profiler SPHardwareDataType |grep "Serial Number (system)" |awk '{print $4}'  | cut -d/ -f1) #echo $sSerialNumber  # Get operating system name and version - Start OSvers1=$( sw_vers -productVersion | cut -d. -f1 ) OSvers2=$( sw_vers -productVersion | cut -d. -f2 ) OSvers3=$( sw_vers -productVersion | cut -d. -f3 ) case $OSvers2 in 8) OSName="Mountain Lion" ;; 9) OSName="Mavericks" ;; 10) OSName="Yosemite" ;; 11) OSName="El Capitan" ;; 12) OSName="Sierra" ;; default) OSName="Unknown" ;; esac # Get operating system name and version - Stop   echo "$computername" echo "--------------" echo "      Computer OS:  Mac OS X - $OSName $OSvers1.$OSvers2.$OSvers3" echo "    Computer Name:  $computername" echo "Current User Name:  $(whoami)" echo "    Serial Number:  $sSerialNumber"  if [[ $remoteip ]]; then echo "Remote IP Address:  $remoteip\n" else echo "Remote IP Address:  Unable To Determine\n" fi  for val in $NetworkPorts; do   # Get for all available hardware ports their status activated=$(ifconfig -uv "$val" | grep 'status: ' | awk '{print $2}') #echo $activated label=$(ifconfig -uv "$val" | grep 'type' | awk '{print $2}') #echo $label #ActiveNetwork=$(route get default | grep interface | awk '{print $2}') ActiveNetworkName=$(networksetup -listallhardwareports | grep -B 1 "$label" | awk '/Hardware Port/{ print }'|cut -d " " -f3- | uniq) #echo $ActiveNetwork #echo $ActiveNetworkName state=$(ifconfig -uv "$val" | grep 'status: ' | awk '{print $2}') #echo $state ipaddress=$(ifconfig -uv "$val" | grep 'inet ' | awk '{print $2}') # echo $ipaddress  if [[ -z $(ifconfig -uv "$val" | grep 'link rate: ' | awk '{print $3, $4}' | sed 'N;s/\n/ up /' ) ]]; then networkspeed="$(ifconfig -uv "$val" | grep 'link rate: ' | awk '{print $3}' ) up/down" else networkspeed="$(ifconfig -uv "$val" | grep 'link rate: ' | awk '{print $3, $4}' | sed 'N;s/\n/ up /' ) down" fi  #echo $networkspeed macaddress=$(ifconfig -uv "$val" | grep 'ether ' | awk '{print $2}') #echo $macaddress macal=$(curl -s "$sExternalMACALService$macaddress") #echo $macal quality=$(ifconfig -uv "$val" | grep 'link quality:' | awk '{print $3, $4}') #echo $quality netmask=$(ipconfig getpacket "$val" | grep 'subnet_mask (ip):' | awk '{print $3}') #echo $netmask router=$(ipconfig getpacket "$val" | grep 'router (ip_mult):' | sed 's/.*router (ip_mult): {\([^}]*\)}.*/\1/') #echo $router DHCPActive=$(networksetup -getinfo "Wi-Fi" | grep DHCP) #echo $DHCPActive dnsserver=$(networksetup -getdnsservers "$ActiveNetworkName" | awk '{print $1, $2}' | sed 'N;s/\n//' ) #echo $dnsserver  if [ "$activated" = 'active' ]; then #echo "Network Port is Active" if [[ $ipaddress ]]; then echo "$ActiveNetworkName ($val)" echo "--------------" # Is this a WiFi associated port? If so, then we want the network name if [ "$label" = "Wi-Fi" ]; then WiFiName=$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -I | grep '\sSSID:' | sed 's/.*: //') #echo $WiFiName echo "     Network Name:  $WiFiName" fi  echo "       IP Address:  $ipaddress" echo "      Subnet Mask:  $netmask" echo "           Router:  $router" echo "          IP CIDR:  $ipaddress/$(mask2cdr $netmask)"  if [[ -z $dnsserver ]]; then if [[ $DHCPActive ]]; then echo "       DNS Server:  Set With DHCP" else echo "       DNS Server:  Unknown" fi else echo "       DNS Server:  $dnsserver" fi  echo "      MAC-address:  $macaddress ($macal)" echo "    Network Speed:  $networkspeed" echo "     Link quality:  $quality" echo " " fi  # Don't display the inactive ports. fi  done /pre  <answer282388> I won't pretend to have the answer to this question sorted, but this but this maybe helpful.  You can ask how it currently will route packets to something:  precode$ route get example.com | grep interface interface: en8 /code/pre  And then you can ask what "Network Service" is managing that interface:  precode$ networksetup -listnetworkserviceorder | grep en8 (Hardware Port: Broadcom NetXtreme Gigabit Ethernet Controller, Device: en8) /code/pre  But honestly, I doubt that a "Network Services" is one to one with a hardware port.  And some interfaces, tun0 for example, do not have a "Network Service".  Well at least sometimes they don't.  <comment228044> That looks useful - I'll play around with that! <comment228127> True - each record contains a `status` field that either has `active` or `inactive` as a value. <comment306002> I had to pipe the first line to `tac` to iterate through the interfaces in reverse order because I often have WiFi connected as well as a USB ethernet adapter (which is the preferred device in Network). In this case I want the most preferred active devise to be printed: `services=$(networksetup -listnetworkserviceorder | grep 'Hardware Port' | tac)` <comment335037> It will give you false result if you are sharing your internet. Suppose your are sharing ethernet internet via wifi then status for both Ethernet and wifi will be "active" <comment355780> In my script I've replaced public query with:    `set public (dig +short myip.opendns.com @resolver1.opendns.com)`  My reasoning for this is that a dns server (like opendns) is less likely to be down than a website and is faster. And I removed the sleep statement. No need to wait for the dns-server reply. Execution time for my script 177 ms. Yours takes 5.237 seconds, but does more of course. Still a big difference. <comment355925> Might be easier to define a `echo_italic` shell function instead of wrapping all these `echo`s in `set_color` calls. <comment355991> Great suggestion <comment356571> All `set_color` commands can be removed. They're just 'decorative'. <comment358350> This doesn't show you which service is being *used* - both wifi and ethernet will show as 'active' if you have both enabled and an ethernet cord plugged in.
How to use AppleScript to create a new Rich Text Format file from clipboard text? <body> I have an Automator Service that takes the current text on the clipboard and writes it to a new .txt file. This is executed simply with the following piece of AppleScript code:  precodedo shell script "pbpaste &gt; /path/to/your/clipboard-file.txt" /code/pre  This code is from the following Stack Overflow answer:  AppleScript to paste text from clipboard into a file  However, this code converts the clipboard contents to plain text, removing all of the text's formatting.  Is it possible to use AppleScript to write the clipboard contents to an .rtf or .rtfd file, while preserving the original formatting of the clipboard contents? By original formatting, I am referring to stylistic data such as typographical emphasis (bold, italics, underline), font size, and text color.  On a whim, I tried the following command:  precodedo shell script "pbpaste &gt; /path/to/your/clipboard-file.rtf" /code/pre  But this command resulted in an .rtf file that my computer was unable to read or open.  <answer251468> RTF files, unlike TXT files, are not just plain text but have a basic structure. To create an RTF file, use the following structure (instead of just the plain text from your keyboard):  precode{\rtf1\ansi\deff0 {\fonttbl {\f0 Verdana;}} \f0\fs16 Hello World! } /code/pre  Source: https://www.safaribooksonline.com/library/view/rtf-pocket-guide/9781449302047/ch01.html  <answer251490> This answer has been updated to reflect emrubik's sphere's/em misunderstanding between what Rich Text is (what was originally asked about) and what's actually being worked with from Google Chrome, being HTML. (See comments moved to chat.)  I'm leaving the original answer as is, and below this new content, as it does technically answer the original question as asked. It also contains relevant information to the overall process of dealing with Clipboard content in the context of the original and modified question.  The emcode/em below is example emcode/em to be tested and run within (Apple) Script Editor, as aside from the first sentence in the question, no explicit and specific usage within Automator has, yet, been given. The emcode/em may need to be edited to work within the unknown usage in Automator. That said, as written, if the entire emscript/em below was placed by itself into a Run AppleScript action, by itself, in Automator... it works as is. If using only segments of the emcode/em, some changes to the existing emcode/em could need to be made.  The emcode/em below contains sufficient commenting so as to understand overall what the emscript/em is doing.  hr  pre class="lang-none prettyprint-override"code--        #  --        # Change the 'New RichText Filename.rtf' name to the wanted filename for the target file. --        # Make sure you leave the double-quotes even if the filename does not contain spaces! --        # Note that '(path to desktop as text)' can also be modified as needed, e.g. changed to, --        # '(path to documents folder as text)' or the entire segment after 'set theRichTextFileName to' --        # can be a fully qualified POSIX pathname, e.g.: set theRichTextFileName to "/path/to/filename.rtf" --        #    set theRichTextFileName to POSIX path of (path to desktop as text) &amp; "New RichText Filename.rtf"   --    #        THE REMAINING CODE SHOULD NOT NEED TO BE MODIFIED. --    #  --    #     Note: This code, as is, works as written and intended when run from within (Apple) Script Editor. --    #     Some AppleScript code when wrapped in Automator may not work the same as in (Apple) Script Editor. --    #     In cases where is does not work from a Run AppleScript action in Automator, editing will be required. --    #  --    #     This AppleScript code preforms the following actions, sans errors caught during File I/O operations. --    #  --    # 1. See it the target file exists and prompts to be overwritten if it does. If yes is selected, it continues. --    #  --    # 2. If the Clipboard contains RTF content, writes it to the target file using plain AppleScript. --    #  --    # 3. If the Clipboard contains HTML content, writes it to the target file as RTF using a 'do shell script' command. --    #  --    # 4. If the Clipboard does not contain any RTF/HTML content, notify the user.  -- --        #    Notes: The 'do shell script' makes use of the following: --        # --        #    'osascript' to get the HTML content from the Clipboard. --        #    The content is a Hex stream within a data wrapper and --        #    'awk' will be used to remove/replace the data wrapper. --        # --        #    'awk' to remove the data wrapper from 'osascript' output --        #    replacing it with proper HTML opening/closing Tags to --        #    ensure it actually gets processed by 'textutil' after 'xxd'. --        #    Without the HTML opening/closing Tags 'textutil' does not  --        #    properly, within limits, convert the HTML Clipboard content to RTF. --        # --        #    'xxd' to convert the Hex data from 'osascript/awk' to ASCII text. --        # --        #    'textutil' to convert the ASCII text HTML from 'xxd' to RTF --        #    formatted data and write it to the target file.   tell application "Finder"      if exists theRichTextFileName as POSIX file then         tell current application             display dialog "The file \"" &amp; theRichTextFileName &amp; "\" already exists!" &amp; "\n\n" &amp; "Do you want to overwrite the file?" buttons {"No", "Yes"} default button 1 with title "File Already Exists..." with icon caution              if the button returned of the result is "No" then                 return             else                 tell application "Finder"                     delete the file (theRichTextFileName as POSIX file)                 end tell             end if         end tell     end if      tell current application          --    # Find out what class types are available for the Clipboard content         --    # and use this information to determine which action will be taken.          set cbInfo to get (clipboard info) as string          if cbInfo contains "RTF" then              try                 set richTextfromClipboard to get the clipboard as «class RTF »             on error eStr number eNum                 display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with icon caution                 return             end try             try                 set fileHandle to open for access theRichTextFileName with write permission                 write richTextfromClipboard to fileHandle                 close access fileHandle             on error eStr number eNum                 display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with title "File I/O Error..." with icon caution                 try                     close access fileHandle                 end try             end try          else if cbInfo contains "HTML" then              try                 do shell script "osascript -e 'try' -e 'get the clipboard as «class HTML»' -e 'end try' | awk '{sub(/«data HTML/, \"3C68746D6C3E\") sub(/»/, \"3C2F68746D6C3E\")} {print}' | xxd -r -p | textutil -convert rtf -stdin -stdout &gt; " &amp; quoted form of theRichTextFileName             on error eStr number eNum                 display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with icon caution             end try          else              display dialog "The Clipboard does not contain\nany usable RTF/HTML content!" buttons {"OK"} default button 1 with title "No RTF/HTML Content on Clipboard..." with icon caution          end if      end tell  end tell /code/pre  hr  strongOriginal answer to the original question asked:/strong  To get strongRich Text/strong emcontent/em from the strongClipboard/strong into a emfile/em using strongAppleScript/strong, it's a bit more complex then a simple codedo shell script/code emcommand/em.  The example strongAppleScript/strong emcode/em below will, if the target emfile/em doesn't already exist and if strongRich Text/strong emcontent/em exists on the strongClipboard/strong, write it to a emfile/em. It will have all the emattributes/em as the strongRichText/strong emcontent/em on the strongClipboard/strong has, as it did when copied to the strongClipboard/strong.  Open strongScript Editor/strong and copy and paste the emcode/em below into a new strongUntitled/strong document and then run it from strongScript Editor/strong, reviewing the emoutput/em in strongEvents/Replies/strong. Run it a couple of times, with and without strongRich Text/strong emcontent/em on the strongClipboard/strong and with and without the existence of the emfile/em, on the hard drive, defined by codeset theRichTextFileName .../code at the start of the emscript/em.  You'll see the emcode/em makes sure the emfile/em doesn't exist, so as not to overwrite an exiting emfile/em of the target name and location and if the strongClipboard/strong doesn't contain strongRich Text/strong emcontent/em, it displays a message for that too.  Now if using this in an strongAutomator Service/strong e.g., where strongService receives selected rich text/strong, then the emcode/em can be modified not to trap for an error if strongRich Text/strong emcontent/em isn't on the strongClipboard/strong as the emservice/em will not appear on the strongServices/strong emmenu/em if strongRich Text/strong is not selected in a document.  Also if you want to overwrite the target emfile/em at its designated location the emcode/em around that can be removed too. I'll give those emcode/em examples as well.  hr  Example emcode/em to paste into strongScript Editor/strong for testing and review:  pre class="lang-none prettyprint-override"codeset theRichTextFileName to POSIX path of (path to documents folder as text) &amp; "New RichText Filename.rtf"  tell application "Finder"     if exists theRichTextFileName as POSIX file then         tell current application             display dialog "The file \"" &amp; theRichTextFileName &amp; "\" already exists!" buttons {"OK"} default button 1 with title "File Already Exists..." with icon caution         end tell     else         tell current application             try                 set richTextfromClipboard to get the clipboard as «class RTF »             on error eStr number eNum                 display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with title "No Rich Text Content on Clipboard..." with icon caution                 return             end try             try                 set fileHandle to open for access theRichTextFileName with write permission                 write richTextfromClipboard to fileHandle                 close access fileHandle             on error eStr number eNum                 display dialog eStr &amp; " number " &amp; eNum buttons {"OK"} default button 1 with title "File I/O Error..." with icon caution                 try                     close access fileHandle                 end try                 return             end try         end tell     end if end tell /code/pre  hr  Example emcode/em to use in an strongAutomator Service/strong e.g., where strongService receives selected rich text/strong:  pre class="lang-none prettyprint-override"codeset theRichTextFileName to POSIX path of (path to documents folder as text) &amp; "New RichText Filename.rtf"  tell application "Finder"     if exists theRichTextFileName as POSIX file then         tell current application             display dialog "The file \"" &amp; theRichTextFileName &amp; "\" already exists!" buttons {"OK"} default button 1 with title "File Already Exists..." with icon caution         end tell     else         tell current application             set richTextfromClipboard to get the clipboard as «class RTF »             set fileHandle to open for access theRichTextFileName with write permission             write richTextfromClipboard to fileHandle             close access fileHandle         end tell     end if end tell /code/pre  hr  Example emcode/em to use in an strongAutomator Service/strong e.g., where strongService receives selected rich text/strong and overwrites existing target emfile/em:  pre class="lang-none prettyprint-override"codeset theRichTextFileName to POSIX path of (path to documents folder as text) &amp; "New RichText Filename.rtf"  tell current application     set richTextfromClipboard to get the clipboard as «class RTF »     set fileHandle to open for access theRichTextFileName with write permission     write richTextfromClipboard to fileHandle     close access fileHandle end tell /code/pre  hr  The image below is of an example strongAutomator Service/strong that creates the strongNew RichText Filename.rtf/strong emfile/em from selected strongRich Text/strong from the strongCreate Rich Text file from Clipboard/strong emservice/em on the strongServices Context menu/strong (by right-click) or strongApplication_name/strong  strongServices/strong  strongmenu/strong, when strongRich Text/strong is selected in a document.  img src="https://i.stack.imgur.com/QVaFl.png" alt="Automator Service - Create Rich Text file from Clipboard"  hr  Now these are just examples and additional logic can be coded to tailor it to meet ones needs. As an example, emcode/em could be added to automatically increment an existing file's name so as not to overwrite it, or prompt for a new file name and complete the operation vs. aborting with a message that the file already exists, etc.  hr  strongUpdate for use with a codedo shell script/code emcommand/em/strong:  If you really want to do it using a codedo shell script/code emcommand/em, then use the following emcode/em while replacing code/path/to/new rich text file.rtf/code with a valid empath filename/em to a location you have write permissions. Note not to remove the code\"/code before and after code/path/to/new rich text file.rtf/code in the actual emcommand/em as this handles the empath filename/em if containing spaces. If the empath filename/em does not contain spaces, then the code\"/code before and after code/path/to/new rich text file.rtf/code does not need to be used.  pre class="lang-none prettyprint-override"codedo shell script "osascript -e 'try' -e 'get the clipboard as «class RTF »' -e 'end try' | awk '{print substr($0, 12, length($0)-13)}' | xxd -r -p &gt; \"/path/to/new rich text file.rtf\"" /code/pre  Here's the emcommand/em line showing as wrapped text, for easier viewing:  codedo shell script "osascript -e 'try' -e 'get the clipboard as «class RTF »' -e 'end try' | awk '{print substr($0, 12, length($0)-13)}' | xxd -r -p &gt; \"/path/to/new rich text file.rtf\""/code  ul liWhile one can copy and paste (recommend) the emcode/em, nonetheless here's how to type the Double Angle Quotation Marks, which are also available under Parentheses in (Special) Characters, e.g. kbdoption/kbdkbdcommand/kbdkbdT/kbd in TextEdit.   Note: Keep in mind the spacing in code«class RTF »/code is meant to be offset in this use case.  ul liTyping Double Angle Quotation Marks  ul li« Left Double Angle Quotation Mark, press: kbdoption/kbdkbd\/kbd/li li» Right Double Angle Quotation Mark, press: kbdshift/kbdkbdoption/kbdkbd\/kbd/li /ul/li /ul/li /ul  Note that, as written, this codedo shell script/code emcommand/em overwrites the output file if it already exists, without prompting! It will either be a zero length file if the Clipboard does not contain any Rich Text content, otherwise the file will be of necessary length to contain the Rich Text content from the Clipboard. Obviously, additional logic could be coded into the codeosascript/code emcommand/em however if you need more complexity then this you're better off using the method first presented in this answer. Or using an external script being called by codedo shell script/code emcommand/em that handles all the necessary emlogic/em and emerror handling/em based on the complexity of the overall conditions this will be applied under.  ul liWhy such complexity vs. codedo shell script "pbpaste &gt; /path/to/clipboard-file.rtf"/code?/li /ul  That's a good question and while codepbpaste/code does have the code-Prefer {txt | rtf | ps}/code option, nonetheless codepbpaste -Prefer rtf/code may not output Rich Text even if it exists on the Clipboard. Or what it does output, if not ASCII Text, will not be a form of Rich Text that is understood, by e.g TextEdit, and or will not contain all the Rich Text emattributes/em if any, that the Clipboard content contains.  This makes it necessary to get the Rich Text content on Clipboard in a different manner and why codeget the clipboard as «class RTF »/code is being used instead. When using a codedo shell script/code emcommand/em with this, it requires additional processing to utilize the emdata/em returned, as it's in a emdata wrapper/em when returned and not immediately usable, thus requires further processing.  As an example, codeHello World!/code in Rich Text on the Clipboard can look like this in ASCII Text:  precode{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400 {\fonttbl\f0\fnil\fcharset0 ComicSansMS;} {\colortbl;\red255\green255\blue255;} \pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural  \f0\b\fs36 \cf0 Hello World!} /code/pre  The above format unfortunately is not easily usable, if at all, in AppleScript and I believe that's why being grabbed as Hex encoded emdata/em is required.  ul liI'm basing this on the fact that even though the codeget clipboard info/code emcommand/em for the Clipboard content in this example returns code{«class RTF », 265}/code among the info returned, nonetheless while the ASCII Text form of this Rich Text content is 265 bytes long it is returned in Hex format at over twice the bytes with the emdata wrapper/em.  The fact that it's returned in Hex by codeget the clipboard as «class RTF »/code in both the Script Editor or using codeosascript/code support this supposition./li /ul  Here's the same codeHello World!/code in Rich Text on the Clipboard in Hex:  code7B5C727466315C616E73695C616E7369637067313235325C636F636F61727466313138375C636F636F617375627274663430300A7B5C666F6E7474626C5C66305C666E696C5C66636861727365743020436F6D696353616E734D533B7D0A7B5C636F6C6F7274626C3B5C7265643235355C677265656E3235355C626C75653235353B7D0A5C706172645C74783732305C7478313434305C7478323136305C7478323838305C7478333630305C7478343332305C7478353034305C7478353736305C7478363438305C7478373230305C7478373932305C7478383634305C7061726469726E61747572616C0A0A5C66305C625C66733336205C6366302048656C6C6F20576F726C64217D/code  However, what's returned by codeget the clipboard as «class RTF »/code for the codeHello World!/code example above is:  code«data RTF 7B5C727466315C616E73695C616E7369637067313235325C636F636F61727466313138375C636F636F617375627274663430300A7B5C666F6E7474626C5C66305C666E696C5C66636861727365743020436F6D696353616E734D533B7D0A7B5C636F6C6F7274626C3B5C7265643235355C677265656E3235355C626C75653235353B7D0A5C706172645C74783732305C7478313434305C7478323136305C7478323838305C7478333630305C7478343332305C7478353034305C7478353736305C7478363438305C7478373230305C7478373932305C7478383634305C7061726469726E61747572616C0A0A5C66305C625C66733336205C6366302048656C6C6F20576F726C64217D»/code  The Hex encoded string is in a code«data RTF »/code emwrapper/em which needs to be removed before converting the Hex encoded content to ASCII Text to be written to a disk file by the use of I/O Redirection, e.g.code&gt;/code, in the codedo shell script/code emcommand/em example above.  So, the output of codeosascript -e 'try' -e ' get the clipboard as «class RTF »' -e 'end try'/code gets piped (code|/code) to codeawk/code where it creates a substring, printing only the Hex encoded content itself, not the emdata wrapper/em portion, as that would not be processed properly by codexxd/code in the next step of the process.  It then has to be piped (code|/code) to codexxd/code for conversion to codeASCII Text/code to be written to a disk file using I/O Redirection, e.g.code&gt;/code, to the target empath filename/em.   The image below is of Clipboard Viewer toggling between ASCII Text and Hex encoding views, showing codeHello World!/code copied from a Rich Text Document, the one used in this example.  img src="https://i.stack.imgur.com/3fcHQ.gif" alt="Clipboard Viewer"  hr  I hope this provides a better understanding of how AppleScript works with Rich Text content on the Clipboard, as either way conversion from a Hex encoded string to ASCII Text has to take place and this is being done transparently in the original example emcode/em while requiring additional processing outside of AppleScript emcode/em being processed by codeosascript/code when using the codedo shell script/code emcommand/em in this context.  <comment312649> I've edited my question so it is clearer. Do you have any idea how I can paste the clipboard text into the RTF file, and have the RTF file match the font, size, color, etc. of the clipboard text? <comment312806> Pretty sure what he's saying is that if you put that metadata in a plain text file, and give that the extension .rtf, then you have a valid .rtf file. <comment312807> @JonathanWarner I am indeed. <comment312808> @rubik'ssphere Just replace Hello World with your clipboard text and create the file, the font of the copied text should override the default there of Verdana. <comment312820> @John Ramos, In your comment you said `... I am indeed" to JonathanWarner's comment however, how your answer is written, that really isn't implied well, much less it gives no practical example of how to apply it in _coded_ format, which would have been a better answer then it was and no ambiguity about what you meant. However, rubik's sphere does not want to take plain text from the clipboard and make it rich text, he wants the rich text that is there, written to a disk file so it maintains all the rich text attributes it already has, not ones you'd have to manually code to employ your answer. <comment312839> @user3439894 My answer was just a good starting point, maybe not a complete answer as I don't do Applescripts. My best guess is that the rich text attributes of the clipboard text will override the chosen font, color, and size settings and will work exactly as the OP wants. If my answer isn't satisfactory, I think Applescript might not be able to achieve this, and making an app in Xcode might be necessary. If that's the case, Stack Overflow is a good place for this question. <comment312841> So I just hope that @rubik'ssphere at least tries what I have here. <comment312844> @John Ramos, you said, "_If my answer isn't satisfactory, I think Applescript might not be able to achieve this, and making an app in Xcode might be necessary._" Did you read my answer? Of course it can be done in AppleScript as I wouldn't have provided the AppleScript answer I did, if it couldn't. I think the problem is as you said ,"_as I don't do Applescripts_" and herein lies the issue as you don't ever realize or understand why what you wrote for an answer isn't usable in the context of the information presented within the OP. Continued in next comment... <comment312845> As to "_So I just hope that @rubik'ssphere at least tries what I have here._", well sorry to say but it's just not usable in the context asked for! When you do not understand the subject matter, in this case AppleScript, and how it works, especially in reference to the context requested, it might be best not to try an answer the question. I'm really not trying to be hard on you or upset you with what I've said and I believe if you understood AppleScript and the context of how it applies to the information presented in the OP you'd understand and wouldn't have post what you did to begin with. <comment312846> @user3439894 OK, I just wanted to provide some info on the structure of RTF files, because that seems more like what's being asked here than specifically AppleScript. <comment313852> Comments are not for extended discussion; this conversation has been [moved to chat](http://chat.stackexchange.com/rooms/45233/discussion-on-answer-by-user3439894-how-to-use-applescript-to-create-a-new-rich). <comment314307> I've updated my answer to work with both RTF and HTML Clipboard content. <comment315160> Did my updated answer work for you? <comment342355> @rubik's sphere, This _code_ had the same _bug_ as in your other question in that the _target file_ was being overwritten internally not deleted. I've corrected the _bug_ by adding `delete the file (theRichTextFileName as POSIX file)` within a Finder `tell` _block_ in the added _else_ _branch_ of the `if the button returned of the result is "No" then` _statement_. <comment342357> @rubik's sphere, As to the modification you've asked for, I'll have to review the _code_ and see what can be done, however since this answer, now as is, actually answers the original question asked, I feel any modification should be attempted first by you and then posted as a separate question if you can't achieve your goal. IMO It's not exactly fair to come back months later requesting modifications be made to an already accepted and up-voted answer that adds additional previously unasked parameters to the original question. <comment342364> I apologize. You're right. I will create a new question. <comment342376> I figured out how to add blank lines to the file when I have a plain text clipboard and thus .txt file, but I couldn't figure out how to do it with an HTML or RTF clipboard. [Here's that question.](http://apple.stackexchange.com/questions/272410/i-need-help-inserting-blank-lines-into-rtf-file-with-applescript)
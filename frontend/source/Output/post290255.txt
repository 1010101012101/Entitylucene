AppleScript to return condition depending on audio file length <body> I'd like to use Hazel em(a rule-based file system automator)/em for macOS to automatically move mixtape audio files from one folder to another, if their duration is longer than 30 minutes.  Hazel doesn't provide a built-in method of checking for audio file length (that I know of), but it provides the ability to run rules if an AppleScript condition is passed, i.e. codereturn true/code.  Judging from the screenshot below, I think it works if codelength of theFile &gt; 30*60 seconds: return true/code em(pseudo code)/em.  img src="https://i.stack.imgur.com/tTPiH.png" alt="enter image description here"  I'm not however sure how to accomplish this via AppleScript. Any ideas how to do it, or where to start? A search online didn't provide many basic ideas, but it seems to be possible.  hr  emNote/em: Giving advice on AppleScripts is outside the scope of the Hazel support AFAIK, so I can't get any help from them.  <answer290327> Okay, I've downloaded Hazel and tested the following AppleScript emcode/em on a New Rule to validate it works. The following emcode/em when used in an emembedded script/em will set codetheResult/code to codetrue/code on codetheFile/code, an audio file that is longer than 30 minutes. Any file 30 minutes or less, or a non-audio file will set codetheResult/code to codefalse/code:  precodeset theResult to (do shell script "[[ $(afinfo -r '" &amp; POSIX path of theFile &amp; "' | awk '/estimated duration:/{print int($3/60)}') -gt 30 ]] &amp;&amp; echo 'true' || echo 'false'") as boolean return theResult /code/pre  ul liNote that from my first comment before posting this answer, I've changed codetheFileName/code to codePOSIX path of theFile/code, and as you can see in the image below, it validated the rule. It then also processed the rule, as I defined it, successfully./li liTo change the number of minutes, change the emvalue/em on the right side of the emoperator/em, e.g.br code-gt 30/code to the desired time, e.g. code-gt 20/code. The emoperator/em can also be changed to any one of the following: code-eq/code, code-ne/code, code-lt/code, code-le/code, code-gt/code or code-ge/code/li /ul  img src="https://i.stack.imgur.com/jHmBe.png" alt="Hazel Preference Pane"  Understanding, a little bit, the content of the codedo shell script/code emcommand/em:  ul licodeafinfo/code doesn't have much in the way of an emmanual page/em, so just type codeafinfo/code in Terminal and press ementer/em for its emoptions/em./li licodeafinfo -r/code - code{-r --real} get the estimated duration after obtaining the real packet count/code/li liExample output of codeafinfo -r/code:  precode $ afinfo -r '09 Karn Evil 9.mp3'  File:           09 Karn Evil 9.mp3  File type ID:   MPG3  Num Tracks:     1 ----  Data format:     2 ch,  44100 Hz, '.mp3' (0x00000000) 0 bits/channel, 0 bytes/packet, 1152 frames/packet, 0 bytes/frame                     no channel layout.  audio bytes: 85117515  audio packets: 81460  estimated duration: 2127.935 sec  bit rate: 320000 bits per second  packet size upper bound: 1052  maximum packet size: 1045  audio data file offset: 275530  optimized ----  $ /code/pre  ul liThe above output gets piped (code|/code) to codeawk/code./li /ul/li licodeawk '/estimated duration:/{print int($3/60)}'/code  ul licodeawk/code finds the emrecord/em (line) containing codeestimated duration:/code in the emoutput/em of codeafinfo/code piped to it and prints the third emfield/em, code$3/code, code2127.935/code as an integer, having been divided by code60/code to get the number of minutes, as the time value is in seconds. In the example emoutput/em, codeawk/code returned: code35/code/li /ul/li licode$(...)/code The emcommand substitution/em portion passed code35/code to the test code[[ $(...) -gt 30 ]]/code, so it equated to code[[ 35 -gt 30 ]]/code and as a result, using logical operators, echoed codetrue/code. Had the value been equal to or less than 30, or a non-audio file, it would have echoed codefalse/code./li /ul  hr  If you want the emcontent/em of codedo shell script/code emcommand/em to run faster, then use the following:  precodeset theResult to (do shell script "[[ $(afinfo -b '" &amp; POSIX path of theFile &amp; "' | awk 'FNR == 3 {print int($1/60)}') -gt 30 ]] &amp;&amp; echo 'true' || echo 'false'") as boolean return theResult /code/pre  ul licodeafinfo -b/code - code{-b --brief} print a brief (one line) description of the audio file/code  ul liThis runs faster then using code-r/code as it's not counting the packets, but getting the info from embedded data. Note that while the emhelp/em says "(one line)", the emoutput/em is actually three lines, but still faster then the long form, especially if not using code-r/code./li /ul/li liExample emoutput/em of codeafinfo -b/code:  precode$ afinfo -b '09 Karn Evil 9.mp3' 09 Karn Evil 9.mp3, MPG3, Num Tracks:     1 ---- 2127.938 sec, format:   2 ch,  44100 Hz, '.mp3' (0x00000000) 0 bits/channel, 0 bytes/packet, 1152 frames/packet, 0 bytes/frame $ /code/pre  ul liThe above output gets piped (code|/code) to codeawk/code./li /ul/li licodeawk 'FNR == 3 {print int($1/60)}'/code  ul licodeawk/code prints the first emfield/em (code$1/code) of the third emrecord/em (line) of emoutput/em piped from codeafinfo -b/code, code2127.935/code as an integer, having been divided by code60/code to get the number of minutes, as the time value is in seconds. In the example output, codeawk/code returned: code35/code/li /ul/li /ul  <comment366408> I don't have Hazel, so I can't test with it and why a comment vs. an answer, however here's an AppleScript `do shell script` _command_ that will set `theResult` to `true` or `false` if you can figure out how to pass it `theFileName`: `set theResult to (do shell script "[[ $(afinfo -r '" & theFileName & "' | awk '/estimated duration:/{print int($3/60)}') -gt 30 ]] && echo 'true' || echo 'false'") as boolean`. You can then add this line after it, `return theResult` and it will be equivalent to `return true` or `return false` accordingly. <comment366448> @user3439894 I understand why you didn't post this as an answer, but I still think you should because doing so prevents the OP from deleting the question (for whatever reason). And, in this case, your answer is likely to lead to a solution that helps others. :) <comment366474> @Monomeeth, I went ahead and downloaded Hazel and after a slight modification, validated the _code_ in my comment. By the way, I do not believe that adding an answer can stop the author of the OP from deleting his/her question. <comment366476> +1 Nice work! I'm sure others will find this useful to know. :) <comment366478> @Monomeeth, so as to live up to your gracious comment,  I updated the answer to include a little bit of an understanding of what the `do shell script` _command_ is doing. BTW +1 for you on the Community Moderator Election! :) <comment366482> Thanks for the solution, and especially for adding context and explanation which I think will be most beneficial for a wider audience! <comment366489> @Winterflags, I've update the answer to add info on how to make it faster, read the section at the end of the answer after: "If you want the _content_ of `do shell script` _command_ to run faster, then use the following:"
How to delete a specific line of a paragraph in AppleScript, while retaining the original format of the text? <body> I have a text variable of class codetext/code that shows something like this when it is returned:  precode" This is sentence 1. This is sentence 2. This is sentence 3. This is sentence 4." /code/pre  I want to be able to delete specific lines from the text, without affecting the rest of the variable.  For example: codedelete {1, 3}/code to get this result:  precode"This is sentence 1. This is sentence 3. This is sentence 4." /code/pre  hr  The method described in this answer has a serious bug:  em"How to delete a specific line of a paragraph in AppleScript?"/em  The linked method to delete lines in a paragraph actually converts all linefeeds in the text variable to returns. In other words, it is impossible to run this code more than once on the same variable.  For example, the following code:  precodeset varText to " This is sentence 1. This is sentence 2. This is sentence 3. This is sentence 4." set varText to do shell script "sed -e '1d;3d' &lt;&lt;&lt; " &amp; quoted form of varText -- Employing the same method on the same variable: set varText to do shell script "sed -e '1d;3d' &lt;&lt;&lt; " &amp; quoted form of varText return varText /code/pre  returns  code""/code  Since this method only works correctly if the lines of the text variable are the product of a codelinefeed/code (as it should), the problem is strongemnot/em/strong that this method fails to perceive a codereturn/code as a new line (as I had originally claimed in this question). The problem is that this code introduces a codereturn/code to the text variable in the first place.  hr  Thus, I want a solution that will allow me to strongrun the same text variable through the solution more than once/strong in the same AppleScript.  In other words, I am looking for a method to remove a specific line from a paragraph that does not have this bug and does not insert a codereturn/code anywhere in the text.  <answer276261> strongExample:/strong  precodeset varText to " This is sentence 1. This is sentence 2. This is sentence 3. This is sentence 4."  set varText to do shell script "sed -e '1d;3d' &lt;&lt;&lt; " &amp; quoted form of varText /code/pre  strongReturns:/strong  precode"This is sentence 1. This is sentence 3. This is sentence 4." /code/pre  hr  strongUpdate:/strong As a result of a discovery mentioned in the strongEdit:/strong of How to delete a specific line of a “return”-based paragraph in AppleScript?, let me make the following statement:  strongNOTE:/strong Unfortunately what's returned in this case has emcarriage return/em (x0D) emcharacters/em instead of the expected emnew line/em (x0A) characters and in my opinion is a bug!  strongIt's a bug because:/strong The codedo shell script "sed ..."/code emcommand/em when run in Terminal with that codevarText/code returns with code\n/code (x0A) not code\r/code (x0D) as it's supposed to. Even the compiled codedo shell script "sed ..."/code emcommand/em in Script Editor still has code\n/code (x0A) not code\r/code (x0D) however why it's being returned with code\r/code (x0D) intend of the expected code\n/code (x0A) is a mystery to me at the moment and I'm going to consider this an AppleScript bug since it not mirroring the expected behavior of the same when run in Terminal.  So, to account for the embug/em in the results of the codedo shell script "sed ..."/code emcommand/em, this is how I'd handle it. After the codedo shell script "sed ..."/code emcommand/em use the following lines of emcode/em:  precodeset newLine to "\n" set varText to paragraphs of varText set oldTID to AppleScript's text item delimiters set AppleScript's text item delimiters to newLine set varText to varText as string set AppleScript's text item delimiters to oldTID /code/pre  Now what's returned contains emnew line/em (x0A) emcharacters/em as it should have to begin with if there wasn't this bug, not emcarriage return/em (x0D) emcharacters/em.  hr  Note: When compiled, the codeset newLine to "\n"/code line of emcode/em will show as below:  precodeset newLine to " " /code/pre  <answer276477> Let's break down this script into smaller pieces and then put it all together in one AppleScript.  This approach is written entirely in AppleScript and requires no external tools. Using external tools, like codeperl/code or codesed/code, will likely result in much shorter solutions but you have mentioned in other questions wanting to learn AppleScript.  h21. Split with Delimiters/h2  You can use AppleScript's strongdelimiters/strong behaviour to split a string. You can change the delimiter as desired to codereturn/code, codelinefeed/code, or even characters like code=/code :  precode -- http://macscripter.net/viewtopic.php?id=24473  to split(someText, delimiter)      set AppleScript's text item delimiters to delimiter      set someText to someText's text items      set AppleScript's text item delimiters to {""} --&gt; restore delimiters to default value      return someText  end split   set myText to (return &amp; "This is sentence 1." &amp; return &amp; "This is sentence 2." &amp; return &amp; "This is sentence 3." &amp; return &amp; "This is sentence 4.")  set myLines to split(myText, return) /code/pre  h22. Filter List/h2  With the returned list, you can filter out the undesirable items using a loop:  precode -- http://macscripter.net/viewtopic.php?id=24525  set indexesToDelete to {1, 4}  set cleanList to {}   repeat with i from 1 to count myLines      if i is not in indexesToDelete then set cleanList's end to myLines's item i  end repeat /code/pre  h23. Combine the Items/h2  The filtered list of sentences can be re-combined using another loop:  precode-- Combine the filtered list into a string set myResult to "" repeat with i from 1 to count cleanList     if myResult is "" then         set myResult to cleanList's item i     else         set myResult to myResult &amp; return &amp; cleanList's item i     end if end repeat /code/pre  h1Entirely AppleScript/h1  Combining these snippets results in the following code:  precode-- Get the text to work with set myText to (return &amp; "This is sentence 1." &amp; return &amp; "This is sentence 2." &amp; return &amp; "This is sentence 3." &amp; return &amp; "This is sentence 4.")  -- Split the text into lines based on 'return' delimiter set myLines to split(myText, return)  -- Filter out indexes 1 and 4 using a loop set indexesToDelete to {1, 4} set cleanList to {} repeat with i from 1 to count myLines     if i is not in indexesToDelete then set cleanList's end to myLines's item i end repeat  -- Combine the filtered list into a string set myResult to "" repeat with i from 1 to count cleanList     if myResult is "" then         set myResult to cleanList's item i     else         set myResult to myResult &amp; return &amp; cleanList's item i     end if end repeat  -- Final string myResult  to split(someText, delimiter)     set AppleScript's text item delimiters to delimiter     set someText to someText's text items     set AppleScript's text item delimiters to {""} --&gt; restore delimiters to default value     return someText end split /code/pre  The script above could be reduced by combining the filter and re-combination loops. I have left these as separate tasks to better demonstrate their roles.  <answer276499> Okay, I've deleted the original and first edit because you've edited your originally question to the point it's easier to write a new answer altogether.  Since your originally question showed the following line of emcode/em, as an example of how the variable may be set, I'm going to include it to say the following.  Whether the codevarText/code has been set by e.g.:  precodeset varText to (return &amp; "This is sentence 1." &amp; return &amp; "This is sentence 2." &amp; return &amp; "This is sentence 3." &amp; return &amp; "This is sentence 4.") /code/pre  ul liIn which codereturn/code is codex0D/code vs. the more proper use of codelinefeed/code (codex0A/code) instead, in a case where the variable is emdata/em and not a disposable message./li /ul  Or:   precodeset varText to " This is sentence 1. This is sentence 2. This is sentence 3. This is sentence 4." /code/pre  ul liIn which each of these lines actually end with a codelinefeed/code (codex0A/code) as it should be on a Mac./li /ul  The codedo shell script/code emcommand/em has a strongbug/strong as it converts codex0A/code to codex0D/code after what's returned from the emcommand line/em having the expected codex0A/code endings passed back. I confirmed this because if I use the following:  precodeset varText to " This is sentence 1. This is sentence 2. This is sentence 3. This is sentence 4."  set varText to do shell script "sed  -e '1d;3d' &lt;&lt;&lt; " &amp; quoted form of varText &amp; " | tee $HOME/Desktop/outfile" /code/pre  Then codeoutfile/code contains codelinefeed/code (codex0A/code) endings so the same is returned to codedo shell script/code but it then erroneously converts the codex0A/code line endings to codex0D/code endings which can then handled by the following:  So, to accommodate the strongbug/strong, always insure the content of the variable passed and returned contains codex0A/code line endings by using the following codehandler/code and example emcode/em.  The following assumes that codevarText/code has already been set by either of the methods described above.  precodeon ensureLinesEndWith0A(varText)     set varText to paragraphs of varText     set oldTID to AppleScript's text item delimiters     set AppleScript's text item delimiters to linefeed     set varText to varText as string     set AppleScript's text item delimiters to oldTID     return varText end ensureLinesEndWith0A  set varText to ensureLinesEndWith0A(varText) set varText to do shell script "sed  -e '1d;3d' &lt;&lt;&lt; " &amp; quoted form of varText set varText to ensureLinesEndWith0A(varText) /code/pre  You could then use the following again to delete more lines from codevarText/code:  precodeset varText to ensureLinesEndWith0A(varText) set varText to do shell script "sed  -e '1d;3d' &lt;&lt;&lt; " &amp; quoted form of varText set varText to ensureLinesEndWith0A(varText) /code/pre  The image below shows and example of calling the codedo shell script " sed ..."/code emcommand/em twice.   img src="https://i.stack.imgur.com/8RfRu.png" alt="image of code example"  <comment347929> If I am removing only one line, do you suggest that I include the semicolon? I tried it both ways (with and without the semicolon) and it seems to work fine either way, but I am just asking for your preference. <comment347976> @rubik's sphere, The semi-colon is only needed as a separator when more then one range is specified, in this use case. Which line are you wanting to delete? <comment347996> Did you see the last part of my new question? It is impossible to run this method twice on the same variable, which must mean that your line deletion method alters the new line (x0A) characters to something else (in the process of deleting a line). <comment347999> Regarding info in your **Edit:**: The `do shell script "sed ..."` _command_ when run in Terminal with that `varText` returns with `\n` (x0A) not `\r` (x0D) as it's supposed to. Even the compiled `do shell script "sed ..."` _command_ in Script Editor still has `\n` (x0A) not `\r` (x0D) however why it's being returned with `\r` (x0D) intend of the expected `\n` (x0A) is a mystery to me at the moment. I'm going to consider this an AppleScript bug since it not mirroring the expected behavior of the same when run in Terminal.  This is why I deleted my answer because I wasn't aware of the issue. <comment348049> GrahamMiln Since now I've identified the bug with the original answer that led me to post the second question, is it possible to merge these two questions together? If not, can you just delete this question altogether, since @user3439894 has provided their updated answer on the second question? <comment348052> I don't want to delete this question myself, because doing so will result in a strike against my SE account. (I understand that the act of deleting one's own question is penalized). <comment348067> Your strategy also suffers from the exact same bug found in the original method provided by @user3439894 (the bug is described in the "Edit:" part of my post). I.e., if `myText` contains linefeeds instead of returns, and you use the line: `set myLines to split(myText, linefeed)`, your code will convert every linefeed that exists in the text to a return, making it impossible for the same text variable to successfully run through your method more than once. I was hoping for a solution that doesn't possess this problematic side effect; I want to delete lines from the same variable more than once. <comment348097> @rubik's sphere, Graham Miln's answer does not suffer from the same bug as he's not using a `do shell script` _command_, which is where the bug is. He's using `return` just like you originally showed in the original version of this question! You should not use `return` to concatenate multi-line _strings_, you should use `linefeed` instead. As a matter of fact if you replaced all be the last `return` to `linefeed` in his answer it would work as expected by maintaining `x0A` line endings vs. the `x0D` which `return` does when used as a `text` class special string character constant. <comment348098> @user3439894 You are right in that it is not, technically, the "same" bug. To be clear, Graham's method has a different bug, but one with the exact same effect as the bug in your `do shell script` method. This is the test: using linefeeds in the place of returns in Graham's answer, can you run a specific text variable through his method more than once in the same script with everything still working properly (e.g., by first deleting the second line of the paragraph and then deleting the third line, in two separate statements)? <comment348099> On your point about using `return`, I of course agree! In reality, I _don't_ use and _have never_ used `return` to concatenate multi-line strings! That's why I had to significantly edit the title and body of this question; my post contained several inaccurate statements. This post was first published _before_ I had picked up on the bug in your code, which (I eventually realized) explained where all the `returns` in my text variables were coming from! I had originally assumed that **_I_** was—somehow—responsible for the prevalence of the `return` characters, which, now I know, is not the case. <comment348105> First of all it was not my code per se that had the bug! It's a bug in how the `do shell script` _command_ is processing what's returned from the _command line_, it's AppleScript that's not properly processing the output of the command(s) executed within the `do shell script` _command_! Your use of `return` as a multi-line string concatenation was a problem as `sed` saw the contents of the variable as one line and deleted it because it's expecting `x0A` not `x0D` line endings. Anyway my updated answer handles both the poor use of `return` over `linefeed` and the bug. <comment348109> Yes, I obviously did not mean to imply that _you_ personally are responsible :). When I stated, _"bug in your code,"_ it was shorthand for, _"the AppleScript bug that manifested in the solution that you provided."_ You wrote, _"Your use of return as a multi-line string concatenation was a problem."_ As I said, I completely misunderstood the issue at hand (bc I failed to realize the AppleScript bug) when I provided that example of using `return` to concatenate in the original post. <comment348110> I have not once in my entire life actually used `return` to concatenate; that example existed to highlight a problem that was not actually the problem.  Unrelated question... have you had a chance to corroborate my observation about Graham's answer? <comment348113> Okay, I played with his code and it does look like it's not working as you want it to even when replacing all but the last `return` with `linefeed` or using the other method of setting the variable. I'll look more closely tomorrow as I'me done for the night. Anyway, my answer employs a bug fix and can handle `return` when used as a text class special string character constant and or what's returned from the `do shell script` command. <comment348114> @rubik's sphere, Checkout the image I added to my answer. <comment348123> I have tested your `text item delimiters to linefeed` workaround. I believe that it successfully corrects the pernicious little AppleScript bug that we've identified. I can now perform countless `do shell script "sed  -e...` operations on the same text variable within the same run of a script, and the specified lines are reliably deleted as intended. Thank you for your help!
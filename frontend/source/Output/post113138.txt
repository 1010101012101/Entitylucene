How to recursively edit path of symlinks? <body> This is an additional question that began with this one - How to edit Symbolic Links in OS X?  Now that I know how to edit the path symlinks point to, I'm trying to figure out how to do this recursively for any broken symlink.  I'm a PHP guy, so this CLI stuff is somewhat foreign to me...  There seems to be a few specific elements to this, namely:  ol liIdentify a broken symlink and retrieve its location/li liGet the old, now-incorrect, destination for the symlink/li liConstruct the new correct path for the symlink to point to/li liEdit the symlink/li /ol  The first is fairly easy:  codefind /path/to/search -type l | while read f; do if [ ! -e "$f" ]; then ls -l "$f"; fi; done/code  This gets me a nice list of all broken symlinks found below the supplied directory.  But I believe I would need to store the location of each in a variable (array?) to work with it.    Next, it seems that changing the action supplied in the "then" portion of the logic, would yield the solution.  Item 2 can be retrieved using:  codereadlink /path/to/broken/symlink/code  So it seems we need to shove that into a variable.  I'm unclear on how to do this in terminal.  Number 3 would be a simple edit to the path retrieved during step 2.  I need to replace the old drive name, with the new.  So changing:  code/Volumes/Old\ Drive/path/to/symlink/code  to  code/Volumes/New\ Drive/path/to/symlink/code  Also unclear on exactly how to do this within a CLI script.  Some sort of string replacement appears to be needed.  Something like str_replace in the PHP world.  Finally step 4 can be done via:  codeln -f -s /path/to/new/location/of/original /path/to/location/of/broken/symlink//code  as detailed in my other question, previously linked above.  How exactly would I string these concepts together, to accomplish my desired outcome of fixing all my symlinks in one shot?  <answer113149> From the top of my head (and without any testing at all):  ol liCreate a text file with the following content  precode#!/bin/bash  find "$1" -type l | while read symlink; do     if [ ! -e "$symlink" ]; then         old_path=$(readlink "$symlink")         new_path=${old_path/Old Drive/New Drive}         ln -f -s "$new_path" "$symlink"     fi done /code/pre/li liMake it executable by running codechmod +x name-of-file/code/li liRun code./name-of-file /path/to/search/code/li /ol  This is stronguntested/strong so try it with a sample directory first.  hr  To add some explanations  ul licodeold_path=$(readlink "$symlink")/code runs the command in code$(...)/code and assigns the result to code$old_path/code/li licode${old_path/Old Drive/New Drive}/code does text substitution on code$old_path/code/li /ul  <answer113150> In a codebash/code shell, to set a variable, simply use codeset NAME=bob/code or codeset VITAL_SIGNS=none/code.  You can also set a variable using the output of a command by calling the codebash/code-builtin function coderead/code to assign the output to a named variable. This works well in a pipe stream like so:  precodels -l | wc -l | read NUMBER_OF_LINES /code/pre  Or you can assign the output directly to a variable like so:  precodeLICENSE_KEY=$(cat ~/software/key.txt | grep KEY | awk '{print $1}') /code/pre  A great way to recursively read variables is in a loop as follows:  precodefor BROKEN_LINK in $(commands to produce a list of files) do commands here to sort your links out, noting that the broken links are stored in the variable $BROKEN_LINKS done /code/pre  With the above in mind, something like the following should work:  emprove a folder doesn't exist/em  precodeStuffeMac:dan stuffe$ ls ~/Desktop/broken_links ls: /Users/stuffe/Desktop/broken_links: No such file or directory /code/pre  emprove a new target folder does exist/em  precodeStuffeMac:dan stuffe$ ls ~/Desktop/working_links StuffeMac:dan stuffe$ /code/pre  emcreate some invalid and valid links/em  precodeStuffeMac:dan stuffe$ ln -s ~/Desktop/brokenlinks/dan1 StuffeMac:dan stuffe$ ln -s ~/Desktop/brokenlinks/dan2 StuffeMac:dan stuffe$ ln -s ~/Desktop/working_links/dan3 StuffeMac:dan stuffe$ ln -s ~/Desktop/outofscopedeadlinks/dan4 StuffeMac:dan stuffe$ ls -l total 32 lrwxr-xr-x  1 stuffe  staff  38  8 Dec 10:06 dan1 -&gt; /Users/stuffe/Desktop/brokenlinks/dan1 lrwxr-xr-x  1 stuffe  staff  38  8 Dec 10:06 dan2 -&gt; /Users/stuffe/Desktop/brokenlinks/dan2 lrwxr-xr-x  1 stuffe  staff  40  8 Dec 10:06 dan3 -&gt; /Users/stuffe/Desktop/working_links/dan3 lrwxr-xr-x  1 stuffe  staff  46  8 Dec 10:21 dan4 -&gt; /Users/stuffe/Desktop/outofscopedeadlinks/dan4 /code/pre  emgrab a list of dead links into a file for input/em  precodeStuffeMac:dan stuffe$ find . -type l | while read f; do if [ ! -e "$f" ]; then ls "$f" &gt;&gt; deadlinks.txt; fi; done StuffeMac:dan stuffe$ more deadlinks.txt ./dan1 ./dan2 ./dan4 /code/pre  emrun a loop against each dead link/em  precodeStuffeMac:dan stuffe$ for DEAD_LINK in $(cat deadlinks.txt) &gt; do &gt; DESTINATION_IN_SCOPE=$(readlink $DEAD_LINK | grep brokenlinks | wc -l) &gt; NEW_DESTINATION="~/Desktop/working_links/" &gt; if [ $DESTINATION_IN_SCOPE = "1" ] &gt; then &gt; NEW_LINK=$(echo $DEAD_LINK | colrm 1 2) &gt; ln -f -s $NEW_DESTINATION$NEW_LINK $DEAD_LINK &gt; else &gt; echo "Link $DEAD_LINK not in target folder" &gt; fi &gt; done Link ./dan4 not in target folder StuffeMac:dan stuffe$ /code/pre  emcheck out the symlinks after edits/em  precodeStuffeMac:dan stuffe$ ls -l total 32 lrwxr-xr-x  1 stuffe  staff  28  8 Dec 10:08 dan1 -&gt; ~/Desktop/working_links/dan1 lrwxr-xr-x  1 stuffe  staff  28  8 Dec 10:08 dan2 -&gt; ~/Desktop/working_links/dan2 lrwxr-xr-x  1 stuffe  staff  40  8 Dec 10:06 dan3 -&gt; /Users/stuffe/Desktop/working_links/dan3 lrwxr-xr-x  1 stuffe  staff  46  8 Dec 10:21 dan4 -&gt; /Users/stuffe/Desktop/outofscopedeadlinks/dan4 /code/pre  <comment132820> Thank you for this, however when I try to run the script as indicated, I simply get `Run: Command not found` <comment132823> Well, you only need to type the rest of the line (starting with the period) <comment132827> I learned some new `bash` syntax from this one. So an upvote for that! Thanks! <comment132829> Oh!  OK now it ran.  Didn't appear to do anything though... the symlinks do have a new timestamp, but they're still broken as before.  In trying to understand your code, I'm not clear on how it's doing the string replace on the old name to change it to the new. <comment132830> The more modern `bash` way to grab output from commands is to use the `$(command)` syntax like `for MYVAR in $(ls | grep somefilter)` instead of using backticks. It has some advantages over backticks like [this](http://stackoverflow.com/questions/2657012/unix-how-to-properly-nest-bash-backticks). I made edits based on this. <comment132831> It's in the `new_path=` line. If you add a real sample of your old and new path I can adjust the script accordingly. <comment132833> It's not a git to parse correctly in SE markdown either ;) <comment132835> Ohhhh I'm supposed to change that bit.  Thought somehow it was dynamic LOL  I'll adjust and post back if I still have any trouble <comment132836> Hot diggity that worked perfectly!!  Thanks so much for the simple and elegant script!
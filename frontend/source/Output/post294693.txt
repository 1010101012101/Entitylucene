Split csv file using Automator Service (Finder Context Menu) <body> I am trying to create an Automator strongemService/em/strong for strongFinder/strong's Right-Click Context Menu that can split any selected csv file, whilst copying in the original header at the top of every file.  My current attempt is to make Automator run this Bash Shell Script:  precode#!/bin/bash  FILE=$(ls -1 | grep MY_CSV_FILE.csv) NAME=${FILE%%.csv}  head -1 $FILE &gt; header.csv tail -n +2 $FILE &gt; data.csv  split -l 50 data.csv  for a in x??     do         cat header.csv $a &gt; $NAME.$a.csv     done  rm header.csv data.csv x?? /code/pre  This script will split codeMY_CSV_FILE.csv/code into new files with max 50 lines while copying in the original header at the top of every file. The new files will have the original name appended with codexaa/code, codexab/code, codexac/code etc.  Regarding the Automator setup, this is the Service I'm currently working on. The problem right now is that I'm unable to pass the Selected File in Finder to the Bash script.   img src="https://i.stack.imgur.com/GqElv.png" alt="enter image description here"  Notice that:  ul liService receives: emfiles or folders/em in emFinder.app/em./li liPass input to Shell script: emas arguments/em./li liI have removed code#!/bin/bash/code from the top of the Shell Script and set the Shell to: em/bin/bash/em./li liI switched codeMY_CSV_FILE.csv/code for code"$f"/code â€“ not sure if that's correct./li /ul  Do I also need to specify the path using something like code"$@"/code for both the input file and the resulting output files? I haven't done something like this before, so I'm not really familiar with that variable and code"$f"/code for that matter.  How could I make this work? I'd like the resulting files to appear in the same folder as the file I select to run the Service on, via the Finder Right-Click Menu. It would be even better if the Service only accepted csv files.  img src="https://i.stack.imgur.com/HMb2e.png" alt="enter image description here"  <answer294966> I'd write the emcode/em a bit differently, and here is an example of how I'd do it:  pre class="lang-none prettyprint-override"code#!/bin/bash  for f in "$@"; do     if [[ -f $f ]]; then         d="$(dirname "$f")"         n="$(basename "$f")"         t='/tmp'         if [[ ${n##*.} =~ [cC][sS][vV] ]]; then             head -1 "$f" &gt; $t/h.tmp             tail -n +2 "$f" | split -a 3 -l 50 - $t/tmp.             i=1             for s in $t/tmp.a??; do                 fn="$d/${n%.*}.$(printf '%03d' $i).csv"                 if [[ ! -f $fn ]]; then                      cat $t/h.tmp $s &gt; "$fn"                     ((i++))                 else                     rm $t/h.tmp $t/tmp.a??                     echo "The file '"$fn"' already exists!"                     exit                 fi             done             rm $t/h.tmp $t/tmp.a??             echo ''         fi     fi done /code/pre  ul liAs presently coded, it handles one or more emfiles/em passed to the emservice/em./li liMakes sure the emobject/em being acted upon is a emfile/em, not a emdirectory/em./li liMakes sure the emfile/em has a em.csv/em extension (regardless of the case of the extension)./li liCreates the emtemporary files/em in: code/tmp/code/li liChecks to see that the emoutput filename/em doesn't already exist, and if it does, it cleans up and exits./li liWrites to a emfile/em with a emnumerically incremented filename/em, e.g. codefile.001.csv/code, codefile.002.csv/code, etc., in the same emdirectory/em as the emfile(s)/em passed to the emservice/em./li liRemoves the emtemporary files/em created in: code/tmp/code /li liAs presently coded, it handles emfiles/em with a emline count/em of up to 49,950 split to 50 line files, not counting the header.  ul liNote that no error handling is coded for the total line count of the emsource file/em, however, could be easily added./li liOr easily modified to handle emfiles/em with a emline count/em of up to 499,950 split to 50 line files, not counting the header, by changing code-a 3/code of the codesplit/code emcommand/em to code-a 4/code and code'%03d'/code of the codeprintf/code emcommand/em to code'%04d'/code. You'd also change code$t/tmp.a??/code in br codefor s in $t/tmp.a??; do/code and coderm $t/h.tmp $t/tmp.a??/code to: code$t/tmp.a???/code/li /ul/li /ul  I'd also add a strongRun Apple Script/strong emaction/em to the emservice/em, with the following emcode/em:  precodeon run {input, parameters}     if (item 1 of input) is "" then         display notification "Splitting of the target file(s) is finished!" with title "Split CSV File(s)"     else         display notification (item 1 of input as string) with title "Split CSV File(s)"     end if end run /code/pre  This enables the emoutput/em of the codeecho/code emcommands/em in the strongRun Shell Script/strong emaction/em to display a notification if a emoutput file/em already exists or when the splitting is finished.  Note that while notification could be done from within the strongRun Shell Script/strong emaction/em using codeosascript/code, nonetheless, I did it this way as it was easier to code.  hr  img src="https://i.stack.imgur.com/eAATs.png" alt="Automator Service Workflow"  This was tested on a emfile/em named emfile.csv/em in strongFinder/strong, which has 200 lines in it, and the images below show what was created by the strongRun Shell Script/strong emaction/em portion of the strongAutomator/strong emservice/em when run on the emfile/em.  img src="https://i.stack.imgur.com/MQFT6.png" alt="CSV File in Finder"  img src="https://i.stack.imgur.com/P6cBz.png" alt="Contents of split CSV File in TextEdit"  <comment372258> Can you [edit](https://apple.stackexchange.com/posts/294693/edit) your question to clarify what it is about your attempted approach that isn't working? That is, do you get an error? Or does it work, but just not in the way you want? Or is it that you'd like it to do something in addition to what it's actually doing now? Something else? Also, can we assume the actual Shell Script you're referencing works, or is that your problem? <comment372274> Bravo, this is very impressive work and a massive improvement on the original script. There's a lot to unpack here so I will have to do it in due time, but I can confirm that the Service works great upon first tests. Out of curiosity (not need), is there a reason to code for 49,950 instead of 499,950 lines, e.g. performance? I will probably never need the latter, but interesting to learn. <comment372275> @Monomeeth A very valid point, sorry about that. Running the service gave a macOS error box saying "Shell script error" or something like that. It didn't accomplish anything close to success. I didn't see any specific code error in Automator. It also seems to have created a file called `x??.csv` in my user folder (`~`). <comment372309> @Winterflags, There is almost always more then one way to do something and why I started off with "_... here is an example ..._". With the code of the OP, the split filenames were going to be incremented by the _value_ of `$a`, i.e. `x??`, e.g. `xaa`, `xab`, etc. It's a personal preference for me, I want a numeric value in the split filenames, so I coded it for that. In the code of the OP, `for a in x??` would have failed if the source file had _line count_ more then 49,950 split to 50 line files because `x??` only accounts for 999 files where `x???` accounts for 9999 files. <comment372310> @Winterflags, Both the code in the OP and my code suffer from the same hard coded limitation, because as coded both assume there will not be more the 999 files create by the `split` _command_ So, either the _pad_ has to be large enough to accommodate without doing the math first or the math can be done first and coded to dynamically accommodate. It's less coding to adjust the _pad_ then checking the line count first. If you want to ensure a very high number of lines then increment the values even higher then as noted in my answer so the _pad_ is more then adequate. <comment372311> @Winterflags, Changing `-a 3` of the `split` _command_ to `-a 5`, and `'%03d'` of the `printf` _command_ to `'%04d'` and `$t/tmp.a??` in  `for s in $t/tmp.a??; do` and `rm $t/h.tmp $t/tmp.a??` to `$t/tmp.a????`, will handle files with a line count of up to 4,999,950 split to 50 line files. To make it even easier, `$t/tmp.a??` can be set to `$t/tmp.*` and then you'd only have to modify `-a 3` of the `split` _command_ and `'%03d'` of the `printf` _command_ setting each to a higher number, e.g. `-a 8` and `'%08d'` will handle files with a line count of up to 4,999,999,950 split to 50 line files. <comment372312> @Winterflags, The primary point is, I wanted you to know there was no error handling around this and how to adjust what to account for it. While I did say "_... however, could be easily added._" that really should have been "_... however, could be added._" and why changing the values as mentioned is actually the easiest thing to do.
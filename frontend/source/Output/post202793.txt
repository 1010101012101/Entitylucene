Terminal: command to show application folder <body> I recently discovered that I can open application from Terminal like this:  precode$ open -a TextEdit /code/pre  Is there any command that would just show the application folder instead of opening it? Such that I could do this:  precode$ alias vmrun=\"`some-command 'VMware Fusion'`/Contents/Library/vmrun\" /code/pre  I need that codesome-command/code to print the folder of VMware Fusion application.  UPDATE: I don't know where the application is installed, otherwise I could just hardcode it in the script  <answer202800> You have to add:  precodealias vmrun='/Applications/VMware\ Fusion.app/Contents/Library/vmrun' /code/pre  to your code~/.bash_profile/code, save the file and source code~/.bash_profile/code. In the future you just have to type codevmrun/code to launch the tool.  If you need quick access to any more commands from this directory you can add:  precode:/Applications/VMware\ Fusion.app/Contents/Library/ /code/pre  to your path.  <answer202820> I believe this is what you're looking for:  precodealias vmrun=\"`osascript -e 'tell application "Finder" to get POSIX path of (application file id "com.vmware.fusion" as alias)'`/Contents/Library/vmrun\" /code/pre  Now when I type codevmrun/code, without any arguments, in a strongTerminal/strong and press kbdEnter/kbd it outputs the internal help file, as it should.  This works on my system, however it returns the first occurrence of the "VMware Fusion.app" application bundle's path.  I have four different visions installed, so this would not be ideal in my situation, although for those that only have one version installed it works.  <answer202823> I have just created and uploaded a GitHub Gist GitHub Gist which may help you out.  The main functionality is:  precodefunction get_apps_folder () {      mdfind -0 -onlyin / \         'kMDItemKind=="Application" &amp;&amp; kMDItemDisplayName="'"${1:-TextEdit}"'"' \     | xargs -0 -I{} dirname {}  }  function open_apps_folder () {     open $(get_apps_folder "$1") } /code/pre  You could take that and add the two functions to your code~/.bash_profile/code and they would be available for any interactive shell sessions you are using. (And yes, getting around mixed and embedded single and double quotes can be messy.) :-)  But, to give a better explanation, the main part is:  precodemdfind -0 -onlyin / 'kMDItemKind=="Application" &amp;&amp; kMDItemDisplayName="VMware Fusion"' | xargs -0 -I{} open {} /code/pre  The code-onlyin /path/code limits the search to just the root volume, otherwise any “Spotlight-searchable” volume attached will most likely be searched as well, including Time Machine, which can get unwieldy and/or verbose, hence using code-onlyin //code.   In the Gist, each line output by codemdfind/code is fed to codexargs/code which calls codeopen/code on what is passed to it. Note that there is no particularly robust checking of what is passed to codexargs/code (ie. it is assuming it is getting a directory).  codemdfind/code and codemdls/code can be pretty handy for things like this, although they can take a little getting used to. I usually use codemdls /path/to/file/code to get an idea of what metadata that type of file has. I can then take those keys and values to search using codemdfind/code. You can find a lot of pages, examples and documentation out there, BTW.  <answer202841> Two quick and easy options:  ol liYou can use Spotlight (codemdfind/code) via command-line for high level items:  precodeappLocation=$(mdfind Fusion.app) echo $appLocation /Applications/VMware Fusion.app /code/pre/li liOr if you use the codelocate/code binary (pre-requisite command to enable it will be noticed first time you use it).  precodeappLocation=$(locate vmrun) echo "Found at " $appLocation Found at /Applications/VMware Fusion.app/Contents/Library/vmrun /code/pre/li /ol  <answer202858> hr  Just type:    precodemdfind &lt;target_file_name.ext&gt; /code/pre  If there are any matches, you will be presented with the relevant associated path(s). If there's more than one, choose whichever is appropriate and hardcode it.  hr  For example:    precodeme@MacBook-Pro:~$mdfind "VMware Fusion.app" /opt/homebrew-cask/Caskroom/vmware-fusion/7.1.2-2779224/VMware Fusion.app /code/pre  hr  Or more likely, one of these:  precodeyou@MacBook-Pro:~$mdfind "VMware Fusion.app" /Applications/VMware Fusion.app /Users/you/Applications/VMware Fusion.app /code/pre  hr  <comment244647> While shell functions are nice, and I originally though he'd have to use a function over an alias (conversion since been deleted), nonetheless I believe my solution is in the format that tair expressed he wanted.  Also, he is not wanting to open the VMware Fusion application via a function, he's wants to set an alias to the `vmrun` executable which is not the same as the VMware Fusion executable. <comment244652> La di da and too-rye-ay. <comment244674> Regarding 'first occurence' -- at least consistent with `open -a my.app'. <comment244679> What's the bigger picture of your script? As far as I understand it `vmrun` entered in Terminal should control an arbitrary VM and VMware Fusion or even several different versions are installed in arbitrary folders (which usually isn't the case because the default installation folder is /Applications/). <comment244680> @tair Do you want to hardcode it? i.e.. Are you more concerned with finding `some-command` ***or identifying the true path of*** `/VMware\ Fusion.app/`? <comment244682> @tjt263 I want it to be script-friendly and maintainable <comment244713> @tair that doesn't really answer my question.. do you just want to find the directory where the *.app resides so you can hardcode it? or would you prefer something dynamic like a command / variable? <comment244718> Ok, I see your point. The script should be portable from mac to mac, IOW should not depend on a path of application on a particular mac <comment244725> okay well what if you had the script ask the user for input? It could check the common default locations like `/Applications/` and `~/Applications/` and prompt them for the correct path if not found. <comment244727> Oh, that would be overengineering.. It is enough to have behavior consistent with `open -a ...` <comment244760> @tair ok so do you have a solution? Or are you still working on it? <comment244786> Let us [continue this discussion in chat](http://chat.stackexchange.com/rooms/27662/discussion-between-tjt263-and-tair). <comment244955> @jps3 Interesting. I think I like this answer the best, even though I'm not entirely sure that I fully understand it. <comment245016> Nice. So is that AppleScript? I've never actually used it before.. or seen anything quite like it.. +1 <comment245024> @tjt263, Yes, part of that is, from the CLI or in a Shell Script, not necessarily  the normal Apple Script that is done in the Script Editor (previously named AppleScript Editor).  In other words running AppleScript from the CLI or in a Shell Script it uses `osascript` to process the code.  From the Editor things are a bit different and there is plenty of AppleScript on the Internet if you what to see what it looks like when run in the Editor or even AppleScript added to Automator. <comment245025> @user3439894 yeah cool so running `osascript` is sort of like running `python` then, for instance? <comment247835> @tjt263 exactly. But I personally don't like it too much, because everytime I try to do something with AppleScript I struggle with lack of documentation <comment247840> @tair interesting though, it looks like pseudo-code. I suppose the idea is probably that it's meant to be intuitive and easy for non programmers to grasp or something like that. In the meantime, I realised I had an old book on the shelf with a chapter on Automator, AppleScript, & bash integration. Might have to look into it. <comment247857> If that first example works for you; try: '`open $"(mdfind Fusion.app)"`' <comment247860> Or: '`$"(mdfind Fusion.app)"/Contents/Library/vmrun`'
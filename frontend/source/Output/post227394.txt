Cause of Unix Epoch time integer underflow? <body> By setting the time on 64-bit iDevices to January 1, 1970 (Unix Epoch time 0) and rebooting it, the iDevice becomes bricked because of an integer underflow. My question is about which operation actually causes the crash:  Method 1: You called someone at Epoch time 1455403324, this number is saved for timestamp calculations to see how long ago you made the call. You now change the time to 1/1/1970. 5 minutes have passed and your Epoch time is now 300 but a timestamp calculation for your last call is executing and the equation is 300 (current time) - 1455403324 (time you last called) which is a negative value, causing the integer underflow (assuming the timestamp integer is unsigned, which wouldnt make sense if it wasnt because just like the assumption with the actual epoch time value, how is it possible for someone to have called another x minutes in the future?)?  Method 2: As someone stated before, "In some time zones, setting the date to 1 Jan 1970 will set the internal clock to a number less than zero, as the time is stored in GMT (as the number of seconds since midnight on that date) and then the offset is applied before display," wrote by https://www.reddit.com/user/redion1992. "In other time zones, setting the clock will result in a positive time value. Best guess is that this is triggered by having the time value less than zero."  Are they both valid or one or the other?  <answer227412> Almost confident it's not due to an integer overflow, but instead a time based signature which is used in the security mechanisms of iOS, like the SEP.   <answer227439> This is both not the cause of your issue. iOS works with something called codesigning. Apple writes and compiles their code, then cryptographically signs it in order to prove its authenticity. This is done with certificates. Certificates usually have two date values.  ul liThe one typically stumbles about when using the internet is the emend date/em. If your time is past that date, the certificate is no longer valid and whatever you're trying to verify won't verify./li liThe other one is the emstart date/em which tells the computer when the certificate begins its validity period./li /ul  The iPhone and its current version of iOS have not been around in 1970. When you boot the device it does an integrity check of the system, using those certificates. If you set the system date to a point in time before the start date of the certificate with which the system is signed, it simply can't pass the check.  See this twitter exchange: https://twitter.com/JZdziarski/status/698244919698333696     strong@JZdziarski/strong: One thing people donâ€™t realize is iOS/OS X have to have a valid time in order for code sign certificates to be valid.br   strong@Ghostlyrics/strong: @JZdziarski I don't see how this is an issue given that it does NTP (or similar) by default?br   strong@JZdziarski/strong: @Ghostlyrics because if Apple's own certificates aren't valid, ntp can't run.   <comment276209> This should not be voted down. <comment276217> But then, this bug should happen with any date before the release of the iPhone... <comment276261> This question cannot be answered by anyone who doesn't have access to the iOS codebase.  All answers that have been submitted so far are pure speculation and not appropriate for Stack Exchange.
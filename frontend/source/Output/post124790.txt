What is the Mac equivalent of Windows "start" command? <body> I'm creating a script that runs several other scripts.  I need them to all start up in their own process (read window) so I can review the output of each, but I also need them to run in parallel, so they can't block each other.  In addition, I need to change the current working directory for each process, so doing something like the following isn't working:  precodeosascript -e 'tell app "Terminal" to do script "someScript.sh"' /code/pre  <answer124791> pre osascript -e "tell application \"Terminal\" to do script \"cd $(read); ~/path/to/someScript.sh\"" /pre  should work. You can replace $(read) with a variable.   <answer124797> FYI, generally speaking, the equivalent of Windows's codestart/code is codeopen/code (man). In their simplest usage, they're each the command-line equivalent of double-clicking something in the graphical shell. codeopen/code may not be involved in the most efficient means of doing what you're trying to do in this case, however.  <comment146039> You could do this in one widow and multiple processes if the subscript just use standout for their output - the calling script can redirect the outputs to a different file for each script <comment146045> My attempts to use `open` to run a shell script instead cause it to open in a text editor.  Perhaps you could provide an example command-line statement for this? <comment146047> You generally wouldn't `open` a script to run it, because 1) if you're already in a terminal you can just execute it (e.g. `cd dir_containing_script; chmod +x script_filename; script_filename;`—note that the `chmod` step only has to be done once per script), and 2) as you've discovered, by default double-clicking a shell script in Finder doesn't execute it—it opens it for editing. You could however use `open` to send the output of a script into a GUI app. For example, send a script's stdout into a new document in your default text editor with `script_filename | open -f`. <comment146049> Note that you would've already had to mark the script as executable with `chmod +x` for that last example to work. <comment146070> Adding on to @TerryN's answer, the `open` command has additional options that allow you to explicitly specify what application does the opening. RTMP. <comment146082> I should clarify that when I said above that you can use `open` to "send the output of a script into a GUI app", I was speaking somewhat loosely. I didn't mean to imply that it does so by piping to the .app's stdin. As described on the man page (in the examples section), `open -f` works by writing to a temp file and opening that file with the target app. Unfortunately, that behavior seems to be offered only for TextEdit and the default text editor.
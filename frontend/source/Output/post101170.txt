Why do I need to put sh before running .sh files? <body> When I want to run code.sh/code files in Terminal, I need to put codesh/code in front of them.  Is there any way to avoid this, and thus save typing?  <answer101171> You don't need to call codesh/code if the script file is marked as executable. In that case, you can call it my name just like you would any other command from the existing shell.  hr  To be fully proper, you'll want to do two things:  ol liEdit your script to include a shebang directive at the top of your script:  code#!/bin/sh/code  ... That would tell the shell which interpreter to use to run the script; in this case, the code/bin/sh/code executable./li liMark the script as emexecutable/em by you with the chmod command:  codechmod u+x scriptname.sh/code/li /ol  Once you do both of those, you should be able to run your script by typing your script's file name on the command line.  You'll need to be in the same directory as your script, unless you also take the added step of adding the containing folder to your PATH variable. If you don't care what shell runs the script, you don't need step one to specify codesh/code but it's often better to be precise and set the "shebangsh".  <answer101180> If you're running your script from the shell, you don't actually need the code#!/bin/sh/code shebang as outlined in this this answer–every Unix-like system I've used, including OS X, will default to code/bin/sh/code if no interpreter is specifically specified (though it's a good idea as non-shells won't know how to execute your script unless you give the shebang.)  You also don't need an code.sh/code extension.  You emdo/em need to set executable permissions, e.g.  precode$ chmod +x script.sh /code/pre  em(The code$/code is the shell prompt; I'm using it to illustrate commands you give to the interactive shell.  Don't type it!)/em  However, I think what your confusion is is that you have created a script, e.g. codescript.sh/code, in the current directory, and are trying to execute it by simply typing codescript.sh/code.  e.g.  precode$ cat &gt;script.sh echo hello, world ^D $ chmod +x script.sh $ script.sh -bash: script.sh: command not found /code/pre  em(code^D/code means kbdcontrol/kbd-kbdD/kbd.  You will find this notation in many writeups on using Unix.)/em  The fact that codescript.sh/code in this case is a shell script is only half the problem; your actual issue is that, by default, the shell will not search the current directory for a program.  However, this works:  precode$ sh script.sh hello, world /code/pre  because codesh/code is taking the script as an argument.  You can execute a script–or, again, emany/em executable–in the current directory, if it is marked executable (i.e. codechmod +x/code), by specifying that you want to run the one in the current directory:  precode$ ./script.sh hello, world /code/pre  You can also move the script to a directory on your codePATH/code.  I recommend code/usr/local/bin/code for this if your script is intended to be used system-wide, or a codebin/code directory in your home if the script is only for you.  The latter requires you to add code$HOME/bin/code, which expands to your new bin directory, to your codePATH/code by adding the following lines to your code.profile/code in your home directory:  precodePATH=$HOME/bin:$PATH export PATH /code/pre  Finally, you can, if you want, actually add the current directory to your codePATH/code, which will allow you to just go to a directory containing codescript.sh/code–or any other executable–and type  precode$ script.sh /code/pre  to execute it.  However, strongI do not recommend this practice/strong, as an attacker can now trick you into running an arbitrary executable by dropping an executable script (named, say, codels/code) into a directory you will be in.  If you emreally/em want to do it, though, just add the following to your code.profile/code:  precodePATH=.:$PATH export PATH /code/pre  <comment119103> Shebangs are not actually necessary for `/bin/sh`, though they don't hurt. <comment119109> I made a folder at ~/bin to put my shell scripts into and put it on my $PATH and also attached a Folder Action to the ~/bin folder to automatically set the execute permissions because that is so easy to forget to do. <comment119118> @zigg - You are correct. I hope Chris doesn't mind my edits… Nuke or re-edit as desired :-0 <comment119119> Also - very good info - thanks @zigg <comment119122> @bmike The edits work for me.  As for the shebangs, my habit was to always specify because I used to write a lot of `ksh` scripts back in my days on HP-UX -- but it's good to know that it isn't strictly necessary. <comment119125> I think I need to back away from my earlier statement about shebang necessity (though the rest of my answer still stands.)  You can run a shebang-less script from a shell, but if you use an `exec` syscall, you get `ENOEXEC` (exec format error).  Sorry about that, @bmike, @ChrisW.Rea.  I'm going to go edit my answer now. <comment119477> Put the '.' at the end of the $PATH instead of the beginning and now you don't need to worry about a phantom 'ls'. (Although if someone can get into your system, you've got bigger issues.) <comment119479> @TJ, but you *do* need to worry about stuff like `sl` or `lls` or `l`... i.e., typos. Just leave `.` out of `$PATH`. Also, you may not (or should not) necessarily trust everyone on your system. For example, suppose there's some exploit that allows an attacker to drop an arbitrary file into some directory, but they need *you* to execute that file in order to escalate to a better exploit (e.g., collect data and phone home). Defense in depth! <comment119482> @TJLuoma What @Reid said, plus keep in mind that there are many use cases for a Unix system beyond a personal OS X desktop. Haven't tried it, but I bet even the guest account could leave one of those items in `/tmp` or some other world-writable directory. <comment119633> If you are using a system where other people have access to directories you use, you've got larger issues. <comment119642> @TJLuoma You'd best never use multiple accounts on any Unix system, then.  `/tmp` et al. come with the territory. <comment119745> @zigg - I tried this on a shared hosting account. I made a /tmp/ls, made it chmod 755, & tried to run it. Won't run. I put '.' at the start of my PATH, went to /tmp, tried 'ls' & didn't get the fake one. "The typo trojan in a globally writeable directory" is basically a scary story for sysadmins to tell around a campfire. The malicious user has to count on me being in that directory, use the same typo they guessed. Possible? Statistically, I guess. So is winning the lottery. (`ps auxwww` also doesn't show me other users' commands, so you could put passwords as args without others snooping it.) <comment119749> @TJLuoma I'm done. Deny all you want. I can't even guess what's going on in your shared hosting environment, but the `/tmp/ls` trick definitely works on OS X with the default bash shell (which is, after all, what we're talking about here) and it remains a bad idea, no matter how you wish to attempt to characterize it. <comment119861> @zigg - OK, so first you want to talk about "any Unix system" and now you just want to talk about OS X. Got it. Yes /tmp/ls works on OS X. However, what percentage of Mac users are the only ones who ever log into their Macs? I'm going to guess maybe 98%. They will never run into a Typo Trojan. And even if they did, it's still a matter of the Malfeasant picking the exact typo in the exact globally-writable directory where I happen to make it. Which is basically /tmp/. Your claim that it is, universally, "a bad idea" is true only in an abstract, theoretical sense best named a Unix Urban Legend.
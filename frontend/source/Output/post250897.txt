Results of find cannot be encapsulated in quotes <body> On Linux, handling spaces when I am using the results codefind/code only requires wrapping the variable in quotes. This doesn't work on OS X. This code, for example, doesn't work:  precodefor file in $(find . -name "*.txt") do     ls -l "${file}" done /code/pre  Even wrapped in quotes, parts of file names separated by spaces are treated as their own result. How do I fix this?  <answer250936> Your code doesn't work on OS X or Linux.  precodefor file in $(find . -name "*.txt") do     ls -l "${file}" done /code/pre  First the shell performs the expansion of the command substitution code$(find . -name "*.txt")/code The results resemble the following- codefile with spaces\nanother file with spaces/code and so on. Now, the shell performs codeword spitting/code based on the value of codeIFS/code- the internal field separator. The value is usually white space, tab, and newline.  Run the following code:  precodefor file in $(find . -name "*.txt") do     echo "${file}" done /code/pre  Now let's change the codeIFS/code to just the newline character.  precodeIFS=' ' for file in $(find . -name "*.txt") do     ls -l -- "${file}" done /code/pre  Your code will work though I advise you not to change codeIFS/code and find alternate solutions.  Both GNU find and BSD find are very robust and can handle file names with spaces. You can avoid the loop and get similar results with one line  precodefind . -name "*.txt" -ls /code/pre  <answer251020> From Bash Pitfalls (which also explains in detail why codefor file in (find ...); do/code doesn't work):      When using find use it properly eg. use -exec  precodefind . -type f -exec some command {} \; /code/pre      Instead of codels/code consider,  precodefor i in *.mp3; do    # Better! and...     some command "$i" # ...always double-quote expansions! done /code/pre      POSIX shells such as Bash have the globbing feature specifically for this purpose -- to allow the shell to expand patterns into a list of matching filenames. There is no need to interpret the results of an external utility. Because globbing is the very last expansion step, each match of the *.mp3 pattern correctly expands to a separate word, and isn't subject to the effects of an unquoted expansion. (If you need to process files recursively, see UsingFind.)      Question: What happens if there are no code*.mp3/code-files in the current directory? Then the for loop is executed once, with codei="*.mp3"/code, which is not the expected behavior! The workaround is to test whether there is a matching file:  precode# POSIX for i in *.mp3; do     [ -e "$i" ] || continue     some command "$i" done /code/pre      Note the quotes around $i in the loop body above.   <comment311733> Can you use `find . -name "*.txt" -exec ls -l {} \;` instead? <comment311816> 1. You left `=` out of `IFS'`, that line should be `IFS='`. 2. There is nothing wrong with changing `IFS` if done properly, i.e. set current `IFS` to a variable, modify `IFS` to suit the need in the code and then reset it from the variable and continue. 3. Also, while `find . -name "*.txt" -ls` does work, it does not output the same expected output of running `ls -l` by itself does and why I suggested, in my comment to Melab, using `find . -name "*.txt" -exec ls -l {} \;` instead of a loop altogether. <comment311891> Don't use a `for` loop to process `find` results, use `find ... -exec ...` instead (and, in complexer cases, write a shell script for the code to be executed). <comment312000> Also if you're changing IFS to equal a newline, consider writing it as `IFS=$'\n'` <comment312045> @user556068 And what advantages does ansi quoting have over the other methods of changing IFS to newline? <comment312234> For me personally it is clearer what the intent is with `$'\n'` than the other method of making a literal newline. And it requires less space to write. Granted it is only a difference of one line in this case but every little bit counts. <comment312249> @user556068 Fair enough. The way I wrote it is POSIX compliant. While the ansi c style quoting has been accepted to become part of the POSIX standard (not there yet), some shell's do not understand it. In particular, `dash` and some versions of `ash`.  Personally, I like `IFS=$(printf '\n')` . Anyways, that was only a demonstration. You should never write a loop like that. <comment312297> "Both GNU findâ€¦" You just said that the code does not work on Linux.
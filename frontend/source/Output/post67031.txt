Isn't Inactive memory a waste of resources? <body> I'm looking for explanation of memory usage on my machine especially in light of the example in this screenshot below:  img src="https://i.stack.imgur.com/3WIAq.png" alt="Memory Usage"  I understand what is codeFree/code and codeActive/code meansbr But what are the meanings of codeWired/code and codeInactive/code?  Especially codeinactive/code, why does it use so much memory for something that we do not use?  <answer67048> Inactive memory gets a horrible rap due to a crappy name. It should be called "make your Mac really fast the second, third, and fourth time it does the same task" memory except that's an awful name, too.   Here's how I explain things to someone new to the concept of virtual memory:  ul liWired: The system cannot run without this amount of RAM (never swapped)/li liActive: Programs are really using this memory now or in the last few seconds/li liInactive: Things that programs have read from the slow disk or elsewhere and said they never need again. emEngineers know better, you will go back to Facebook in a few minutes or re-launch Word after quitting it. The same things happen again and again on computers./em/li liFree: strongTotally Wasted RAM/strong - the system only needs one or two MB free to cover short term allocation requests. For largest allocations, it simply uses some of the Inactive RAM by allocating it to active/wired and removing the information on what it used to hold./li /ul  The problem arises when Free+Inactive is less than roughly 1/3 of the total and then things can really get slow.   strongInactive memory is bonus speed / double duty RAM./strong It serves as free at a moment's notice, but also makes repeated tasks much, much faster if the system guessed correctly and kept something in RAM that you will do again. It's faster than swapped memory since it's already loaded in RAM and accelerates things when the virtual memory system makes good guesses.   When you are wondering if RAM is a problem, rather than looking at each of the 4 categories (5 if you count active swap), you can couple W+A as slowing down a new program/task and F+I as speeding up a new program/task. The more F+I you have, the more new programs you can launch before the RAM needs to rely on swapping to juggle the memory that has been allocated.  You don't really need to know how swap works since I mentioned it above. Basically, when a program is sitting idle and hasn't been used for days (or hours) the system will write that RAM to the hard drive rather than kill the program. This lets the system shuffle and handle all sorts of things relating to memory management and keeps each program from needing to talk amongst themselves to agree who will use less memory when the system runs out.  Here is a real world example of how inactive RAM is used.  ol liQuit all apps and make sure the two Apps we are testing are not set to auto start when you log in/li liReboot your Mac/li liFire up your Activity Monitor and watch the RAM throughout/li liTime how long it takes to start Application A (MS Word would be a good choice)/li liQuit A/li liTime how long it takes to start Application B (Adobe something would also be good)/li liQuit B/li liTime how long the second launch of A takes/li liQuit A/li liTime B's second launch./li liTime A's start the third time with B running./li /ol  You should see dramatic speedups for the second / third launch as the system learns to keep in inactive RAM the things these two apps need to run.  hr  In your case - the total of Wired and Active means that some swapping to disk is likely happening and your Mac isn't as fast as it could be since your inactive RAM isn't large enough to store all the things you might need to reuse. If you have a fast SSD drive, this RAM allocation is OK and instead of starting to slow down once less than 1/2 of your RAM is F+I, you can cut things closer to like 1/4 of the total RAM for F+I before seeing noticeable slowness. These guidelines are general, and you'll want to watch codevm_stat 15/code or some similar interval to ensure continual and medium volume swapping isn't making your Mac slow.  <answer80637> Basically it's broken.  Inactive RAM should be "purged" automatically when Free RAM is low.  What's the point of holding RAM for previously opened applications hoping that the user will open it again?  The fact that Free RAM is low indicates that existing ACTIVE applications might not have enough RAM and is swapping NOW.  Keeping GB of RAM for closed applications is just dumb. According to Apple's own description, Inactive RAM should be purged or borrowed automatically when Free RAM is low. This is clearly not the case.  <answer97195> The problem on my Mac is the "inactive" memory never seems to get purged unless I do a manual purge in the command window. It builds up and builds up until I get a popup window telling me to kill applications. Even after killing all my applications, I still have too much inactive memory to run anything. So, on my Mac running the latest version of Mountain Lion it is NOT true that inactive memory gets reclaimed when the free memory gets low. Either I have an app somewhere that has locked up a chunk of inactive memory that never gets freed, or the iOS has a bug in it. (I have 8GB of physical memory ... that ought to be enough!)  <answer106990> The number which is strongthe most important/strong in determining if your Mac is getting memory 'stressed' is the 'Page outs' figure. In Activity Monitor in Mavericks this is no longer shown, they now show the information in 'Swap Used:'.  Page outs means the OS has determined there is not enough available RAM to run all the applications &amp; processes which have been requested. What it then does is it 'pages' out to disk parts of memory which it determines are not being actively used. This means RAM memory (fast) is changed to HDD memory (slow). If this is happening a lot because there are a lot of applications running, and the user is going between applications, then there will be a lot of page outs, and page ins.  If you see page outs increasing then you should take action.  <answer107263> Inactive memory in essence, makes opening up formerly closed processes faster. If you find that the Mac OS is taking up too much memory you don't really need like from the dozens of tabs you opened on Safari or Chrome just use the 'purge' command in the Terminal. In OS X Mavericks just use 'sudo purge' instead (you will need to input your password). It shaves off precious seconds when you need to open something up again, but if you want to play a RAM intensive game or open a RAM hungry application I definitely suggest using the purge command.     <answer141102> Thanks to all the posters and commenters, this has been a instructive and useful thread for me. My recent experience might be useful to someone.  I use my Mac Mini with OS X10.8.1 and with 16G RAM entirely for prototyping software that will be run elsewhere.  I can assure you that I will not "go back to Facebook in a few minutes or re-launch Word after quitting it"--I do that on my macbook instead.   My task was to munge up a large bunch of data, i/o is time consuming, so the notion is to read as large a chunk of data to ram as possible at one swoop, process it there, and then write it back to disk, then repeat the process until done, which takes some hours. What I see is that every time I read in a new chunk of data, the inactive memory jumps--I suppose that the system AI assumes that I might want to use the old chunk again, which I don't--and the free memory drops.    After a few iterations of this process the free memory gets down to a just a few MB, the inactive memory will free up a few more MB, and then eventually after some minutes of quibling back&amp;forth between free and inactive memory, the inactive memory will free up a few GB at once.  All is as @bmike describes, and both vm_stat 15 and Activity monitor show 0 page-outs.  Except maybe not quite.  Several times things have been moving along swimmingly, I head off to have a coffee or dinner and am not monitoring the process, and what shouldn't happen happens and the process suddenly throws off a boatload of page-outs and slows way down.  Stipulate that it's probably my crappy code that's causing the problem but I wish I could turn off the inactive memory just to eliminate that source of variability. Is it broken? I wouldn't say so at all, but I would say that I guess the memory management is not optimized for my use case.   <answer213943>    strongInactive memory/strong used by recently active and quit apps. OS X keeps it reserved in case the user wants to open the program again. In it happens, OS X does not need to relocate memory that accelerates performance speed. If you do not re-open the program, after a while the memory of the inactive will be freed or relocated.(c)   This feature is cool when you have a lot of RAM, but when it's not it's quite annoying. Actually it's all about apple stuff. When you have powerful gadget or Mac everything is cool, but when when you device become older all features slows it.   So u have to use special tricks to manage it.   For inactive memory there is a command codepurge/code to free it.  <comment78975> possible duplicate of [What is the meaning of Wired Memory in Macbook?](http://apple.stackexchange.com/questions/36063/what-is-the-meaning-of-wired-memory-in-macbook) <comment78981> See http://support.apple.com/kb/HT1342. <comment79032> Wow very complete answer for newcomer like me. Thank you very much, very appreciated :) <comment79034> Yup - I get to answer for everyone - once and for all, people can edit it to make it better and you get your answer. Pretty cool idea for a web site where people can come and ask interesting questions. :-) <comment79037> Wow! Beautiful answer! <comment79038> I didn't find a question where the nub was on explaining inactive memory - so I'll write a short article on it. We can link to related questions as there are several that attempt to break down all memory, but don't go into how Inactive RAM works in practice. <comment79231> We can free up inactive memory with terminal command `purge` <comment79746> I wish they explained it like this in my OS class. <comment79758> I never knew that. Great answer. +1. <comment93412> Virtual memory systems make large amounts of free RAM a waste. When a program asks for a memory allocation, the kernel makes up more virtual memory and hands it out like candy. Only when a program fills that memory with actual data does the system need to make room in RAM for that operation. That "making room" pulls from free and then inactive memory - and the delay to release inactive memory is immeasurably small. The purge you describe is exactly what happens - just that you imply the system should do the purge work up front when the system is lazy and only does that work if needed. <comment109520> @bmike But wouldn't hat mean that when there is no free RAM left and I start a new App, that the inactive RAM portion would decline and active would rise? That is clearly not the case and from my experience the system gets extremely slow whenever there is no more free ram left, despite there being gigabytes of inactive ram. The system seems to prefer swapping disk before it considers reusing inactive ram. <comment109575> @codingFriend1 Let's be precise - how many pages free in `vm_stat` do you consider "no more free RAM"? When the Mac is "slow" what are the page in and page out counts for `vm_stat 1`? _Any time I'm watching this on a problem system, I like to have `vm_stat 15` running in a terminal window (or logging to the filesystem) so I can know precisely what the paging activity is when deciding if/when I'll tune things like the pager._ This example has 100 MB of free RAM, so it's not likely even under paging pressure. <comment114633> I'm with you, Ernie... in Mac OS 10.6 and 10.7 on a MacBook Pro and Mac Pro, inactive memory will creep up, and the OS will start swapping (according to "Page Ins" and "Page Outs") and the system will crawl to a stop.  The inactive memory seems to never get reclaimed.  I have to use "purge" to reclaim the inactive memory, and get my system active again. <comment124923> Where does this popup window come from? What is the memory situation as reported by `vm_stat` when it does happen? What makes you so sure that there can be "too much" inactive memory "to run anything"? As far as I'm concerned, this is all hearsay that has no backing in the code that you know, actually runs in the kernel. <comment125176> Does your memory allocation look anything like what Gus has presented? Here we're talking about a gigabyte wired and a gigabyte and a half active. The inactive / free ration looks fine to me in this situation. Perhaps you would ask a second question detailing the situation you have where things are breaking down? <comment125798> How does this differ from other answers? <comment125801> The problem is it doesn't work as it should. Not even in Mavericks. When free RAM gets low, as in the image above, my Mac gets unresponsive. I have 8GB of RAM, so that should not be happening. Purging the unused memory speeds things up all around. <comment125802> Inactive memory seems to work as expected in the diagram we are discussing here. If you have a case where you can demonstrate that it's broken, I'd love to see that question asked on how to address your situation. I have yet to find a Mavericks memory situation where I felt things were really messed up on the Apple engineering side. You'll want to include some vm_stat 5 to show that you have paging and that the system isn't releasing inactive memory when it should... <comment126750> Inactive memory is bonus speed only in certain scenarios.  If you use a large variety of programs it might be a problem because freeing inactive memory on demand obviously takes time. Time that will be added on the next non-cached-app's launch. On my Mac mini(i5) Photoshop CS5 takes 7~10 seconds less to launch when I purge inactive memory before. <comment126751> @GusDeCooL It seems that repairing disk permissions on `Disk Utility` purges the memory more effectively <comment126881> Inactive memory is great as long as you don't visualize, even if you have more than enough memory for the VM and OS X; Disk caches while visualizing will slow your mac to a halt and cached memory doesn't help. <comment127121> The VM software (Fusion, virtualbox, whatever) should be doing a pretty good job of keeping memory wired or active when it would benefit the VM. Is there a specific problem you're seeing? <comment129715> @user60372 if you'd like to create a question for your case, we can probably identify the reason(s) for your Mac not responding when expected. <comment129720> @cvsguimaraes purge is not instant;  http://chat.stackexchange.com/transcript/message/12107920#12107920 <comment129722> @kbyrdm *VM* here probably means virtual memory (not virtual machine). <comment129773> @GrahamPerrin That's why some people use scripts to purge memory in background with low IO priority. <comment163829> Not sure if this is cited elsewhere, but here's a good reference (see especially "Page Lists in the Kernel": http://developer.apple.com/library/mac/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html <comment263352> Late to the party-swapping to an SSD can be an extremely bad idea. While the downgrade in performance is much less than with spinning media, the frequent writes to the same blocks can kill the flash memory fairly quickly (measured in years, but not decades). <comment263355> @agentroadkill swapping is always a bad idea - in practice, I've not seen it to be a problem with a single Apple SSD. Even third party SSD are doing marvelously well on this front - I understand the theory that you will eventually exhaust your writes, in practice, I'm just not seeing people willing to put up with systems that swap enough to be of a concern. <comment294555> @bmike I've read that OSes post-Mavericks IIRC handle memory differently and simply allocate more of it to running processes and then swap when new apps open. Have I understood this correctly? If not, why don't we get the pie chart for RAM in activity monitor anymore?
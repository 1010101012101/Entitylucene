How do I fix failed aliases? <body> I had two external hard disks: External and Backup. External had many aliases which pointed to other files on the same disk. Backup was used to backup External.  External failed, and I now use Backup, which I have since renamed to External. Unfortunately, all those aliases now point to code/Volumes/Backup/…/code and thus no longer work.  I don't want to have to fix them or recreate them one at a time.  Is there a way to fix all the aliases so that they point to code/Volumes/External/…/code instead of code/Volumes/Backup/…/code?  <answer2668> Name the disk back to Backup?  Seriously, I think that would be the quickest way to solve the problem.  Or you could write a shell script that recursively finds all aliase's pointing the "Backup" volume and recreate them to point to the new name...  strongedit/strong  Check out http://sveinbjorn.org/osxutils_docs, mkalias in particular.  <answer2771> Here's my stab at solving this problem with Applescript. The following applescript will take selected aliases in the Finder and try and relink them to the new path replacing codeBackup/code with codeExternal/code in the POSIX path.  Hopefully it's straightforward. You could probably make it recursive to search for aliases in selected folders, but that's more work than I care to do -- and then there's the problem of dealing with aliases to folders. Things could get messy. ;-)  Hope it helps.  precodetell application "Finder"     set these_items to the selection end tell  repeat with i from 1 to the count of these_items     set this_item to (item i of these_items) as alias     set this_info to info for this_item      if class of this_item is alias then         tell application "Finder"             set original_file to original item of this_item             set this_alias_file_name to displayed name of this_item             set container_folder to container of this_item              set the_path to the POSIX path of (original_file as alias)             set new_path to my replaceText("/Backup/", "/External/", the_path)              move this_item to trash             try                 make new alias file at container_folder to (POSIX file new_path) with properties {name:this_alias_file_name}             on error errMsg number errorNumber                 if errorNumber is -10000 then -- new original file not found, try relinking to old                     try                         make new alias file at container_folder to (POSIX file the_path) with properties {name:this_alias_file_name}                     on error errMsg number errorNumber                         if errorNumber is -10000 then -- old original not found. link's dead Jim                             display dialog "The original file for alias " &amp; this_alias_file_name &amp; " was not found."                         else                             display dialog "An unknown error occurred:  " &amp; errorNumber as text                         end if                     end try                 else                     display dialog "An unknown error occurred:  " &amp; errorNumber as text                 end if             end try         end tell     end if end repeat  on replaceText(find, replace, subject)     set prevTIDs to text item delimiters of AppleScript     set text item delimiters of AppleScript to find     set subject to text items of subject      set text item delimiters of AppleScript to replace     set subject to "" &amp; subject     set text item delimiters of AppleScript to prevTIDs      return subject end replaceText /code/pre  <answer38942> His problem is not with the name "Backup". Same happens to me with "Compare Files" contextual menu (I think that's the issue) and certainly with files opened from DreamWeaver.  There has been some change / fix in Apple OS because DW tries to open the same file in Chrome without "Volume" before the partition name, and the same file opened in Chrome reveals "Volume" which works.  So either Adobe or Apple made a change or made a fix on the way they point/call a partition other than the startup disk in that same drive.  So in the OP case, the name of the drive IS backup. The problem is the aliases have "Volume" added to it. I think at some point the startup disk was meant to NOT include "Volumes" and later they fixed it for the Finder and other obvious places but they didn't get to the aliases yet.  <answer86549> I recently had to solve the same problem, and wrote this ruby code to fix all aliases recursively.  I'll paste it here:  precode#!/usr/bin/ruby  # these are the folders containing all your images if ARGV.size == 2   dir_base     = ARGV[0]   alias_folder = ARGV[1] else   puts "usage $0 dir_with_all_files sub_dir_containing_broken_aliases"   puts "  or pass -d to use defaults:  ~/img  background"   if ARGV[0] &amp;&amp; ARGV[0] == '-d'     dir_base     = File.expand_path '~/img'     alias_folder = 'background'   end end  # list of all alias file paths, dirs excluded alist = Dir.glob("#{dir_base}/#{alias_folder}/**/*").             select{|w| w.scan('.').any? }  # a list of all file paths, alias fodler contents excluded flist = Dir.glob("#{dir_base}/**/*").             reject{|w| w.scan("#{dir_base}/#{alias_folder}").any? }  # forcably create new aliases by overwriting old files alist.each do |f|    flist.each do |w|      `ln -fs #{w.gsub(' ','\ ')} #{f.gsub(' ','\ ')}` if w.split('/').last == f.split('/').last     puts "linked #{w.gsub(' ','\ ')}  to  #{f.gsub(' ','\ ')}"   end end /code/pre  <comment2371> My new backup is named "Backup"... The shell script idea is what I have in mind but I know no tool able to display and change alias contents. <comment2398> There's something missing from your story. In OS X, Aliases will not break when the Volume is renamed. <comment2401> they will if they point to a path in /Volumes <comment2402> @calavara aliases are not symbolic links they link to a File ID not a path <comment2411> @ghoppe: What I observe is that aliases are broken. I just want to fix them as a whole and I don't know how. The main missing part of my story, I'm afraid, is inside the Finder. As far as I know, aliases contain not only a File ID, but also a path and many other informations that a hidden algorithm uses for alias resolution. If I use the `strings` command on my failed aliases, I observe that they do contain a full path to `/Volumes/Backup/...`. Anyway, I begin to think that symbolic links with a relative path might be a more robust solution in my case. <comment2436> @ghoppe: they do contain a path... check out http://en.wikipedia.org/wiki/Alias_%28Mac_OS%29.  Particularly the section "Preventing Alias Failure", and the statement "It is similar to the Unix symbolic link, but with the added benefit of working even if the target file moves to another location on the *same* disk", and "The original may be moved to another place *within the same filesystem*, without breaking the link." <comment2437> @calavera yes, I know they contain a path, but they also link to a file ID. And yes, I know they break if they're moved to a different filesystem. This does not invalidate my point. An alias will **not** break if the volume containing them is renamed. They were broken when the target file was moved. <comment2438> @ghoppe: I suspect that the failure was introduced during backup procedure. I use SuperDuper. <comment2439> @mouviciel Yes, that's right. Sorry for being pedantic about how they broke. I'm just picking nits. I guess we're both half-right. They broke because the files were copied from External - Backup so the File ID could no longer match. When you renamed the volume Backup to External, the file path no longer matched, so the second redundancy in the alias could no longer find the file. Both methods used by the OS to find the file could no longer find the file. <comment2442> mkalias looks interesting! But the latest version is dated 2003 and the technical note mentioned is for Mac OS 9... If I find nothing else, I will try to update it for Snow Leopard... <comment2484> Many thanks for this script! I am not an Applescript expert so I won't try to upgrade it. I think that a possible solution lies between Applescript and bash with its powerful `find`. Thanks again! <comment36972> Can't say that this is an answer, but I'm trying to run the script above, and am getting an error, saying that it can't get original item of alias file. However, when I manual do a get info for the file in question, I do see an 'Original' value in the display. Relevant snippet: if class of this_item is alias then tell application "Finder" set original_file to original item of this_item Any idea why this would result in no original item when Finder's Get Info clearly shows it? <comment100035> +1 Though I already solved my own problem, I believe your contribution will be helpful for others. Thank you. <comment201761> ghoppe thx from The Netherlands your script was for me the best, resulting in an excellent job done! Greetings from Holland to Canada ;-) Robin
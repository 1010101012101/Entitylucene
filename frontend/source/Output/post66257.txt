Migrating to new user account: must chown old account's files... I think <body> Is there a way to selectively chown the files/folders owned by a particular user, while leaving other files/folders untouched? I'm in the process of migrating to a fresh user account on my machine. I copied what I need from the old user's home directory and chowned it recursively, as described on an Apple support page. The support page makes no mention of chowning files/folders elsewhere on the machine, but I've found plenty of stuff in other locations that are owned by the old user:  ul li/Applications em(lots of stuff)/em/li li/Library em(lots of stuff)/em/li li/private/var/tmp em(a small lot)/em/li li/private/var/vm/app_profile/ em(2 files)/em/li li/usr/local/clamXav/ em(1 easily replaceable file)/em/li li/usr/local/lib/codec/ em(4 files/folders)/em/li /ul  I'm planning to delete the old user once I'm confident that everything is working, and I'm not sure what would happen if some critical files are owned by a deleted user. The old user was an admin account, if that matters. Oh, and I'm running OSX 10.4.11 on a PPC mac, if that matters.  Any help appreciated :)  <answer66281> You can check and re-assign ownership recursively over a directory tree with codefind/code, codestat/code and codechown/code.  precode#!/bin/bash  olduser=&lt;oldusername&gt; # replace this with your old username newuser=&lt;newusername&gt; # replace this with your new username dir=&lt;dir&gt; # replace this with the directory you want to run through  find $dir | while read filename do   owner=$(stat "$filename" | cut -d ' ' -f 5)   if [ $owner == $olduser ]   then     chown $newuser $filename   fi done /code/pre  <comment77987> what's the significance of `$` in bash? <comment77991> It's how you refer to variables you have assigned. By setting `dir='/Applications'`, for instance, any future use of `$dir` will be effectively replaced with `'/Applications'`. Also, in the example of the `$()` section, it's a way to make bash act as if the output of a particular command or commands were typed in-place. For instance, `man $(echo 'grep')` is equivalent to `man grep`, because `echo 'grep'` returns `grep`. <comment78017> No need for `stat`, just use `find` directly: `find $dir -user $olduser -exec chown $newuser '{}' \;` <comment78035> Ooh. I didn't know `find` could be filtered like that. Neat. <comment78196> @patrix- I think I understand the above code, except for the `\ `. If I understand it correctly, it finds files in `$dir` that meet two conditions: 1) owned by `$olduser` and 2) return a zero value exit status when `chown $newuser` is run on them. I'm guessing it starts with the first condition, and if that condition is met, it then runs `chown $newuser` on the file to evaluate the second condition. So if the first condition fails (the file's *not* owned by `$olduser`), `find` moves on without chowning that file. A clever way of piping. Is that sort of correct? And thanks for the help! <comment78201> Cool, I tested it out and it seems to work perfect. Had to run it as sudo. Now I just have to summon the courage to run it on huge batches of my files. Thanks again fellas. <comment78209> If you're nervous, make sure you've a backup. Which could just be a big list of every file and its permissions. <comment78306> Should I add `-h` to the `find` so symlinks themselves are chowned, rather than what they point to? And run an equivalent `chgrp` too? Someone at the apple support forums mentioned that there are some files/directories with the UID in the filename, which could be another issue to deal with. I've decided to just use the new account and use these commands to deal with problems as they crop up, rather than running them on the whole system at once. I want to fix small problems, not make big ones. <comment78314> A good point. `find`'s symlink following won't affect the ownership of the filenames it does print (actually, it might if you're using @patrix's method; the manpage is unclear), so that's only really necessary if you want to gain some speed â€” it wouldn't be a problem if it found other files owned by your old user. `stat` does not follow symlinks by default, but `chown` *does*, so you should probably `chown -h`. Holding off is probably a good decision, though.
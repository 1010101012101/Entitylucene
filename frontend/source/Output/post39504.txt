Best way to copy all files, ignoring errors? <body> I have a partially corrupted HD that can not be repaired by Disk Utility, but which can be mounted read-only making the data on it accessible.  I am trying to copy all the recoverable contents onto a spare HD, but every method I try fails when an error is encountered - leaving the remaining files uncopied.  Finder - Fails. SuperDuper - Fails. Ditto (terminal command) - Fails.  I was hoping that Ditto would do the trick, the Ditto man page says:     ditto returns 0 if everything is copied, otherwise non-zero.  ditto   almost never gives up, preferring to report errors along the way.    Diagnostic messages will be printed to standard error.   I have submitted a bug to Apple re ditto failing to perform as advertised.  Any other ideas?  <answer39521> This Macworld hint suggests using dd to make a bit-by-bit copy (ignoring errors) then mounting the resultant image in Finder to recover your files. I've not tried it, but it sounds like it might work.   <answer99516> The codeditto/code command should work, I would use codeditto/code in conjunction with the code-v/code option for verbose so you can see exactly what gives you an error of what it copies.  <answer99517> I use strongcodecp -Rfv sourcefile destinationfile/code/strong with success on a pretty regular basis.  strongcp/strong = copy  strongR/strong = maintains file hierarchies  strongf/strong = if  an  existing destination file cannot be opened, remove it and try again  strongv/strong = verbose mode, displays files transferred as it progresses  strongsourcefile/strong = data you want to copy  strongdestinationfile/strong = directory/drive you want to copy to  <answer108082> You might consider using the codedd/code command to perform a block-by-block copy from your corrupt HDD to your new HDD.  Assuming your new-HDD (code/dev/disk2/code) is of equal or greater size than your corrupt-HDD (code/dev/disk1/code), then you can issue:  precodedd if=/dev/disk1 of=/dev/disk2 bs=4096 conv=notrunc,noerror /code/pre  blocksized @ 4k, don't truncate any data blocks, ignore all errors  To find the device names, run codemount/code from Terminal first.  <answer128294> Try Gnu ddrescue -- it's a data recovery program that does block-based copying with corrupt data recovery during the copy operations. You can get it for OS X if you're using Homebrew by typing in an Terminal window:  precodebrew install ddrescue /code/pre  A guide on arstechnica describes how to rescue a failed disk using ddrescue. Make sure you read through the guide, as it contains helpful information. Here is a gist on how to get there.  ul liLocate the drive using codediskutil list/code. The identifier column is what you are looking for:  precode/dev/disk1    #:                       TYPE NAME                    SIZE       IDENTIFIER    0:      GUID_partition_scheme                        *750.2 GB   disk1    1:                        EFI EFI                     209.7 MB   disk1s1    2:                  Apple_HFS Macintosh HD 2          80.0 GB    disk1s2    3:                  Apple_HFS Home                    509.1 GB   disk1s3 /code/pre/li liUnmount the disk in question:  precodediskutil unmount /dev/disk1s3     /code/pre/li liStart a rescue operation of the disk into an image. Make sure the location of codeRescue.dmg/code is replaced with your desired location.  precodesudo /usr/local/bin/ddrescue -v -n -c 4096 /dev/disk1s3 Rescue.dmg Rescue.log /code/pre/li liRecover the image onto a strongnew/strong drive:  precodesudo /usr/local/bin/ddrescue --force -v -c 4096 Rescue.dmg /dev/disk2s0 recovery.log /code/pre/li /ul  Be advised to also read the manual of ddrescue to educate yourself on the available options by running codeman ddrescue/code.  <answer273535> You might try running SuperDuper and ignoring the files with io errors, if it's only a few and you use the smart update feature that's a pretty effective way to get most of the data off. (I think the dd command would be preferable if you can do that).  Steps:  ol liSelect 'backup all files' as the backup strategy/li liIn options select 'smart update' (otherwise this process will take a ridiculously long time if you have more than one or two errors, you'll need the paid version for this)/li liRun the copy/li liWhen the copy fails read the logs to find which file failed to copy, then hit ok/close to get back to the 'start' screen/li liSelect 'edit selected copy script' from the using dropdown/li liUnder Script commands add the file which failed to copy, it should say 'ignore' once it's added to the list of files/li liSave your script with some name (e.g. ignore-corrupted-files)/li liSelect your script and repeat steps 3-7 as many times as necessary to ignore all corrupted files./li /ol  <comment44680> This is good, because you want your data off *fast* if that disk is duff.  In this way, you get a block for block copy, including errors, that will then be available for inspection at your leisure without worrying that the disk will peroperly die before you get everything off it.  I will perform one operation, in a nice neat start to finish without skipping all over the place from file fragment to file fragment which will be harder work on the drive that created the DD copy. <comment44736> ddrescue is better than dd at this, since it'll retry bad sections over & over for as long as you leave it running -- see [this previous answer](http://apple.stackexchange.com/questions/33101/how-can-i-recover-files-from-a-failing-hard-drive/33106#33106) where the OP god his data off after a couple of weeks' grinding(!).  Note that this is a good approach if the HD hardware is failing, but does nothing at all to fix volume structure corruption -- that just gets copied along with the files. <comment117078> According to the asker `ditto` doesn't work. Why do you think it does? <comment117134> How does this ignore errors on the source drive (see the question)? <comment117185> @patrix It doesn't "ignore" errors but the "f" flag forces through them, only copying intact data. As you watch the progress (thanks to the verbose flag) you will see output along the lines of "data not copied due to I/O error" when it encounters bad data.  Once the error is displayed it moves on to the next file without any user input.  The poster's scenario sounds extremely similar to the dozens of times I've used this command to retrieve data from flakey disks/volumes. <comment150258> To add to the moderator notice: this could be a very good answer to the problem but it needs more work. Can you add some sample ddrescue commands for OS X devices to the answer? I've fixed it up a bit with the kind of background and information we like to see in answers here. If you do that, I'm sure it'd be a great response. <comment191688> Is there a way to copy a failing file with some postfix, so all the missing files are better found? <comment315531> See http://stackoverflow.com/a/27637277 rather than the `--ignore-errors` answers below. <comment335165> From the BSD `cp` manual (macOS): "In -R mode, cp will continue copying even if errors are detected." <comment348500> op is asking about alternatives to `ditto`
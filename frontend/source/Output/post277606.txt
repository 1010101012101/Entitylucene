Why are all the homebrew formulas located in the 'libexec' folder? <body> When I install packages manually, the typical layout looks like the following:   precode├── conf ├── lib ├── bin │   ├── mvn │   ├── mvn.cmd /code/pre  But when I install it with homebrew, almost all the files are placed in the codelibexec/code folder:  precode├── bin │   └── mvn └── libexec     ├── bin     ├── boot     ├── conf     └── lib /code/pre  Why is this strange layout used? It's a bit confusing when you read tool's official documentation and your paths mismatch.  <answer277658> The layout was a deliberate design decision on Homebrew’s side to keep the strongbalance between usability, maintainer sanity, and not breaking things./strong  A comment in Homebrew’s source code says:     Installing JARs to "lib" can cause conflicts between packages.   For Java software, it is typically better for the formula to   install to "libexec" and then symlink or wrap binaries into "bin".   Why conflicts?  To explain what the specific conflict is and what causes it, let’s have a look at (a gross simplification of) what Homebrew does when you run codebrew install foo/code:  ol liHomebrew downloads and unpacks everything codefoo/code needs strongaccording to the formula./strong/li liHomebrew follows the installation instruction strongaccording to the formula./strong For example, it copies files around, applies patches, and so on. In the end, you get a emkeg,/em the folder containing the fresh installation./li liFor your convenience, Homebrew looks at the codebin/code and codelib/code directories of your keg, then symlinks everything it finds into code/usr/local/bin/code and code/usr/local/lib/code so you don’t have to./li /ol  Note how in #3, the formula strongdoes not have a say./strong This helps keep complexity out of the formula definitions. A formula maintainer can never forget to create a symlink because she or he doesn’t have to; Homebrew does it automatically for everything that is in codebin/code or codelib/code.  The layout policy was (AFAIK) first codified in issue #678 of Homebrew’s legacy GitHub repository, which says:     This is expected behavior; libexec is assumed to be private-use stuff for that formula.   Basically, Homebrew considers the contents of codebin/code and codelib/code empublic/em artifacts, i. e. things that are supposed to be called from outside the formula.  Everything else, including the whole content of codelibexec/code, is considered an implementation detail, i. e. things for private use by the formula itself.  But what is the big deal with that? Could you, as an author of a formula like codemaven/code, not simply ignore those principles and instead live with a few unnecessary symlinks in code/usr/local/lib/code, and give the user the same layout as the upstream project has?  Turns out that yes, you could, but it’s a horrible idea, and strongHomebrew maintainers would rightfully refuse such a formula until fixed./strong  Publishing private stuff to code/usr/local/lib/code is a typical cause of JAR hell. (Imagine a Java-based Homebrew formula codefoo/code which uses codemylib.jar/code v1, and another Homebrew formula codebar/code which uses codemylib.jar/code v2, with the version number not being part of the filename codemylib.jar/code. Now go ahead and try to figure out why your business-critical application – which happens to use code/usr/local/lib/mylib.jar/code because it’s in the path – only works on that 50% of your machines where codefoo/code has been installed emafter/em codebar/code but not vice versa. This is an example of the conflict mentioned at the beginning.)  strongtl;dr Whatever you put into codelib/code, Homebrew will symlink to code/usr/local/lib/code for you. Putting a JAR you depend on into code/usr/local/lib/code is a bad thing to do and leads to JAR hell./strong 
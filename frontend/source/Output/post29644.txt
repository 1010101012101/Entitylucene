How do you md5 an entire disk in OS X? <body> I want to validate a "dd" image of a USB disk in OS X using the terminal. The terminal command md5 works on the dd image but not on the entire disk.  precode$ dd if=/dev/disk2 of=image.dd conv=notrunc 1974152+0 records in 1974152+0 records out 1010765824 bytes transferred in 149.033958 secs (6782118 bytes/sec) $ md5 image.dd  MD5 (image.dd) = 3efc7e341b1bf2d729ffcd9b6a313428 $ md5 /dev/disk2 MD5 (/dev/disk2) = d41d8cd98f00b204e9800998ecf8427e $ md5 /dev/rdisk2 MD5 (/dev/rdisk2) = d41d8cd98f00b204e9800998ecf8427e /code/pre  I tried using /dev/rdisk1 and got the same results. I am OS X Lion.  <answer29645> Hmm...Is the dd image functional?    What you are seeing might be a result of the dd command possibly putting some junk at the tail end of the transfer so that you get a copy of an even number of records.   You do not say, but it is assummed that you are dd'ing/md5'ing a quiet/unmounted/unused disk to make the image file.  <answer29646> You could mount both filesystems (read-only, if possible) and then recursively checksum each file.    strongEDIT:/strong  example command:  codecd /Volumes/xyz/code  codefind . -type f -exec md5 {} \; | cut -c15- &gt; log1.txt/code   15 in this case is the string length of /Volumes/xyz or what ever your mount point is.  Do this on both file systems and make sure the filenames do not have the starting root path (by using cut).  Then use the 'diff' command to compare the 2 files.  <answer29647> If you are not trying to checksum disk the running system resides on (this won't ever be consistent) you may try  pre dd if=/dev/disk2 | md5 - /pre  <answer243452> I know this question is old, but I thought for other people that may read this they would find this helpful... I found that OS X is mounting and writing to the volume immediately upon codedd/code completing. This makes it impossible to checksum the newly written volume and compare with the file. I had to use a forensics tool call DiskArbitrator to prevent volumes from being mounted after codedd/code completes. This allows there to be time to checksum the volume before spotlight messes it up.  <comment34024> Yes it is functional. If I dd the image back to a different thumb drive I get the expected contents. I also checked this process using Ubuntu and md5sum. It works as expected there. <comment34025> The size of the disk might not be an even number of blocks.  Thus dd would add junk to buffer the last write to be an integral number of blocks.  Once copied, there are an integral number of blocks so copying the image around will then return the same results. <comment34026> I think the md5 command doesn't work on entire disks (anymore). I've found old articles saying it should. If you md5 a disk it returns immediately. Can someone verify this? <comment34027> Interesting! Piping directly into md5 rather than generating the file first is a viable solution. I was really hoping that the md5 command would do the disk reading independent of dd. <comment34028> The [philosophy of Unix](http://en.wikipedia.org/wiki/Unix_philosophy#Eric_Raymond) ensures that the functionality of `dd` will never be integrated into `md5`: Unix is intentionally made up of simple components. They each do one thing well and they work together! The beauty of this approach is that you don't need the authors of the `md5` command to have *foreseen* that you might want to use it to generate a hash from an entire disk. In Windows, where tools tend to be less modular and less interoperable, you can't be as clever; unforeseen tasks may require manual steps or purpose-built tools. <comment34029> By the way, I suspect that `dd if=/dev/rdisk2` would be dramatically faster than `dd if=/dev/disk2`. <comment34032> The best way is completely unmount (not eject) disk which you can do with Disk Utility or in terminal. Then do `dd` to `stdout` and `md5` result. <comment35229> Can you explain how to recursively checksum the files? <comment35319> Added example commands <comment299808> Are you referencing El Capitan and earlier or Sierra?  If it's not Sierra, then the correct name is *OS X*
Best way to check in bash if Command Line Tools are installed? <body> Using bash, I want to check if Command Line Tools are installed.  Currently strongthey are/strong and when I will type codexcode-select --install/code I get:     xcode-select: error: command line tools are already installed, use   "Software Update" to install updates It appears Homebrew is already   installed. If your intent is to reinstall you should do... blah blah   blah   strongBasically my problem is that I have several methods to check it in bash (using codeif / fi/code) but I don't know which solution is the best one./strong  1) I can do codexcode-select -p/code and that returns the path code/Library/Developer/CommandLineTools/code but then how I should build the codeif/code statement? I don't know what will be presented when CLT are not installed.  2) I can do codexcode-select --version/code. Should I then codegrep/code for a phrase codeversion/code since I get     xcode-select version 2343.   3) I can do codewhich xcode-select/code but again, in all cases I'm not sure how the codeif/code should look like. I also think that codegrep/code is not the best way, since in the future the output may be different in future version of OSX.  To sum up I would like something like  precode#!/bin/bash if [ no idea ]; then     #installed, nothing to do... else     xcode-select --install fi /code/pre  Thanks for any suggestions.  <answer219508> precodeif type xcode-select &gt;&amp;- &amp;&amp; xpath=$( xcode-select --print-path ) &amp;&amp;    test -d "${xpath}" &amp;&amp; test -x "${xpath}" ; then    #... is correctly installed else    #... isn't correctly installed fi /code/pre  Strangely, the code--print-path/code isn't documented in old Xcode versions but is working as code-print-path/code. On the other hand, the code-p/code option doesn't have this compatibility.  <answer219575> Just because code-select returns a valid path doesn't mean the command line tools are installed:  pre class="lang-none prettyprint-override"code$ xcode-select -p /Applications/Xcode.app/Contents/Developer $ if type xcode-select &gt;&amp;- &amp;&amp; xpath=$( xcode-select --print-path ) &amp;&amp;     test -d "${xpath}" &amp;&amp; test -x "${xpath}" ; then echo "installed" ; fi installed $ xcode-select --install xcode-select: note: install requested for command line developer tools /code/pre  Thus, a more accurate check is to use xcode-select to try and install the CLT with the following:  precodeif xcode-select --install 2&gt;&amp;1 | grep installed; then   echo installed; else   echo not installed, installing; fi /code/pre  If it's not installed, it will prompt for installation as your example shows, but without a separate line for the codexcode-select --install/code.  <answer219708> Yet another approach would be to use codepkgutil/code  precodeif      pkgutil --pkg-info com.apple.pkg.CLTools_Executables &gt;/dev/null 2&gt;&amp;1 then    printf '%s\n' "CHECKING INSTALLATION"         count=0         pkgutil --files com.apple.pkg.CLTools_Executables |         while IFS= read file         do         test -e  "/${file}"         &amp;&amp;         printf '%s\n' "/${file}…OK" ||         { printf '%s\n' "/${file}…MISSING"; ((count++)); }         done         if      (( count &gt; 0 ))         then    printf '%s\n' "Command Line Tools are not installed properly"                 # Provide instructions to remove and the CommandLineTools directory                 # and the package receipt then install instructions         else    printf '%s\n' "Command Line Tools are installed"         fi else   printf '%s\n' "Command Line Tools are not installed"        # Provide instructions to install the Command Line Tools fi /code/pre  <comment265477> That's perfect. So I was missing that `-x`. Thank you Daniel. I see that replacing `-print-path` with just `-p` works as well. <comment265479> Depending on the quality of the checking you want to achieve, a `type xcode-select` and a `-d` could be necessary. <comment265514> I'd use: `if [ -d "$(xcode-select -p)" ]; then` <comment265515> If you want to use `print−path` it's supposed to be `−−print−path` not `−print−path` as you have it. <comment265517> @user3439894: thank you. On many of my `Xcode` versions, the `man` documents `-print-path`, some others document `--print-path`. But in all cases `-p` seems more trustable. <comment265524> With the help of remarks of @user3439894, I put here or more general shell check of `Xcode` correct install. <comment265526> Shouldn't `${xpath}` be double quoted to prevent globbing and word splitting?  Also, why are you placing spaces around `xcode-select --print-path` in `$( xcode-select --print-path )`?  There doesn't need to be and should simply be: `$(xcode-select --print-path)` <comment265538> @user3439894: about quotes you are right. About the spaces around `$(` and `)` it is a personnal habit (as the space before `;`) so as to visually separate them of the rest of the command line. <comment265578> Is the first code you run the consequence of a 1st `xcode-select --install` followed by a move of the registered `Xcode` path with `xcode-select --switch /tmp`? <comment336305> In macOS Sierra 10.12.2, if CLT is already installed `xcode-select --install 2&1` results in stderr: `xcode-select: error: command line tools are already installed, use "Software Update" to install updates`, but you wouldn't want to suppress that either for the case when it isn't installed. I'm stumped. <comment336832> @fd0 looks to be the way to go.  On a clean Sierra MacOS 10.12.1:      ENTER: $ pkgutil --pkg-info=com.apple.pkg.CLTools_Executables     RESULT: No receipt for 'com.apple.pkg.CLTools_Executables' found at '/'.     ENTER: $ echo $?     RESULT: 1 <comment336847> I looked in the source code of homebrew and `Homebrew/os/mac/xcode.rb` looks to use this type of approach. Looking at homebrew was interesting to me as I could see the evolution of the CLT integration in MacOS.
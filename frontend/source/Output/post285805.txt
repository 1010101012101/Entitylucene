How to SSH in one line <body> How would I connect to another computer through SSH in one line? If I were to do codessh host@IP/code, it would require me to enter the password in the second line.  I was thinking that I could do something like this: codessh host@IP | echo password/code, but that puts the password in before asking for the password.  <answer285806> There are several possibilities. Your example will obviously not work, but you can achieve something similar using codesshpass/code utility:  precodesshpass -p password ssh host@IP /code/pre  Note, strongthis is not recommended/strong because the codepassword/code will be visible for other processes or in the shell history.  strongA much better way to do the same is to set up the passwordless authentication using SSH keys./strong In short:  precodessh-keygen -t rsa -f ~/.ssh/id_rsa ssh-copy-id IP /code/pre  <answer285807> You should be using SSH keys to authenticate with rather than putting your password on the command line as it's strongemextremely/em/strong insecure.  The way this works is once you have your SSH keys set up, all you have to do is issue the command:  precodessh user@host /code/pre  and without typing another thing, you will be automatically logged in.  hr  h3Copy SSH Public Key to Mac/FreeBSD/Linux from macOS/h3  This assumes you have access to the remote server via password based authentication (typing in a password),  and that you have already generated your private/public keypair (if not, see below).  In the following example, we are using RSA.  To start with let's copy the key over (be aware that the "home" directory differs between macOS, Linux, BSD, etc.):  Using SCP:  precodescp ~/.ssh/id_rsa.pub username@hostname:/Users/username/.ssh/ /code/pre  Or simply cat-ing the file to codeauthorized_keys/code (I prefer this method):  precodecat id_rsa.pub | ssh username@hostname ' cat &gt;&gt;.ssh/authorized_keys' /code/pre  (Your key name may differ)  If the .ssh directory does not exist on the remote server you will need to login and create it.  Now the key has been copied from the mac to the emremote/em server. Set correct permissions for the SSH Public Key on the remote server:  precodechmod 600  ~/.ssh/id_rsa.pub /code/pre  Next add the key to the SSH authorized_keys file, if the file does not exist create it.  If the file codeauthorized_keys/code already exists in code~/.ssh/code the use the following command:  precodecat id_rsa.pub &gt;&gt; authorized_keys /code/pre  If the file does not exist enter the following commands:  precodecat id_rsa.pub &gt; authorized_keys  chmod 600 authorized_keys chown user:group authorized_keys /code/pre  br  h3Generate SSH Public/Private key on macOS/h3  Open up the Terminal by going to Applications - Utilities - Terminal  In the terminal, use the following command to start the key generation  precodessh-keygen -t rsa /code/pre  Next you will be prompted to provide the location where you want to create the private key file:  Enter file in which to save the key (code/Users/username/.ssh/id_rsa/code):  Leave this empty to create the key in the default location, which is code/Users/username/.ssh/id_rsa/code. The public key file will be created in the very same location, and with the same name, but with the .PUB extension.  After you will be prompted to choose a passphrase. This is the password emoptional/em to use the private key.  precodeEnter passphrase (empty for no passphrase): /code/pre  Your SSH key is generated.  Now, keep in mind, if you put in a passphrase you will be required to enter it each time you connect.  The utility codessh-agent/code will keep the passphrase in memory alleviating the need to manually enter it every time you connect while you are in the same session.  For more details see codeman ssh-agent/code  <answer285859> I have spent a long time looking for the answer to this too. Despite it being insecure and all these people telling you to use RSA keys (strongwhich IS a more secure and reliable idea/strong), it is quite possible.   Use a program called codeexpect/code for this. Expect will watch stdout (and I think stderr if configured correctly) for you, waiting for certain messages and responding to them with output. Expect itself is actually a scripting language, and when I was doing this same thing, I had a very hard time getting my own script to work properly because of timing. However, expect also includes a handy utility called codeautoexpect/code.   With autoexpect, it will watch you and generate an expect script for you. Simply run autoexpect and the command you want:  precodeautoexpect ssh host@ip  /code/pre  and do what you'd normally do. When you exit the program (by typing codeexit/code in the ssh'd shell), it will generate the script. In case that you don't want the whole script you're writing to be in an expect script, you can edit the script from autoexpect (called codescript.exp/code) to exit before typing the codeexit/code command into the shell. The line you want to move to change the script ending is:  precodeexpect eof /code/pre  which means expect end of file. Hope this helps!  <answer285972> Using codeexpect/code is just plain wrong to log into an ssh connection for anything other than in a test suite.  What @ben-a is looking for is already implemented in ssh. The trick is to how to use it. So here goes:  ol liGenerate a public/private keypair using codessh-keygen/code. Use either ECDSA or RSA as the code-t/code (or type) and for RSA use 2048 or 4096 as the code-b/code (or BITS length). This should suffice at the moment of writing. ALWAYS use a PASSWORD!/li liUtilize the codessh-copy-id/code or the above mentioned methodology to create on the machine you're logging on to (a.k.a. the server) the code~/.ssh/authorized_keys/code file. Within there is a copy of the public key you just generated./li liNow on the machine you use to log into the 'server' (or client) you open the file code~/.ssh/config/code. If it does not exist you can create it./li liIn this file, you add the following for your needs  pre class="lang-none prettyprint-override"codehost &lt;name you want to use for this connection&gt;     Hostname &lt;DNS or IP of the server&gt;     user &lt;user name you want to use&gt;     identitiesonly yes     identityfile &lt;path to the private key&gt; /code/pre/li liYou can now use just codessh &lt;name&gt;/code to setup the connection, but it will still need the password for your key. To solve this, use the for-this-purpose developed and included ssh-agent. To add your key to the agent just use codessh-add &lt;path to keyfile&gt;/code. You will be asked for the password, and it will store the key for you securely for this session. If it yields the error "can't find the ssh-agent" (or similar), that means that probably the agent hasn't been started. You can start it for this session using codessh-agent bash/code. This will start a new shell with the agent active in it./li /ol  When using these steps, you not only make it harder for someone to impersonate you by hijacking your credentials, but also keep the usability in order (its easier to use than plain passwords).  <comment360538> I tried the `sshpass` as you recommended, but it said command not found. <comment360541> Well ... You will probably have to install it. And no, I don't recommend it. Set up passwordless authentication using ssh keys. <comment360542> Are there any ways to do it without having to install? <comment360543> @BenA. set up passwordless authentication by defining a public/private keypad and setting it up on both machines involved. That's much easier (and actually safer) than any password <comment360544> Absolutely this - keys can and should completely replace passwords for any ssh access over the internet.   I'd suggest you expand on the need for security of the private key, that its not something to have laying about on all your computers. <comment360545> A thousand times no.  sshpass is a dirty hack used for connecting to devices that speak ssh but don't do keys properly, and its main use is setup scripts.  You would not use sshpass on a multiuser machine  ```ps auxw | grep sshpass```   will tell other users the ssh password. <comment360547> This sort of thinking comes from the days of telnet and expect, back when the internet was a safer place.   Allen's answer is correct, Jakuje's answer is techncally true but not the tool for the job in most places. <comment360565> +1 This is a really good answer, not only because of what it says, but also because of how you've explained it. Anything that's easier for users to follow and helps them to be more secure is a plus in my books! <comment360567> Great answer. Just wanted to add that `ssh-copy-id` is a nice tool for automating some of the above. <comment360568> This is a good question for setting up passwordless login. I'd ask that you revisit your accepted answer. Which Jakuje's answer -is- correct, and will work, the proper way to do this is with SSH keys, described in Allan's answer. <comment360586> @Criggie, not entirely. While I'm 100% behind the key-based solution, I have sshpass on a couple of internal-only Raspberry Pis (for random tasks, and accessed by random clients; passing keys around just for internal use is a hassle). Running your command gives the following output: `pi@sshbox:~ $ ps auxw | grep sshpass pi        4891  0.0  0.3   2256  1560 pts/0    S+   06:29   0:00 sshpass -p zzzzzzzz ssh pi@192.168.0.208`. The `zzzzzzzz` is literal; sshpass masks the content of the password. Perhaps earlier iterations were less privacy-aware. <comment360603> A mention of [ssh-agent](https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/ssh-agent.1.html) might also help. Most (all?) versions of OS X / macOS come with it, and it allows password-less login even when the key is password protected. <comment360605> @Scot - it's not part of macOS by default and must be [installed via Homebrew or MacPorts](http://bit.ly/2rK2F6t).  I'm not a fan of installing software for things can can be accomplished in 1 line or a short, self written script and for those reasons I thought it was outside the scope of the answer.  However, it's a good little utility and worth mentioning. <comment360606> I joined this stack purely to upvote this answer.   Bad security must be discouraged whereever it is found. <comment360621> In case no one else has said it yet: Welcome to Ask Different! <comment360661> If `ssh` would read the password from stdin, then `echo password | ssh host@IP` would work, but usually SSH tries to read directly from the terminal. <comment361286> @Allan - I also had thought that `ssh-copy-id` was not installed by default, but I just noticed that it is present on a virgin copy of macOS Sierra. I don't recall this being present in El Capitan, but I'm not certain.
bash: Searching with ls <body> Is there a bash command that can be used as Spotlight or an option with codels/code that only prints files containing certain text? I want to be able to open Terminal and type something codels -SOMEOPTION filename/code and find all the files that have codefilename/code in their name, and this option could be used with code-R/code and it would work as a replacement for Spotlight.  <answer108698> precode find . -type f -name "*filename*" -exec grep -il 'mywordinthefile' {} \; /code/pre  ul licodefind/code search for file recursively in a directory. /li liFirst parameters is the directory you want to look in. Here it's code./code so the current directory. You could use code~/Documents/code for example or any other directories. /li licode-type f-/code option is to only return files, not directories. /li licode-name/code option takes a pattern to find specifics filenames. /li licodegrep/code is used here to find the word/pattern you want in the files found by codefind/code. /li /ul  <answer108705> To find all files which strongcontain/strong a certain string, you can use just grep on its own:   codegrep -R /path/to/directory "myword"/code  In the example above, code"myword"/code is what you're looking for, and code/path/to/directory/code is the directory you want to search through. code-R/code tells codegrep/code to run a recursive search (i.e. to start at the path you specified, and go into each subdirectory in there).   strongEDIT/strong  I've re-read your question and I think you're looking for how to find files that have a certain filename. For this use:   codefind /path/to/directory -name "*glob*" -print/code  where code/path/to/directory/code is where you want to start your search (and codefind/code will also look in the subdirectories) and code"*glob*"/code is a full or a partial file name that you want to look for. Please note, you can use wildcards (code./code and code*/code for any single and any multiple characters match, respectively) in the glob. As a variation to this, you can use, as proposed by others:   codefind /path/to/directory -name "*glob*" -exec ls -la {} \;/code  in the above, what you put after the option code-exec/code is any UNIX command with paramteres (in this case codels -la/code). The code{}/code will be substituted by the file name codefind/code finds, and the code\;/code is a termination string.   strongEDIT 2/strong  Please note, the commands above give you similar results to Spotlight, but they don't use Spotlight at all.   If you'd like to use Spotlight from command line, you can use codemdfind/code command, which is a command-line interface for Spotlight. Typing codemdfind/code on its own will give you a quick help for using it with a few examples. codeman mdfind/code will give you a more detailed manual for it.   Essentially codemdfind/code takes a search string (and optional modifiers) as it's argument and it's the same as you would type in Spotlight's text field when using it in a GUI.  <answer108730> To find files with a specific string in the filename, use  precode    find . -type f -name '*&lt;filename&gt;*' 2&gt; /dev/null /code/pre  Substitute code&lt;filename&gt;/code with the string that you would like to look for in the filename. The redirection at the end is to avoid printing errors when certain files/folders are not accessible.  hr  You can put this command in a shell script, called say, emlsf/em that would contain the following:  precodefind . -type f -name "*$1*" 2&gt; /dev/null /code/pre  Then make it executable using  precodechmod +x lsf /code/pre  hr  You can also put this in your code~/.bashrc/code or code~/.bash_profile/code file instead of a shell script as described above (the command is still named lsf here):  precodemyls() {     find . -type f -name "*$1*" 2&gt; /dev/null } alias lsf=myls /code/pre  <comment127377> I copied the command into Terminal, I replaced myword with "test" because I have a file called test.txt in the directory, but I get no output. <comment127378> -exec grep is only needed if you ant to find something in the file. For the file name, replace the `-name`
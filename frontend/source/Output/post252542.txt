Is any version of OS X/macOS vulnerable to the Year 2038 problem? <body> Around the year 2000, Apple wrote a press release that every Mac since 1984 would avoid the Y2K problem, and could process dates for the next several thousand years.     The good news is that since their introduction in 1984, Macintosh computers have had the ability to make the transition to the year 2000. In fact, the Mac OS and most Mac applications can handle internally generated dates correctly all the way to the year 29,940.    This statement was made when Mac OS 9 was the most recent operating system.  Since then, OS X (now called macOS) is the dominant operating system, which is derived from Unix. Does this mean that any version is vulnerable to the Year 2038 problem, a problem comparable to the Y2K problem that affects Unix-like systems? Or does the statement Apple gave about being compatible to the year 29,940 still hold true?  <answer252549> El Capitan is not susceptible:  precode#!/usr/bin/perl use POSIX; $ENV{'TZ'} = "GMT"; for ($clock = 2147483641; $clock &lt; 2147483651; $clock++) { print ctime($clock); } /code/pre  This perl script provides the output below:  precodeFamily-iMac:~ dude$ sw_vers ProductName:    Mac OS X ProductVersion: 10.11.6 BuildVersion:   15G1004 Family-iMac:~ dude$ /Users/dude/Desktop/2038.pl  Tue Jan 19 03:14:01 2038 Tue Jan 19 03:14:02 2038 Tue Jan 19 03:14:03 2038 Tue Jan 19 03:14:04 2038 Tue Jan 19 03:14:05 2038 Tue Jan 19 03:14:06 2038 Tue Jan 19 03:14:07 2038 Tue Jan 19 03:14:08 2038 Tue Jan 19 03:14:09 2038 Tue Jan 19 03:14:10 2038 /code/pre  Information gleaned and script compacted to bare bones from this very interesting site.  <answer254289> All versions before OS X 10.6 "Snow Leopard" have the year 2038 problem. Most installs of 10.6 and all installs of 10.7 "Lion" fixed the main cause of the problem. It's almost gone, but the year 2038 bug might survive in a few apps.  OS X is derived from Unix by way of BSD. Apps for OS X use BSD system calls for things like opening files and connecting to the internet. BSD has a long history and some of its system calls come from the 1980s. One of its system calls is codegettimeofday()/code, which first appeared in 4.1cBSD. UC Berkeley released 4.1cBSD in 1982, more than half a century before 2038.  I have an old PowerPC Mac. It runs OS X 10.4 "Tiger", the last version with Classic. It has codegettimeofday()/code. Its codetime_t/code is a signed 32-bit integer. This causes the year 2038 problem. A signed 32-bit codetime_t/code has a range of -2147483648 to 2147483647. This can only hold times from 1901-12-13 20:45:52 UTC to 2038-01-19 03:14:07 UTC. When codetime_t/code overflows, codegettimeofday()/code will inform programs that today is Friday the 13th of December 1901, not Monday the 19th of January 2038.  The fix is to transition from 32-bit codetime_t/code to 64-bit codetime_t/code. For OS X, this transition happened along with another transition from 32-bit pointers to 64-bit pointers, but 64-bit pointers require a 64-bit processor.  Apple has only provided 64-bit codetime_t/code for 64-bit processors. It is possible for 32-bit processors to handle 64-bit codetime_t/code, but Apple never provided that feature.  Apple's compilers have supported 64-bit integers on 32-bit processors since OS X 10.0 "Cheetah". That version defined codetime_t/code as 32 bits and codeoff_t/code as 64 bits. In Unix and BSD, codeoff_t/code is the size of a file, or an entire disk of files. A 32-bit codeoff_t/code would limit OS X to disks under 2 GiB. Apple defined codeoff_t/code as 64 bits, so OS X worked with larger disks. Apple defined codetime_t/code as 32 bits in 10.0, so a transition to 64-bit codetime_t/code needed to happen later.  For my old PowerPC Mac, the header file code&lt;ppc/_types.h&gt;/code defines code__darwin_time_t/code as codelong/code. For Intel Mac, the header code&lt;i386/_types.h&gt;/code does the same. In OS X, codelong/code has the same size as a pointer. So when pointers became 64 bits, codelong/code also became 64 bits, and codetime_t/code also became 64 bits, fixing the main cause of the year 2038 problem.  Apple's 64-Bit Transition Guide says, "Prior to OS X v10.6, all applications that shipped with the operating system were 32-bit applications. Beginning in v10.6, applications that ship with the operating system are generally 64-bit applications." I know from Wikipedia that 10.6 required an Intel processor and 10.7 required a 64-bit Intel processor. A Mac running 10.6 on a 32-bit Intel processor must have had 32-bit apps. I conclude that most Macs running 10.6 and all Macs running 10.7 have 64-bit apps with 64-bit pointers and 64-bit codetime_t/code. Apple released 10.7 in 2011, well before January 2038.  With 64-bit codetime_t/code, the year 2038 bug is almost gone, but it might survive in a few apps. Old 32-bit apps might still run on newer systems. Also, 64-bit apps might contain coding mistakes or outdated designs, causing them to convert a 64-bit codetime_t/code to 32 bits. This is a problem for all systems, not only macOS.  sThe kernel of OS X is a hybrid of BSD and Mach. The BSD part of the kernel handles files, internet and such, but the Mach part handles time. I guess that some apps can bypass BSD codegettimeofday()/code and get the time from Mach. This would avoid the year 2038 bug. Apple's Carbon and Cocoa libraries probably get the time from Mach. I know much less about Mach than about BSD./s em(This last paragraph is probably wrong, I need to correct it.)/em  <answer266166> Well, as far as El Capitan 10.11.6 is in question, answer is not as easy as using Perl script.  If we try this  precodemacmladen@buk $ touch -t 205012121212 my macmladen@buk $ ls -al total 104 drwx------  7 root root    4096 Dec 25 13:42 . drwxr-xr-x 23 root root    4096 Dec  4 17:06 .. -rw-r--r--  1 root root       0 Dec 12  2050 my /code/pre  So that proves strongmacOS/strong in lowest, system layer strongis safe/strong from Y2038 bug. That means the system as such will strongnot/strong fail and will work correctly.  However, on application level, that is not always the case.  Trying to push date to 2040, strongSystem preferences/strong Date&amp;Time responded by setting it to strong01.01.2038/strong (you'll have to uncheck automatically setting)  img src="https://i.stack.imgur.com/cEZwj.png" alt="enter image description here"  That means that it depends on application how will they react to Y2038 bug.  <comment314255> I doubt you will be using the same OS in 2038 <comment314259> @fabriced [People still use the 16-year old Mac OS 9](http://arstechnica.com/apple/2016/09/an-os-9-odyssey-why-do-some-mac-users-still-rely-on-16-year-old-software/), or even earlier (the article mentions some researchers doing DNA synthesis who still use System 7.5). It's not too hard to imagine that people would still use current versions of OS X in 22 years. Regardless, I'm still curious about if this statement that Apple made about Macs being compatible to the year 29,940 still applies to OS X, given that other Unix systems have problems with dates after the year 2038. <comment314260> I use Mac OS 9 myself, but it is an obsolete machine according to Apple, and should therefore be used at your own risk (and at the risk of your data). Apple has become slightly more aggressive regarding obsolete machines (optimization of chargers etc) to force its users upwards. One way to know is to change the date on your computer to 2038. <comment314293> While good to know, I am hoping for an answer that addresses all versions of OS X. <comment314294> The essential point is that El Capitan will not suffer from this bizarre non-problem because it is a highly advanced operating system. See [this page](https://blog.interlinked.org/misc/2038.html) for the same benchmarks for Tiger - Mac OS X 10.4. One can safely assume versions of Mac OS X released after Tiger, all the way to El Capitan and beyond, will not be affected. I do not have a copy of Sierra, yet, but I would think it would not be susceptible to the 2038 'problem'. Anybody out there want to test 10.5.x, 10.6.x, 10.7.x, 10.8.x, 10.9.x and 10.11.x to satisfy this poster's curiosity? <comment314301> It's not a bizarre non-problem for less advances operating systems: even [iOS 6 and Android 4.1 run into it](http://www.informationweek.com/desktop/25-years-from-today-a-time-for-bugs/d/d-id/1108280?), where dates cannot be set past past 2038-01-19 due to this bug. Good to know that 10.4 isn't susceptible. I figure if 10.0 was known to be safe (or even Public Beta, if possible), then that likely means they all are safe. <comment314492> If you think my answer is correct, then mark it as useful! <comment314551> It's correct so far, but incomplete. <comment314584> Well, barring any extraordinary advances in medicine and physics within our lifetimes, I doubt anybody reading this page can show that the assertion: "the statement Apple gave about being compatible to the year 29,940" is provable _without a doubt_. Could you better elucidate _exactly_ what kind of answer you are looking for? <comment314631> My question was "Is any version of OS X/macOS vulnerable to the Year 2038 problem?". Your answer said that El Capitan is not, and the comments said that 10.4 Tiger is not (thus we can assume that the ones in between are not either). If the answer said whether or not 10.0 (or maybe even Public Beta) is vulnerable, we can assume that the other ones in the middle are accounted for. <comment316701> A comment to the other answer said that the error didn't happen for them on 10.4, but it failed for you. Why would that be? <comment318028> @IconDaemon cited [results for 10.4](https://blog.interlinked.org/misc/2038.html) where the clock is stuck at 03:14:07 and never advances to 03:14:08. This looks like a year 2038 problem to me. The program might have cast the count from a double-precision float to a 32-bit integer. Intel and PowerPC processors seem to handle this cast differently. I wrote [a C program with such a cast](https://goo.gl/c3hCPR). <comment371872> So, is there a connection between Friday the 13th and Y2038? :)
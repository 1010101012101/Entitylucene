List All Files in USB device from /Volumes Shell Script <body> To clear things up I have setup folder actions on my mac for whenever a USB device is plugged into my mac it will run a shell script.  When I list all files in the Directory /Volumes i get  precode$ ls -a .       ..      .DS_Store   MobileBackups   Storage     WED /code/pre  What I want to do is list all folders and files located in WED or any USB that pops up, so therefore excluding the directories  precode.       ..      .DS_Store   MobileBackups   Storage /code/pre  Leaving me with  precodeWED /code/pre  What i have for the script so far is:  precodeGLOBIGNORE='/Volumes/MobileBackups*':'/Volumes/Storage*' find '/Volumes' &gt;&gt; /Users/Brett/dev/USBLOGS/LogUSB.txt /code/pre  I have tried multiple different ways but it still ends up listing every single file in the /Volumes directory.  Any help would be greatly appreciated. Thanks, Brett  Additionally, it is MAC OS X El Capitan  <answer223129> My /Volumes dir:  precode ➜  /Volumes  ls BOOTCAMP      Cool Stuff    Macintosh HD  Recovery HD /code/pre  This command lists only files on the Recovery HD:  precode➜  /Volumes  find . -type d \( -name BOOTCAMP -o -name Cool\ Stuff \) -prune -o -print . ./Macintosh HD ./Recovery HD ./Recovery HD/.fseventsd ./Recovery HD/.fseventsd/no_log ./Recovery HD/.metadata_never_index ./Recovery HD/.Trashes find: ./Recovery HD/.Trashes: Permission denied ./Recovery HD/com.apple.boot.R ./Recovery HD/com.apple.boot.R/Library ...snip... /code/pre  You can tack more drives onto that list:  precode\( -name BOOTCAMP -o -name Cool\ Stuff -o -name Foo -o -name Bar -o -name Baz \) /code/pre  Found here: http://www.theunixschool.com/2012/07/find-command-15-examples-to-exclude.html  <answer223144> Since you only want codefind/code to act on USB block devices the following is an example of using information reported by System Profiler to get the Mount Point of any attached and mounted USB block device.  By doing it this way it doesn't matter what other mount points exist under code/Volumes/code nor does it matter what the USB block device name is as it's ascertained from System Profiler not the codels/code command.  I've modified the code, once again, removing the compound command line as it not likely it would be run that way anyway and is easier to maintain in script form while adding the ability to handle spaces in the label name of the USB block device.  By temporarily changing the Internal Field Separator code$IFS/code, adding codeIFS=$'\n'/code to the script will ignore the space(s) as a separator in the output of codegrep/code when passed to codefind/code.  So as not to mess with any code in the rest of your script I fist get the state of code$IFS/code and then rest it afterwards.  In a bash script:  precode#!/bin/bash  _ifs="$IFS" IFS=$'\n' for p in $(system_profiler SPUSBDataType | grep -oE '/Volumes/.*$'); do     if [ -n "$p" ]; then         find "$p"/*     fi done &gt;&gt; filename.txt  IFS="$_ifs" /code/pre  The codesystem_profiler SPUSBDataType/code outputs info on the USB Bus and pipes it through codegrep/code to get code/Volumes/$whatever/code e.g. code/Volumes/USB Drive/code using code-oE/code for the code'/Volumes/.*$'/code which outputs code/Volumes//code and everything after it to the end of the line, thus code'/Volumes/.*$'/code will translate the fully qualified pathname of the mount point of any mounted USB block devices.  So whatever the USB block device is mounted as, it's assigned to code$p/code (I picked "p" for empath/em) and when used with codefind/code I added the code/*/code after it so it would not output the emdotfiles/em.  The codeif/code block is there to avoid any output if no USB block devices are mounted.  <answer223257> Here's a variation of user3439894 solution without setting IFS or looping.  precodesystem_profiler SPUSBDataType | awk -F": " '/Mount Point/ {printf("%s%c", $2, 0)}' | xargs -0 -IX find X &gt;outfile /code/pre  Data is parsed from codesystem_profiler/code with codeawk/code. codeawk/code prints the mount points terminated with the null character which is then piped to codexargs/code and the results are written to codeoutfile/code.  To exclude dot files from the output add the option ! -name (not name) and ! -path (not path) to the find command.  precodesystem_profiler SPUSBDataType                       | awk -F": " '/Mount Point/ {printf("%s%c", $2, 0)}'  | xargs -0 -IX find X ! -name '.*'  ! -path 'X/.*/*' 2&gt;/dev/null &gt;outfile /code/pre  <comment270452> Thank you thank you! I'll play around with this and see how things turn out <comment270454> When adding on more names where does -prune come in, would that be the last one before print? <comment270457> find . -type d \( -name MobileBackups -o -name Storage -o -name .DS_Store -o -name '*/*/.*' \) -prune -o  -print  So I have this here and I works perfect except for the fact that within the   ./WED drive it shows ./WED/.fsevent and other .something files.  I tried to exclude those but it didnt seem to work. <comment270466> OMG thats amazing thank you!!! <comment270468> find . -type d \( -name Boxcryptor -o -name Bitcasa\ Drive -o -name BOOTCAMP -o -name C -o -name Cloud\ Drive  \) -prune -o -print | egrep -i -v -e "\./[A-Za-z0-9].*/\..*"  gives me a list without any top-level dot-files. <comment270485> Thank you this was exactly what I needed and is a great explanation as I'm still learning bash. <comment270489> @BrettReinhard, If you need any further explanation just ask. <comment270552> Now in the light of day and looking back at what I wrote last night I have modified the code to only use `grep` once and as now written it can return just the fully qualified pathname(s) of the mounted USB block device(s) from the output of System Profiler in one `grep` process (per mounded USB block device). I guess I was too tired to see it last night. :) <comment270615> Modified the code once again to handle spaces in the label of the USB block device. Sorry for any confusion with all of this. :) <comment270617> Can you explain to me the declarations before the for statement I'm still iffy with the syntax of things. <comment270666> @BrettReinhard, I wrote a detailed explanation however it would fill 3 separate comments so I don't think I should post that much as comments so first read [this from Wikipedia](https://en.wikipedia.org/wiki/Internal_field_separator) and the `$IFS` section in [Advanced Bash-Scripting Guide: 9.1. Internal Variables](http://tldp.org/LDP/abs/html/internalvariables.html) for a better understanding of the Internal Field Separator Bash Variable [`$IFS`].  Then if you don't understand why I wrote it the way I did, I'll see if I can narrow it down to one comment field (600 character max). <comment270686> I keep telling myself I need to learn `awk`! :) Base on comments to chazlarson's answer Brett doesn't want the dot-files to show, so can your example be modified easily to exclude them in the output?  Anyway, nice answer! +1
How can I make 'rm' move files to the trash can? <body> I use the terminal on a daily basis, I will often use coderm DirectoryName/code. Sometimes I get a little crazy and do coderm */code. As you can imagine, these shenanigans have sometimes come back and hit me in the face. Does anyone know how I create a mapping so coderm whatever/code moves everything to the trashcan which I then delete manually.   <answer17625> I can think of a dozen ways to code this, but categorically refuse to type any of them up in an answer. I strongstrongly/strong recommend you curb your habit of emgetting a little crazy/em. You shouldn't be in the habit of using coderm/code at all if you can't use it properly.  The fundamental problem here is that even if you install a safety net on your own system, that will only help you keep your bad habits and when you happen to be on another machine some day that doesn't have the same custom protections, you will do something epicly bad.  The proper solution is to use coderm/code as it was meant to be used including manually adding the code-i/code argument whenever you are in doubt about how a glob will expand, and have good system backups that you can restore in the event of serious user error. Trying to add "trash" to commands that in the rest of the universe don't use it is a half-way step that is the worst of both worlds.  strongemEither use the trash or don't./em/strong Using coderm/code doesn't go to trash, it removes.  If you want to use the trash, there is nothing wrong with that. Just get in the habit of using the codermtrash/code command instead of coderm/code. This will help your brain understand what's happening and not get you into a bad habit that will cause grief later.  <answer17626> Use a command line tool like rmtrash or a script tat uses appscript to call the Finder to do there delete.  After installing rmtras to say /usr/local/bin/rmtrash the creat an alias for bash  precodealias rm='rmtrash' /code/pre  You can use \rm to call rm directly and ignore the alias  <answer17637> h2Bad Idea/h2  Using coderm/code to move files to trash is like weed. It is common and pleasuring but strongemcan be bad for you/em/strong in the future. ;)  You really need control yourself when using coderm/code.  hr  h2Don't use emrm/em/h2  strongImagine/strong, you get used to emrm moving to trash/em and make a habit of it. Sure, your system is safe but when you log into a friend's (or your wife's or your boss') notebook and have to delete something? You'll be actually using the real coderm/code - deleting those files forever. It's a bad habit, and you need to know that.  So instead, install codermtrash/code and make a habit of using it:  pre class="lang-bsh prettyprint-override"code# install rmtrash, (either from the macports or by the brew.) $ alias trash="rmtrash" $ alias   del="rmtrash"       # del / trash are shorter than rmtrash /code/pre  hr  h2Correcting bad habits/h2  Another thing you can do to force yourself to use codermtrash/code instead of coderm/code is alias it to a custom message in your code.profile/code.  pre class="lang-bsh prettyprint-override"codealias rm="echo Use 'del', or the full path i.e. '/bin/rm'" /code/pre  So, whenever you use coderm/code, you'll be prompted to either use codermtrash/code or code/bin/rm/code. Remember, this is only temporary, after a while you should remove the alias.  hr  Never ever, do something like this:  pre class="lang-bsh prettyprint-override"code$ pwd / $ cd /tnp; rm -rf * sh: cd: /tnp: No such file or directory /code/pre  emPop Quiz: In what directory will the coderm/codecommand run?/em :)  Ps: Just removed some unwanted edits to this post, what added some nonsenses about the aliases.  <answer134330> h2strongIntroduction (you can skip it)/strong/h2  For me coderm -i/code would be enough, because it prompts you before deleting any file. However, some extra security provided by codesafe-rm/code isn't a bad idea at all.  A simple codealias/code like coderm=safe-rm -i/code emcould/em be enough, however coderm -rf/code would not work, because code-i/code is overriden by code-f/code.  So, we have to make sure that code-i/code always come after code-f/code!  hr  h2strongMy solution (3 steps):/strong/h2  ul liInstall safe-rm: codebrew install safe-rm/code  You can still work with coderm/code, but you have modify the codeRM_BIN/code in the next step/li liEdit your code~/.profile/code (or bash_profile or whatever), and put the following code snippet, (which contain an codealias/code and a codefunction/code):  precodealias rm="rm_i"  function rm_i(){ RM_BIN=safe-rm # you can replace it with regular rm if you like  args="" files="" argsDone=0 # to make sure arguments are before the files  for var in "$@" do     if [[ $var == \-* ]] ; then         if [ $argsDone -eq 1 ] ; then             $RM_BIN # just to show the usage of rm             return         fi         args+=" $var"     else         argsDone=1         files+=" $var"     fi done  args+=" -i" # Put -i at the end (so rm -rf will not ignore it)  $RM_BIN $args $files } /code/pre/li listrongFinally/strong, codelogout/code and codelogin/code, so the updates in the .profile are applied. strongDON'T/strong use it before a logout/login!/li /ul  hr  h2strongNotes:/strong/h2  ul liIt can be applied to any Linux distro, with slight modifications./li liIt does NOT move your staff to thrash. It just asks you before deleting each file!/li liIt works with code-rf/code and with regexes./li liIf you really want to use coderm -rf/code strongWITHOUT/strong being asked for every single file/folder you can still use code/bin/rm -rf/code (or codesafe-rm -rf/code if you had installed it)./li listrongNo more unintentional/strong coderm -rf/code strongor/strong coderm */code ;)/li /ul  <answer226023> Just want to add a helpful habit to get into for those that don't do this already.  Before using rm for anything, do 'ls' on it first.  That way you can see all the files that you intend to delete.  Then instead of retyping, just pull previous 'ls' command up and swap out ls for rm. This habit has reduced a lot of anxiety when invoking rm.   <comment19240> you can do `mv /file/to/delete ~./Trash` <comment19242> If you do use a tool like `rmtrash`, please do yourself a favor and **use it by it's own name**. Never alias things that are not `rm` to `rm`, it will some day bite you. <comment19276> It's hard to put training wheels on a precision tool like rm without breaking other scripts. Something like `alias rm=/bin/rm -i` should get you safely _trained out of your crazy_. Also - which Trash directory do you want rm to use? It gets clunky since Mac OS X has a trash directory for each volume as well as a user level trash can. <comment19408> `&&` is your lifeline. `;` is the devil. P.S. The answer is that pretty much everything on your system disappears, in the above example. <comment19683> Your point doesn't compute in this instance. People delete things accidentally on a daily basis, system backups do not work in the case of a home pc (which mine is) as the resources are limited, a move to trash can is a far more efficient way of handling these deletions for my particular use case. <comment19684> @steve you missed the point entirely. `rm` by definition removes a file from the disk. It doesn't send it to the trash. Teaching yourself to use `rm` when you mean _send to trash_ sets you up for disaster. If you want to send to trash, use `rmtrash` or a program that was designed for the job, then you won't run into nightmares later. I wasn't saying using the trash is inherently wrong, but if you want to use it, don't wire it up to something that was not intended to use it! <comment110130> If you use zsh, by default it will prompt you when you do `rm *` or `rm /path/*` <comment139981> `brew install rmtrash` and stop using `rm` <comment161638> Aliasing rm to anything larger than itself (e.g. `alias rm='sudo rm'`) is like strapping a Uzi to a kitchen knife: someday you will get more than you bargained for when you go to cut that pineapple. Aliasing rm to anything smaller than itself (e.g. `alias rm='rmtrash'`) is like letting your children play with disarmed hand grenades and not teaching them what they actually are: someday when they encounter a real one they won't treat it with the proper caution. **Either way—aliasing rm is bad for your personal safety and public health!** <comment161639> Using something like safe-rm is reasonable advice. Aliasing it to rm is not. Use it under its own name or a unique alias so you don't take for granted a safety net that will not always be there. <comment161692> I see your point. BUT, the reason I did this, is that I work with many terminals.. some remote terminals, and some locals. And I want to throw lot of **grenades** on the remote terminals, but when I accidentally pull the **safety seal** on the local terminal, I want to see a **warning** before the **explosion** occurs. <comment162515> @Paschalis and what happens if a script or installed program needs to use `rm`? Also, Caleb's point is even more valid -- if you get used to a system with safe-rm aliased, then you might get reckless with it and eventually use it on a system with an unaliased rm. <comment178644> Although, rm doesnt do secure delete, but moving to trash / empty does (in my setup) . <comment202662> This is an awesome answer, cleared up a few things for me. I'll try to form a habit of using `rmtrash` instead of `rm`. <comment277911> Debian/Ubuntu users install `trash-cli` instead, ex. `aptitude install trash-cli` - see https://github.com/andreafrancia/trash-cli <comment357213> Great answer! Thanks thanks! <comment364806> @jm666 Also check out **trash** ([blog post](http://hasseg.org/blog/post/406/trash-files-from-the-os-x-command-line/) &  [source](https://github.com/ali-rantakari/trash)). It asks Finder for trashing files. Moreover it can also use standard Objective C filesystem APIs (faster) and fallback to Finder if insufficient rights. [`brew install trash`](https://github.com/mxcl/homebrew/blob/master/Library/Formula/trash.rb) <comment368144> `rmtrash` isn't compatible with `rm` (doesn't support the same command line parameters like `-r`) so an alias really isn't useful in any case
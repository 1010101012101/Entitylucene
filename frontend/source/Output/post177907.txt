How to identify file type for a bulk lot of files and attach suitable extension to each <body> I have just over a thousand (1000) files whose suffix/extension has been changed by a database engine all to the same thing (eg. fileName.abcd where .abcd is on every file regardless of whether it is a jpg, pdf, or whatever else).  The goal is to convert all the files to PDF but I first just want to sort the various file types into separate folders.  I use Mac OS X and figure that there must be a Terminal script that would:  ol liIdentify the file (Perhaps with 'File' command?) and then.../li liAppend the appropriate extension which would then.../li liAllow me to manually sort and place them into seperate folders for further processing depending on their file type./li /ol  Using the Terminal 'File' command on a file with the database suffix, typical results are quite wordy like this, which at least shows the Mac can identify the file types even though they have the 'wrong' suffixes:  ul liJPEG image data, JFIF standard 1.01/li liPDF document, version 1.3/li liRich Text Format data, version 1, ANSI/li lietc./li /ul  So, I only need a script that would tag the files so I can use Automator to rename the files later with the appropriate suffix.  I note that if in Terminal I type 'File' and after that I drop or copy multiple files on to it, and hit return, then Terminal correctly identifies them all in the same order, but it isn't useful unless it at least tags each file type differently.  I figure this initial task is too difficult for Automator but would love to be proven wrong.  Any assistance in doing this would be appreciated. I have checked this board and elsewhere expecting someone else to have had a similar issue but found no such problem listed anywhere.  <answer177915> This is rather easy combining some standard tools:  ul licodefile/code for looking up the mime type/li licodetr/code to remove the slashes (otherwise, you'd have nested folders for different file groups)/li liwell, some obvious codemkdir/code and codemv/code commands/li /ul    precodefor file in * do     mime=$(file --brief --mime-type "$file" | tr '/' '_')     mkdir -p "$mime"     mv "$file" "$mime/$file" done /code/pre  Alternatively, you could also directly list file extensions for each expected mime type and automatically rename them appropriately.  precodefor file in * do     mime=$(file --brief --mime-type "$file")      case "$mime" in     "image/jpeg")         extension="jpeg"         ;;     "text/plain")         extension="txt"         ;;     "application/pdf")         extension="pdf"         ;;     *)         continue;         ;;     esac      filename="${file%.*}"      mv "$file" "$filename.$extension" done /code/pre  Be aware, that for sake of readability I did not take care of file names containing spaces. If you have them, you'll have to apply one of the patterns to deal with spaces in file names. As it rather seems you're not having them I left them out, as they make the scripts looking emmuch/em more complicated as they are.  <comment210611> I like the premiss behind your scripts however with the first one if there are any directories in the directory that script is run on they too get moved into `application_x-directory` and that not good IMO.  It should be coded to not process directories.  You also note _"Be aware, that for sake of readability I did not take care of file names containing spaces."_ however I find both work on filenames with spaces properly. <comment210614> If you apply the pattern for files containing spaces in the link I provided, adding a filter `-type f` to `find` is all you have to do to exclude directories. <comment210635> I think you're missing the point, in the first script you posted code that's inherently broken per the OP to act on files with invalid extensions not directories and providing a broken script while providing a link to fix it is a bit ridiculous.  Had you just, per my suggestion, added something like `if [[ ! -d "$file" ]]; then ...` to it I would have up-voted it. <comment210827> Thanks, Jens. That answer was even better than I had expected. I really should learn this Terminal stuff. It seems far more efficient than any GUI. <comment211613> @user3439894 is correct: there is absolutely nothing to do to make this work with file names containing spaces â€“ escaping all uses of `$file`, as the example scripts do, is enough (see [the BashFAQ](http://mywiki.wooledge.org/BashFAQ/020) for details on why this is so). The relevant paragraph and link need to be removed, as they are both irrelevant and detracting form the answer.
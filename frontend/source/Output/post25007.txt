Lots of inactive memory after watching HD/DVD movies <body> I'm the owner of mid 2010 iMac (core i7) with 16GB memory installed.br/Normally, Mac OS X (SL and Lion) never uses emswap/em (that is page ins/outs = 0), there are always 3-8GB of emfree/em memory. br/But after watching a few DVD/h264 movies, there are only 50-100*emMB/em* of emfree/em memory and emswap/em is used actively. Looks like video files are mapped into system memory, since the amount of eminactive/em memory ~= size of files. The only workaround is to use codepurge/code utility.  I'm looking for a solution which is better than running codepurge/code every time I looked a movie.  uptime:  precode4:08  up 3 days,  7:35, 5 users, load averages: 0,71 0,76 0,71 /code/pre  vm_stat:  precodeMach Virtual Memory Statistics: (page size of 4096 bytes) Pages free:                         738409. Pages active:                      1715722. Pages inactive:                     536891. Pages speculative:                  857329. Pages wired down:                   344323. "Translation faults":           1067897384. Pages copy-on-write:               6068992. Pages zero filled:               591232281. Pages reactivated:                 1906255. Pageins:                           5019598. Pageouts:                           861857. Object cache: 16 hits of 1354202 lookups (0% hit rate) /code/pre  <answer25018> For what I know (and have noticed) you don't have to worry about this "inactive" memory. The system will reallocate it on demand. It happens when the system have huge file transfer to process. This kind of operation use as much memory as possible to speed up the process. When the transfer is finished, the memory state remains as "inactive", but you could as well considered as free...  <answer25036> What you're seeing is normal, and desired behavior.  OS X, like Linux and BSD, has a disk cache. This means anything read from or written to disk is kept in memory. The "Inactive" memory includes this disk cache.  This answer on AskDifferent explains it, as does this post on macosxhints.com:     However, X's underpinnings (ie the UN*X kernel) provide both these   features without any inputs being needed by the user. It's called the   file system buffer cache. The one most significant difference is that   the size of this buffer cache is dynamic. It starts of with some small   size and can grow and shrink as the i/o demands and Apps memory   requirements vary over time.       It's called a 'buffer cache' because it buffers the i/o data on its   way to/from the disk. When an App writes data it first will be   deposited into the Apps file buffer memory region and will   subsequently be requested via library routines to have the kernel (the   OS) copy it from the App's buffer to disk. The kernel will oblige and   will copy it first to its buffer -- the file system buffer cache. If   the kernel requires more room in its buffer cache it will obtain it   from the free memory. When this happens the free memory value, in say   the Terminal's top command, will immediately show a reduction of free   memory. At some later point the kernel will copy this data (referred   to has dirty buffers) to the appropriate disk location. I believe the   frequency of this being done is 30 secs -- called sync-ing to disk.   Note that having memory paged out to disk strongis not always a bad thing/strong. If memory pages are completely inactive, paging them out to disk emcan improve performance/em, because they are wasting RAM which could otherwise be used for disk cache. Once they are paged out and you stop watching movies, when needed they will be paged back in, automatically replacing the buffers and disk cache. You don't need to run codepurge/code each time. Just let OS X manage the disk cache as it was designed to do.  For more information on this, consult the wikipedia article on paging, and the article on the Page cache.  hr  TL;DR information:  Here's an article describing how swap works under Linux. WHile not 100% applicable to OS X, the concept is the same. I'll quote the relevant part:     When an application needs memory and all the RAM is fully occupied,   the kernel has two ways to free some memory at its disposal: it can   either reduce the disk cache in the RAM by eliminating the oldest data   or it may swap some less used portions (pages) of programs out to the   swap partition on disk. It is not easy to predict which method would   be more efficient. The kernel makes a choice by roughly guessing the   effectiveness of the two methods at a given instant, based on the   recent history of activity   Since you're watching a DVD or a movie, the most recently active pages of memory are the disk cache, so OS X decides to keep that in RAM and swap out pages of memory which have been inactive from before you started accessing the video files. Once you stop accessing video files and access the programs using the memory pages which were swapped out, the reverse is true: OS X will discard the disk cache containing the video data and replace it with the memory pages which it swapped out. Then your swap usage will decrease.  Here's a bit more information, specific to FreeBSD (which is similar to Mac OS X):     FreeBSD will use 'all of memory' for the disk cache. What this means    is that the 'free' bucket typically contains only a few pages in it.    If the system runs out, it can free up more pages from the cache   bucket.      System activity works like this: When a program actively references  a   page in a file on the disk (etc...) the page is brought into the    buffer cache via a physical I/O operation. It typically goes into  the   'active' bucket. If a program stops referencing the page, the  page   slowly migrates down into the inactive or cache buckets (depending  on   whether it is dirty or not). Dirty pages are slowly 'cleaned' by    writing them to their backing store and moved from inactive to cache,    and cache pages are freed as necessary to maintain a minimum number of   truely free pages in the free bucket. These pages can still be    'cleaned' by allocating swap as their backing store, allowing them  to   migrate through the buckets and eventually be reused.      [...]      The VM buffer cache caches everything the underlying storage so, for    example, it will not only cache the data blocks associated with a file   but it will cache the inode blocks and bitmap blocks as well. Most    filesystem operations thus go very fast even for tripple-indirect   block  lookups and such      [...]      FreeBSD has arguably some of the best swap code in existance. I   personally  like it better then Linux's. Linux is lighter on swap, but   doesn't  balance system memory resource utilization well under varying   load  conditions. FreeBSD does.      strongFreeBSD notes the uselessness of existing pages in memory, and decides   that it might be advantageous to free memory (enabled by pushing pages   to swap), so that it can be used for more active purposes (such as   file  buffering, or more program space.) It is a terrible waste to   keep unused  pages around, for the notion of saving (cheap) disk   space./strong Since low  level SWAP I/O can be faster, with less CPU overhead   than file I/O, it  is likely desireable to push such unused pages out   so that they can be  freed for use by higher overhead mechanisms.   (note 1)   (Emphasis mine, check that bolded part for specifically what you're asking about, that is, "Why is swap being used when I have inactive memory?)  <comment28172> What video players are you using? Also keep in mind, the system will always try to get to 50 to 100 MB free memory, so that means things are working properly. What also do you mean by "swap is used actively"? <comment28173> QuickTime/built-it DVD player/VLC/MPlayerX. I mean date is written and read from swap for almost every operation. <comment28175> What process is OS trying to speed up if I properly quit all video players after watching a movie? Why does it use hard drive (where swap is located) instead of reusing *inactive* memory? <comment28176> QuickTime and DVD player swap minimally on my lion machines. Even on an air with 2 GB RAM, playing video doesn't cause even the second swap file to get created on disk. <comment28193> @Kentzo: The OS automatically caches disk reads into free RAM. Memory pages which have been inactive for a long time are paged out to disk to make room for disk cache/buffers as this can actually *increase* performance. I put that in my answer, and am looking for a reference to back that up with. <comment28195> @bmike: It's not QuickTime  swapping, it's the OS caching every disk read that he's seeing. Because his other memory pages are inactive for longer than the disk cache, they get swapped out first. **This is normal and desired behavior**. <comment28196> I don't want to say caching is bad thing and I know its purpose. The bad thing is that I have 16GB of memory (which is enough to keep almost all data/code I use in memory) and OSX uses swap because half of it keeps huge cached video files. I'd like to set caching policy to release files from cache when amount of available memory approaches e.g. 100-200MB. <comment28197> Outstanding answer Josh! A shame it looks to be lost on the OP. I've never understood users that don't quite understand how the system works but want to alter it's behavior all the same. @Kentzo, you cannot adjust such things. They are not open to user control. <comment28198> I never said I'm looking for a userland. If there are kernel-side functions to control the caching policy, just point me, I'll do the rest. The idea was someone already encountered that problem and already wrote a daemon/script. <comment28202> @Kentzo: You said, "The bad thing is that I have 16GB of memory and OSX uses swap because half of it keeps huge cached video files". It should do that only when you're not using the memory pages which get swapped out. Swap is not bad. The pages should be swapped right back in when you're done watching video files. <comment28205> @Josh: They don't: I end up with extensively working hard drive and usually ~8-10GB of inactive memory. Can I limit maximum amount of inactive memory? <comment28207> @Kentzo: Okay. This may be a different issue from what I thought then... During these times, what does the "Swap used" in Activity Monitor say? (**Not** the "VM Size" label) Did you quit QuickTime or VLC? Is your hard drive actually *[thrashing](http://en.wikipedia.org/wiki/Thrashing_(computer_science%29)*? You would know because "Page Outs" will be increasing very quickly. <comment28208> @Kentzo why exactly do you want to do that? What do you gain? Are you looking for faster performance? Is there a specific downside to your current setup? Can you give us more reason why what you have now doesn't work and why you think that only by manually controlling caching can you make it faster? <comment28209> Try setting your pagefile size to around 250MB. See if you witness the same behavior. (I don't even know that you can _do_ that on OSX.) What it's doing is copying the stuff in for the video, and making it all contiguous for playback. Also, verify that it does this when you're playing a DVD directly off the rotating shiny optical disk, instead of playing a DVD rip to your HDD.  If it does the EXACT SAME THING with a shiny optical coaster, then you know that you've probably found a bug with the OSX apps, and not with the kernel. <comment28210> @jcolebrand: Yes, there is a huge degradation of performance, almost every operation causes hard disc IO. <comment28211> @Josh: VM Size: 3.41GB. But OSX operates normal currently. I've updated the question and added the result of vm_stat. <comment28214> @Kentzo: **VM Size is not swap used**. Read [this](http://forums.macrumors.com/showthread.php?t=794368), or [this](http://support.apple.com/kb/ht1342) or [this](http://hints.macworld.com/article.php?story=20010613140025184). What does **Swap Used** say? <comment28216> @Josh: Sorry, correct value for a wrong label. Swap used: 3.41GB <comment28222> OK... I'll need to research this further and get back to you... <comment28733> I am unable to reproduce the behavior you're seeing... I'm on 10.6 however. It's *possible* this is a 10.7 issue, but I don't have Lion yet so I can't test that.
Can I force my Mac to make better use of the inactive memory? <body> I use mysql and it takes up to 2.5 GB of my ram. I checked activity monitor and saw that I have 1GB of inactive memory but it never changes even if I have only 10MB active free memory. Is there any way to force the inactive memory to be used?  <answer10393> You can think of inactive memory like free memory that's been reserved for a recently closed application, but will be used when 'true' free memory has been exhausted.  If you have 1 GB of memory (for the sake of making this discussion easier) on a freshly booted system, imagine the OS uses 300 MB and you open an app that uses 200 MB.  You now have a total of 500 MB used, and 500 free.  If you close that app that was using 200 MB, the memory is marked inactive and you'll now have 300 used (OS), 200 inactive, and 500 free.  If you open an app that requires 600 MB, it'll use the free memory then pull from the inactive pool.  You can free inactive memory by opening Terminal.app and typing (without the $):  precode $ purge /code/pre  You can, also configure MySQL to use more memory but if you're not having performance problems I'd leave everything alone:  ul lihttp://dev.mysql.com/doc/refman/5.0/en/innodb-configuration.html/li lihttp://dev.mysql.com/doc/refman/5.0/en/memory-use.html/li /ul  For more information on inactive memory in OS X:  ul lihttp://support.apple.com/kb/ht1342 (search for "inactive memory")/li lihttp://hints.macworld.com/article.php?story=20010613140025184/li lihttp://goo.gl/abnui/li /ul  (The last link emmight/em require an Apple developer account)  <answer10395> To expand Aaron's answer:  Your case could be a problem with MySQL taking too much resources, but Inactive Memory is like Free Memory for the Operating System. The difference between Inactive and Free is that Inactive was emrecently/em used, so if you for example open iTunes and it uses 200MB, when you close it, the program gets closed, the memory of iTunes marked as Inactive but it remains like that emunless its needed again/em. But if you happen to re-open iTunes, OS X knows that it's there already and inactive, so it marks it as active again and voil√°, that was faster than having to reload it from the slower hard drive.   Provide more information about your computer to help find the cause of your "slow" system.  emupdate/em: Here's more info about Memory and OS X (from Apple):   http://support.apple.com/kb/ht1342  <comment10913> Thanx for your answer but my problem is my system gets really slow but it doesn't use the inactive memory. <comment10914> I corrected myself, you can purge inactive memory (whoops!), see the updated reply.  Also, it sounds like you have something else going on.  Are you running any VMs?  Lots of open applications?  Are you sure it's a memory issue?  Maybe CPU bottleneck?  Disk I/O? <comment10918> I am running mysql with huge queries. I don't have any other large application running. <comment10920> for example I have this in my activity monitor : mysqld - 2.2 GB oovoo - 190 MB kernel - 150 MB firefox - 148 MB and other apps. I have 26MB free memory and 1GB inactive memory and my system is a little slow right now but my inactive memory does not change. <comment10931> @AliBZ: Is the "Swap outs" count in Activity Monitor climbing?  That's the best indicator I know of that the system is really out of useable RAM (and having to swap memory contents out to disk to make room).  Note that "Page ins" are not a useful indicator, as they'll climb every time a program is launched from disk (unless it happens to be already in inactive RAM). <comment10944> @AliBZ: _my system gets really slow but it doesn't use the inactive memory_ : System can be slow also because of CPU usage. Did you check this? <comment52059> This is a very nice theoretical view of the system, which is exactly what Apple claims. But I have the same pb as the OP, and `purge` freezes my system for a few second and does ... nothing at all (at least with respect to the inactive memory pb). And yes, my system is swapping too even though I should have more than 1GB of RAM free. <comment161322> @PierreBdR, it's more than a theory/claim: it's how the kernel works.  The behavior you experience with `purge` is exactly expected - you told the kernel to flush all of the inactive pages Right Now, so it stopped the world and examined all of them -- writing any buffered output to disk, putting the pages back on the free list, etc.  But if your system is swapping, the inactive list is going to immediately grow again as the system (again stops the world &) brings those now-flushed-but-previously-cached virtual memory pages back in from disk (and puts to-be-paged-out ones on the inactive list). <comment162000> @jhfrontz that is simply a lie! The inactive memory is NEVER re-used when needed by applications. This is just what Apple would have us think. The truth is they wanted this behaviour (maybe?) but have been unable to implement it correctly. <comment162284> @PierreBdR What's the basis for your assertion?  Have you used a kernel debugger and actually tracked a candidate physical page on the inactive list and watched as an [otherwise still] active page was [not put on the inactive list but ] paged directly out with another virtual page taking the newly freed physical page?  Have you looked at the kernel memory management code and found a bug? <comment163277> @jhfrontz I used a very advanced protocol: use the computer until you have about 1GB of inactive memory. Start an application needing a LOT of RAM, see how instead of freeing the inactive memory so your application can use it, your computer start swapping like crazy. As this is against the specs, note that as a bug. <comment163442> @PierreBdR that doesn't prove your point. There are many other variables to the experiment that you're not controlling for (e.g., concurrent open applications/files, history of applications/files/work done since boot time, etc.).  In your experiment, you'd need to know exactly what is on the "inactive list" and how dynamic it is with respect to the EXACT ADDRESS & CONTENT OF PAGES PRESENT, not the count of pages; the count of pages (which as you saw -- and as I would expect) remain fairly constant unless you change the active applications/workload, kernel tune/watermark-threshold values, etc. <comment163443> @jhfrontz yes it does. It is well reported that Mac OS X has never managed inactive memory properly. And every time there is an Apple advocate (you in this case) trying to muddle the case, but this is a massive, annoying bug rendering Apple computers unusable for memory intensive tasks. Instead of denying, Apple should work on correcting this very long standing bug that affect everybody using their computers. <comment163561> @PierreBdR the only "reports" I've ever seen are from people who don't understand how virtual memory works.  See http://apple.stackexchange.com/a/67048/10389 for an excellent discussion by bmike. <comment163819> @jhfrontz I feel I am feeding the troll now. But "Inactive memory" is what is called "Cache" on Linux or Windows. And when the cache is happily and silently removed when the memory is needed for an active process, this just never happens for Mac OS X's inactive memory. And instead of being a speed up, it becomes a massive slow down because applications then need to swap while you still have 1GB+ of memory that should be usable. So yes, this IS a bug, and this is something most other OS do right, and Mac OS X does wrong. <comment163824> @PierreBdR You continue to make assertions without giving any definitive proof/citations.  I again refer you to http://apple.stackexchange.com/a/67048/10389 and invite you to share how you know otherwise. <comment163828> Also, check http://developer.apple.com/library/mac/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html <comment163853> @jhfrontz I made assertion made on data I collected when I had a mac. I invite you to look at the other answers for the question you indicate ... there are more than one going my way (things like "That's why some people use scripts to purge memory in background with low IO priority"). If the system worked properly, that should happen: "When the number of pages on the free list falls below a threshold (determined by the size of physical memory), the pager attempts to balance the queues. It does this by pulling pages from the inactive list." (from the link you gave last), but it never does! <comment163876> @PierreBdR That people do ridiculous things doesn't mean they're well-reasoned (look up "Cargo cult science").  And I again ask: how do you KNOW that it wasn't pulling pages from the inactive list?  Just because the count remained the same doesn't mean that it wasn't pulling them off-- instead, it means that they were being put on as fast as they were taken off (i.e., you have insufficient physical memory).  I again invite you to read this and actually learn how VM works: https://developer.apple.com/library/mac/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html <comment163934> @jhfrontz if the OS puts pages in the inactive list while there is not enough memory to do so, this will still be a bug. As when it does that, it clearly doesn't balance the queues, as claimed in the documentation. In any case, the fact that the system never reduces the number of inactive pages is a bug that goes against what the documentation says. <comment163968> @PierreBdR I again invite you to learn how VM works -- the progression is active-inactive-free.  There is a certain amount of work that potentially must be done to free memory (e.g., flush information to disk, etc.).  That your inactive list appears to have approximately the same number of pages does not mean that they are the same pages-- if you observe this while simultaneously observing swapping activity, it may mean that you don't have enough physical memory to do whatever it is you're trying to do and that the system is working as fast as possible to try and compensate for that. <comment164012> @jhfrontz Maybe **you** should learn how it works and look as other OS for guidance on how it can work well. If the system is too slow to free its inactive memory in minutes so the active task can use all the available (i.e. not wired) memory for itself, then it is incorrect. And once again, looking at the page **you** referenced, this is **not** what should be happening. <comment164158> @PierreBdR  I'm always willing to learn more to expand my nearly 30 years of experience doing work on operating systems, so if you have some authoritative references to share, I'm all eyes.  But I'm not sure how to convince you that you're looking at non-indicative data, making incorrect assumptions, and drawing the wrong conclusions-- inactive memory is freed as soon as the buffer space has been flushed to disk (or the OS has otherwise determined that the memory can be reclaimed).  But on an overtaxed machine, something else is going to be get pushed on to the inactive list to replace it. <comment164524> @jhfrontz if what you say is true, then the scenario I am playing wouldn't work on any OS. But on GNU/Linux and Windows, there is no problem: the **one** application that is current takes all the available memory for its own usage, leaving no inactive memory. The fact Mac OS X still puts pages in inactive memory when an application needs this memory to be active is a bug. Whether the bug is in the design or the implementation, I really couldn't care less. <comment284715> Real world: my OS X computers will slow dramatically when there is little free memory left and lots of inactive memory.